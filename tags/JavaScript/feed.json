{
    "version": "https://jsonfeed.org/version/1",
    "title": "Touko • All posts by \"javascript\" tag",
    "description": "这是一个博客网站，记录我的学习和生活点滴。",
    "home_page_url": "http://toukoxu.github.io",
    "items": [
        {
            "id": "http://toukoxu.github.io/archives/proxy/",
            "url": "http://toukoxu.github.io/archives/proxy/",
            "title": "代理（Proxy）：ES6 元编程的 “对象拦截器”",
            "date_published": "2024-08-15T12:46:25.000Z",
            "content_html": "<blockquote>\n<p><strong>Proxy</strong> 是 ES6 引入的元编程特性，简单说就是给对象 “装一层拦截器”—— 所有对对象的操作（比如读属性、改属性、删属性），都会先经过这层拦截器，我们可以在拦截器里自定义操作逻辑。它的灵活性极高，是 Vue3 响应式、数据验证、API 拦截等场景的核心技术。</p>\n</blockquote>\n<h2 id=\"关联知识\"><a href=\"#关联知识\" class=\"headerlink\" title=\"关联知识\"></a>关联知识</h2><p>可以将 Proxy 和 Reflect 合并在一起学习～</p>\n<div calss=\"anzhiyu-tag-link\"><a class=\"tag-Link\" target=\"_blank\" href=\"/2024/08/14/reflect\">\n    <div class=\"tag-link-tips\">站内地址</div>\n    <div class=\"tag-link-bottom\">\n        <div class=\"tag-link-left\" style=\"background-image: url(/img/512.png)\">\n          <i class=\"anzhiyufont anzhiyu-icon-link\" style=\"display: none\"></i>\n        </div>\n        <div class=\"tag-link-right\">\n            <div class=\"tag-link-title\">Reflect：ES6 标准化对象操作的 “工具库”</div>\n            <div class=\"tag-link-sitename\"> Touko</div>\n        </div>\n        <i class=\"anzhiyufont anzhiyu-icon-angle-right\"></i>\n    </div>\n    </a></div>\n\n<h2 id=\"一、Proxy-的核心：三要素与基础用法\"><a href=\"#一、Proxy-的核心：三要素与基础用法\" class=\"headerlink\" title=\"一、Proxy 的核心：三要素与基础用法\"></a>一、Proxy 的核心：三要素与基础用法</h2><p>Proxy 的使用很直观，核心是 <code>new Proxy(target, handler)</code> 这个构造函数，需要传入两个关键参数：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本语法：创建一个代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(target, handler);</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li><strong>target</strong>：被代理的 “目标对象”（可以是普通对象、数组、函数，甚至另一个代理）。</li>\n<li><strong>handler</strong>：“拦截器配置对象”，里面定义了各种 “拦截方法”（比如 <code>get</code> 拦截读操作，<code>set</code> 拦截写操作）。</li>\n<li><strong>proxy</strong>：生成的 “代理对象”—— 后续操作都要通过这个代理对象，才能触发拦截逻辑。</li>\n</ul>\n<p>举个最简单的例子：给普通对象加一层拦截，监控属性的读写：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 目标对象：一个普通用户对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = { <span class=\"attr\">name</span>: <span class=\"string\">'Alice'</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 拦截器配置：定义要拦截的操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> userHandler = {</span><br><span class=\"line\">  <span class=\"comment\">// 拦截“读属性”操作（比如 proxy.name）</span></span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`正在读取属性：<span class=\"subst\">${propKey}</span>`</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 用 Reflect.get 保持默认读逻辑（避免破坏原对象行为）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"comment\">// 拦截“写属性”操作（比如 proxy.age = 29）</span></span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">target, propKey, value</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`正在修改属性 <span class=\"subst\">${propKey}</span>：从 <span class=\"subst\">${target[propKey]}</span> 改成 <span class=\"subst\">${value}</span>`</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 用 Reflect.set 保持默认写逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, propKey, value);</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxyUser = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(user, userHandler);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试拦截效果</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(proxyUser.<span class=\"property\">name</span>); <span class=\"comment\">// 触发 get：输出“正在读取属性：name”，再输出“Alice”</span></span><br><span class=\"line\">proxyUser.<span class=\"property\">age</span> = <span class=\"number\">29</span>; <span class=\"comment\">// 触发 set：输出“正在修改属性 age：从 28 改成 29”</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"二、13-种核心拦截方法：覆盖所有对象操作\"><a href=\"#二、13-种核心拦截方法：覆盖所有对象操作\" class=\"headerlink\" title=\"二、13 种核心拦截方法：覆盖所有对象操作\"></a>二、13 种核心拦截方法：覆盖所有对象操作</h2><p>Proxy 提供了 13 种拦截方法，覆盖了对象的几乎所有基础操作。我整理了日常开发中最常用的几种，按使用频率排序：</p>\n<table>\n<thead>\n<tr>\n<th>拦截器方法</th>\n<th>触发时机</th>\n<th>示例</th>\n<th>核心作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>get(target, propKey, receiver)</code></td>\n<td>读取对象属性时</td>\n<td><code>proxy.name</code>、<code>proxy[0]</code></td>\n<td>监控属性读取、返回自定义值（比如默认值）</td>\n</tr>\n<tr>\n<td><code>set(target, propKey, value, receiver)</code></td>\n<td>设置对象属性时</td>\n<td><code>proxy.age = 30</code></td>\n<td>验证属性值、监控属性修改</td>\n</tr>\n<tr>\n<td><code>has(target, propKey)</code></td>\n<td>使用 <code>in</code> 操作符时</td>\n<td><code>'name' in proxy</code></td>\n<td>自定义 “属性是否存在” 的判断逻辑</td>\n</tr>\n<tr>\n<td><code>deleteProperty(target, propKey)</code></td>\n<td>使用 <code>delete</code> 操作时</td>\n<td><code>delete proxy.age</code></td>\n<td>监控属性删除、阻止敏感属性删除</td>\n</tr>\n<tr>\n<td><code>apply(target, thisArg, args)</code></td>\n<td>代理的目标是函数，且函数被调用时</td>\n<td><code>proxy(1, 2)</code></td>\n<td>拦截函数调用、修改参数或返回值</td>\n</tr>\n<tr>\n<td><code>construct(target, args)</code></td>\n<td>代理的目标是构造函数，且用 <code>new</code> 创建实例时</td>\n<td><code>new proxy(1, 2)</code></td>\n<td>拦截实例创建、修改实例属性</td>\n</tr>\n<tr>\n<td><code>ownKeys(target)</code></td>\n<td>遍历对象属性时（如 <code>Object.keys(proxy)</code>、<code>for...in</code>）</td>\n<td><code>Object.keys(proxy)</code></td>\n<td>自定义遍历返回的属性列表（比如隐藏敏感属性）</td>\n</tr>\n</tbody></table>\n<p>其他拦截方法多用于底层元编程，日常开发中较少直接使用，了解即可。</p>\n<ul>\n<li>getOwnPropertyDescriptor(target, propKey)</li>\n<li>defineProperty(target, propKey, propDesc)</li>\n<li>preventExtensions(target)</li>\n<li>getPrototypeOf(target)</li>\n<li>isExtensible(target)</li>\n<li>setPrototypeOf(target, proto)</li>\n</ul>\n<h2 id=\"三、Proxy-的实战场景：这些地方用它最香\"><a href=\"#三、Proxy-的实战场景：这些地方用它最香\" class=\"headerlink\" title=\"三、Proxy 的实战场景：这些地方用它最香\"></a>三、Proxy 的实战场景：这些地方用它最香</h2><h3 id=\"3-1-响应式数据（Vue3-核心原理）\"><a href=\"#3-1-响应式数据（Vue3-核心原理）\" class=\"headerlink\" title=\"3.1 响应式数据（Vue3 核心原理）\"></a>3.1 响应式数据（Vue3 核心原理）</h3><p>Vue3 的响应式系统就是基于 Proxy 实现的 —— 通过拦截对象的 <code>get</code>（收集依赖）和 <code>set</code>（触发更新），实现 “数据变，视图自动变”。</p>\n<p>简化版实现如下：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储依赖：key 是目标对象，value 是该对象各属性的依赖列表</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> reactiveMap = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakMap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 收集依赖：记录“哪个函数在用这个属性”</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">track</span>(<span class=\"params\">target, propKey</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 这里简化处理，实际 Vue 中会关联组件渲染函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!reactiveMap.<span class=\"title function_\">has</span>(target)) {</span><br><span class=\"line\">    reactiveMap.<span class=\"title function_\">set</span>(target, <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>());</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">const</span> propMap = reactiveMap.<span class=\"title function_\">get</span>(target);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!propMap.<span class=\"title function_\">has</span>(propKey)) {</span><br><span class=\"line\">    propMap.<span class=\"title function_\">set</span>(propKey, <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>());</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">// 假设当前依赖是一个“更新函数”</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">updateFn</span> = (<span class=\"params\"></span>) =&gt; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`属性 <span class=\"subst\">${propKey}</span> 变了，更新视图！`</span>);</span><br><span class=\"line\">  propMap.<span class=\"title function_\">get</span>(propKey).<span class=\"title function_\">add</span>(updateFn);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 触发更新：通知所有依赖该属性的函数执行</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">trigger</span>(<span class=\"params\">target, propKey</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!reactiveMap.<span class=\"title function_\">has</span>(target)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> propMap = reactiveMap.<span class=\"title function_\">get</span>(target);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (propMap.<span class=\"title function_\">has</span>(propKey)) {</span><br><span class=\"line\">    propMap.<span class=\"title function_\">get</span>(propKey).<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> <span class=\"title function_\">fn</span>());</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成响应式对象的核心函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reactive</span>(<span class=\"params\">target</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 避免重复代理（同一对象只代理一次）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (reactiveMap.<span class=\"title function_\">has</span>(target)) <span class=\"keyword\">return</span> reactiveMap.<span class=\"title function_\">get</span>(target);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(target, {</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey, receiver</span>) {</span><br><span class=\"line\">      <span class=\"comment\">// 读取属性时，收集依赖</span></span><br><span class=\"line\">      <span class=\"title function_\">track</span>(target, propKey);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey, receiver);</span><br><span class=\"line\">      <span class=\"comment\">// 嵌套对象递归代理（比如 user.address.city 也能响应）</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value === <span class=\"string\">'object'</span> &amp;&amp; value !== <span class=\"literal\">null</span> ? <span class=\"title function_\">reactive</span>(value) : value;</span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">target, propKey, value, receiver</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">const</span> oldValue = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey, receiver);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> success = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, propKey, value, receiver);</span><br><span class=\"line\">      <span class=\"comment\">// 只有值真的变了，才触发更新</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (oldValue !== value) {</span><br><span class=\"line\">        <span class=\"title function_\">trigger</span>(target, propKey);</span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">    },</span><br><span class=\"line\">  });</span><br><span class=\"line\"></span><br><span class=\"line\">  reactiveMap.<span class=\"title function_\">set</span>(target, proxy);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试响应式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = <span class=\"title function_\">reactive</span>({ <span class=\"attr\">name</span>: <span class=\"string\">'Bob'</span>, <span class=\"attr\">address</span>: { <span class=\"attr\">city</span>: <span class=\"string\">'Beijing'</span> } });</span><br><span class=\"line\">user.<span class=\"property\">name</span> = <span class=\"string\">'Charlie'</span>; <span class=\"comment\">// 触发 set → 输出“属性 name 变了，更新视图！”</span></span><br><span class=\"line\">user.<span class=\"property\">address</span>.<span class=\"property\">city</span> = <span class=\"string\">'Shanghai'</span>; <span class=\"comment\">// 嵌套对象也触发 → 输出“属性 city 变了，更新视图！”</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-2-数据验证：确保属性值符合规则\"><a href=\"#3-2-数据验证：确保属性值符合规则\" class=\"headerlink\" title=\"3.2 数据验证：确保属性值符合规则\"></a>3.2 数据验证：确保属性值符合规则</h3><p>比如要求 <code>age</code> 必须是正整数，<code>name</code> 不能是空字符串 —— 通过 <code>set</code> 拦截器就能实现：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义验证规则的拦截器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> validatorHandler = {</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">target, propKey, value</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (propKey) {</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'age'</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 验证 age 必须是正整数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"title class_\">Number</span>.<span class=\"title function_\">isInteger</span>(value) || value &lt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">`年龄 <span class=\"subst\">${value}</span> 无效！必须是正整数`</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'name'</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 验证 name 不能是空字符串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value !== <span class=\"string\">'string'</span> || value.<span class=\"title function_\">trim</span>() === <span class=\"string\">''</span>) {</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">'姓名不能为空！'</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 验证通过，执行默认的赋值逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, propKey, value);</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建带验证的代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>({}, validatorHandler);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试验证逻辑</span></span><br><span class=\"line\">person.<span class=\"property\">age</span> = <span class=\"number\">30</span>; <span class=\"comment\">// 验证通过</span></span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">'David'</span>; <span class=\"comment\">// 验证通过</span></span><br><span class=\"line\"></span><br><span class=\"line\">person.<span class=\"property\">age</span> = <span class=\"string\">'thirty'</span>; <span class=\"comment\">// 报错：TypeError: 年龄 thirty 无效！必须是正整数</span></span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">''</span>; <span class=\"comment\">// 报错：TypeError: 姓名不能为空！</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-3-API-请求拦截：统一管理接口调用\"><a href=\"#3-3-API-请求拦截：统一管理接口调用\" class=\"headerlink\" title=\"3.3 API 请求拦截：统一管理接口调用\"></a>3.3 API 请求拦截：统一管理接口调用</h3><p>比如给所有 API 调用加 “请求日志” 和 “基础 URL 拼接”，不用每次调用都写重复逻辑：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 目标对象：存储 API 基础配置</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> apiConfig = { <span class=\"attr\">baseURL</span>: <span class=\"string\">'https://api.example.com'</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// API 拦截器：拦截属性访问，返回封装后的请求函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> apiHandler = {</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, endpoint</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 比如访问 api.users，返回一个请求 /users 接口的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">async</span> (params) =&gt; {</span><br><span class=\"line\">      <span class=\"comment\">// 统一加请求日志</span></span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`调用 API：<span class=\"subst\">${endpoint}</span>，参数：`</span>, params);</span><br><span class=\"line\">      <span class=\"comment\">// 统一拼接基础 URL</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> url = <span class=\"string\">`<span class=\"subst\">${target.baseURL}</span>/<span class=\"subst\">${endpoint}</span>`</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 发送请求</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url, {</span><br><span class=\"line\">        <span class=\"attr\">method</span>: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">        <span class=\"attr\">headers</span>: { <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/json'</span> },</span><br><span class=\"line\">        <span class=\"attr\">body</span>: <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(params),</span><br><span class=\"line\">      });</span><br><span class=\"line\">      <span class=\"keyword\">return</span> response.<span class=\"title function_\">json</span>();</span><br><span class=\"line\">    };</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建 API 代理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> api = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(apiConfig, apiHandler);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 API：简洁且统一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> userData = <span class=\"keyword\">await</span> api.<span class=\"title function_\">users</span>({ <span class=\"attr\">id</span>: <span class=\"number\">123</span> }); <span class=\"comment\">// 调用 https://api.example.com/users</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> orderData = <span class=\"keyword\">await</span> api.<span class=\"title function_\">orders</span>({ <span class=\"attr\">userId</span>: <span class=\"number\">123</span> }); <span class=\"comment\">// 调用 https://api.example.com/orders</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-4-自动持久化：修改数据自动存到本地存储\"><a href=\"#3-4-自动持久化：修改数据自动存到本地存储\" class=\"headerlink\" title=\"3.4 自动持久化：修改数据自动存到本地存储\"></a>3.4 自动持久化：修改数据自动存到本地存储</h3><p>比如让配置数据修改后自动保存到 <code>localStorage</code>，刷新页面也不会丢：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建“自动持久化”的代理函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createPersistentState</span>(<span class=\"params\">storageKey, initialState</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 从 localStorage 读取已有数据（没有则用初始值）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> storedData = <span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">getItem</span>(storageKey);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = storedData ? <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(storedData) : initialState;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 拦截 set 操作：修改后自动保存</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = {</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">target, propKey, value</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">const</span> success = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, propKey, value);</span><br><span class=\"line\">      <span class=\"comment\">// 自动同步到 localStorage</span></span><br><span class=\"line\">      <span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">setItem</span>(storageKey, <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(target));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">    },</span><br><span class=\"line\">  };</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(state, handler);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建自动持久化的配置对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> appSettings = <span class=\"title function_\">createPersistentState</span>(<span class=\"string\">'app-settings'</span>, {</span><br><span class=\"line\">  <span class=\"attr\">theme</span>: <span class=\"string\">'light'</span>,</span><br><span class=\"line\">  <span class=\"attr\">fontSize</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试：修改后自动保存到 localStorage</span></span><br><span class=\"line\">appSettings.<span class=\"property\">theme</span> = <span class=\"string\">'dark'</span>; <span class=\"comment\">// localStorage 里的 app-settings 会自动更新</span></span><br><span class=\"line\">appSettings.<span class=\"property\">fontSize</span> = <span class=\"number\">18</span>; <span class=\"comment\">// 同样自动保存</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-5-数组变化监听：完美支持数组方法\"><a href=\"#3-5-数组变化监听：完美支持数组方法\" class=\"headerlink\" title=\"3.5 数组变化监听：完美支持数组方法\"></a>3.5 数组变化监听：完美支持数组方法</h3><p>Proxy 能原生拦截数组的 <code>push</code>、<code>pop</code>、<code>splice</code> 等方法，不用像 <code>Object.defineProperty</code> 那样做特殊 hack：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组拦截器：监控数组操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayHandler = {</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 拦截数组的变异方法（push、pop 等）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> mutationMethods = [<span class=\"string\">'push'</span>, <span class=\"string\">'pop'</span>, <span class=\"string\">'shift'</span>, <span class=\"string\">'unshift'</span>, <span class=\"string\">'splice'</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mutationMethods.<span class=\"title function_\">includes</span>(propKey)) {</span><br><span class=\"line\">      <span class=\"comment\">// 返回包装后的方法，保留原逻辑并加监控</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`数组执行 <span class=\"subst\">${propKey}</span>，参数：`</span>, args);</span><br><span class=\"line\">        <span class=\"comment\">// 调用数组原生方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>[propKey].<span class=\"title function_\">apply</span>(target, args);</span><br><span class=\"line\">      };</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 非数组方法，走默认逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey);</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试数组代理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> list = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], arrayHandler);</span><br><span class=\"line\">list.<span class=\"title function_\">push</span>(<span class=\"number\">4</span>); <span class=\"comment\">// 触发拦截：输出“数组执行 push，参数：[4]”，数组变成 [1,2,3,4]</span></span><br><span class=\"line\">list.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>); <span class=\"comment\">// 触发拦截：输出“数组执行 splice，参数：[0,1]”，数组变成 [2,3,4]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"四、Proxy-实战注意事项与优化\"><a href=\"#四、Proxy-实战注意事项与优化\" class=\"headerlink\" title=\"四、Proxy 实战注意事项与优化\"></a>四、Proxy 实战注意事项与优化</h2><h3 id=\"4-1-必须用-Reflect-保持默认行为\"><a href=\"#4-1-必须用-Reflect-保持默认行为\" class=\"headerlink\" title=\"4.1 必须用 Reflect 保持默认行为\"></a>4.1 必须用 Reflect 保持默认行为</h3><p><code>Reflect</code> 是 ES6 配合 Proxy 推出的 API，它的方法和 Proxy 的拦截器一一对应（比如 <code>Reflect.get</code> 对应 <code>get</code> 拦截器）。在拦截器里用 <code>Reflect</code> 而不是直接操作 <code>target</code>，能确保：</p>\n<ul>\n<li>保持对象的默认行为（比如 <code>this</code> 指向正确）；</li>\n<li>正确处理复杂场景（比如继承属性、不可写属性）。</li>\n</ul>\n<p>反例（不推荐）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> badHandler = {</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target[propKey]; <span class=\"comment\">// 直接操作 target，可能破坏继承等默认行为</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>正例（推荐）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> goodHandler = {</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey, receiver</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey, receiver); <span class=\"comment\">// 用 Reflect 保持默认行为</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-2-避免过度代理：减少性能开销\"><a href=\"#4-2-避免过度代理：减少性能开销\" class=\"headerlink\" title=\"4.2 避免过度代理：减少性能开销\"></a>4.2 避免过度代理：减少性能开销</h3><p>Proxy 虽然灵活，但创建和递归代理会有性能开销，尤其是处理大型对象或频繁操作时。优化技巧：</p>\n<ol>\n<li><strong>避免重复代理</strong>：用 <code>WeakMap</code> 缓存已代理的对象，同一对象只代理一次（参考 3.1 响应式的 <code>reactiveMap</code>）；</li>\n<li><strong>浅层代理优先</strong>：如果只需要监控顶层属性，不用递归代理嵌套对象；</li>\n<li><strong>性能关键场景不用 Proxy</strong>：比如高频更新的列表、大型数据计算，用普通对象更高效。</li>\n</ol>\n<h3 id=\"4-3-嵌套对象代理：需要递归处理\"><a href=\"#4-3-嵌套对象代理：需要递归处理\" class=\"headerlink\" title=\"4.3 嵌套对象代理：需要递归处理\"></a>4.3 嵌套对象代理：需要递归处理</h3><p>Proxy 只能拦截 “直接操作的属性”，如果目标对象有嵌套对象（比如 <code>user.address.city</code>），直接代理顶层对象无法拦截嵌套属性的操作 —— 需要在 <code>get</code> 拦截器里递归代理嵌套对象：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> nestedHandler = {</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey, receiver</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey, receiver);</span><br><span class=\"line\">    <span class=\"comment\">// 如果值是对象且非 null，递归代理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value === <span class=\"string\">'object'</span> &amp;&amp; value !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(value, nestedHandler);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">target, propKey, value</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`修改 <span class=\"subst\">${propKey}</span>：<span class=\"subst\">${value}</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, propKey, value);</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试嵌套代理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>({ <span class=\"attr\">address</span>: { <span class=\"attr\">city</span>: <span class=\"string\">'Beijing'</span> } }, nestedHandler);</span><br><span class=\"line\">user.<span class=\"property\">address</span>.<span class=\"property\">city</span> = <span class=\"string\">'Shanghai'</span>; <span class=\"comment\">// 触发 set：输出“修改 city：Shanghai”</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-4-浏览器兼容性：旧环境回退\"><a href=\"#4-4-浏览器兼容性：旧环境回退\" class=\"headerlink\" title=\"4.4 浏览器兼容性：旧环境回退\"></a>4.4 浏览器兼容性：旧环境回退</h3><p>Proxy 不支持 IE 浏览器，如果需要兼容旧环境，可以用 <code>Object.defineProperty</code> 做回退（类似 Vue2 的响应式方案）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createCompatProxy</span>(<span class=\"params\">target, handler</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 现代浏览器：用 Proxy</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"title class_\">Proxy</span> !== <span class=\"string\">'undefined'</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(target, handler);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 旧浏览器：用 Object.defineProperty 模拟（仅支持 get/set）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(target)) {</span><br><span class=\"line\">    <span class=\"comment\">// 数组回退：拦截索引和长度</span></span><br><span class=\"line\">    target.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">_, index</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(target, index, {</span><br><span class=\"line\">        <span class=\"title function_\">get</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">          <span class=\"keyword\">return</span> handler.<span class=\"property\">get</span>?.(target, index);</span><br><span class=\"line\">        },</span><br><span class=\"line\">        <span class=\"title function_\">set</span>(<span class=\"params\">value</span>) {</span><br><span class=\"line\">          handler.<span class=\"property\">set</span>?.(target, index, value);</span><br><span class=\"line\">        },</span><br><span class=\"line\">      });</span><br><span class=\"line\">    });</span><br><span class=\"line\">  } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 对象回退：拦截属性</span></span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(target).<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(target, key, {</span><br><span class=\"line\">        <span class=\"title function_\">get</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">          <span class=\"keyword\">return</span> handler.<span class=\"property\">get</span>?.(target, key);</span><br><span class=\"line\">        },</span><br><span class=\"line\">        <span class=\"title function_\">set</span>(<span class=\"params\">value</span>) {</span><br><span class=\"line\">          handler.<span class=\"property\">set</span>?.(target, key, value);</span><br><span class=\"line\">        },</span><br><span class=\"line\">      });</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"五、Proxy-vs-Object-defineProperty：核心差异\"><a href=\"#五、Proxy-vs-Object-defineProperty：核心差异\" class=\"headerlink\" title=\"五、Proxy vs Object.defineProperty：核心差异\"></a>五、Proxy vs Object.defineProperty：核心差异</h2><p>很多人会把 Proxy 和 ES5 的 <code>Object.defineProperty</code> 对比，两者都是 “对象拦截” 方案，但 Proxy 更强大、更灵活：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Proxy（ES6）</th>\n<th>Object.defineProperty（ES5）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>嵌套对象监听</td>\n<td>✅ 支持（需递归代理）</td>\n<td>❌ 不支持，需手动递归实现</td>\n</tr>\n<tr>\n<td>数组监听</td>\n<td>✅ 原生支持（push、splice 等方法）</td>\n<td>❌ 需 hack 数组原型，不完美</td>\n</tr>\n<tr>\n<td>新增属性监听</td>\n<td>✅ 自动支持（比如 <code>proxy.newKey = 1</code>）</td>\n<td>❌ 不支持，需手动调用 <code>defineProperty</code></td>\n</tr>\n<tr>\n<td>删除属性监听</td>\n<td>✅ 支持（<code>delete proxy.key</code>）</td>\n<td>❌ 不支持</td>\n</tr>\n<tr>\n<td>拦截操作数量</td>\n<td>13 种（覆盖所有对象操作）</td>\n<td>仅 2 种（get / set）</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>现代浏览器优化良好，一般场景足够用</td>\n<td>稍快，但功能有限</td>\n</tr>\n<tr>\n<td>浏览器支持</td>\n<td>现代浏览器（Chrome、Firefox、Edge），不支持 IE</td>\n<td>支持到 IE9</td>\n</tr>\n</tbody></table>\n<p>简单说：如果不需要兼容 IE，优先用 Proxy；如果需要兼容旧环境，才考虑 <code>Object.defineProperty</code>。</p>\n<h2 id=\"六、Proxy-的局限性\"><a href=\"#六、Proxy-的局限性\" class=\"headerlink\" title=\"六、Proxy 的局限性\"></a>六、Proxy 的局限性</h2><p>Proxy 虽强，但也有一些无法突破的限制：</p>\n<ol>\n<li><strong>无法拦截全等比较</strong>：<code>proxy === target</code> 永远是 <code>false</code>（代理和原对象是两个不同的引用）；</li>\n<li><strong>无法拦截某些内部方法</strong>：比如 <code>Object.prototype.toString.call(proxy)</code>，返回的是代理对象的类型，无法自定义；</li>\n<li><strong>序列化问题</strong>：代理对象不能直接用 <code>JSON.stringify</code> 序列化（会序列化原对象的属性，但拦截逻辑不生效）；</li>\n<li><strong>内存消耗</strong>：深度代理大型对象（比如嵌套多层的数组 / 对象），会占用较多内存。</li>\n</ol>\n<hr>\n<p>Proxy 是 ES6 中最强大的特性之一，它的核心价值在于 “不修改原对象，却能自定义对象的行为”—— 这种 “非侵入式” 的拦截能力，让它在框架开发、工具库、数据处理等场景中大放异彩。掌握 Proxy，不仅能看懂 Vue3 等框架的底层逻辑，还能写出更灵活、更优雅的代码～</p>\n",
            "tags": [
                "JavaScript",
                "性能优化",
                "ES6"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/reflect/",
            "url": "http://toukoxu.github.io/archives/reflect/",
            "title": "Reflect：ES6 标准化对象操作的 “工具库”",
            "date_published": "2024-08-14T12:46:25.000Z",
            "content_html": "<blockquote>\n<p><strong>Reflect</strong> 是 ES6 新增的内置对象，核心作用是<strong>提供一套统一、函数式的对象操作 API</strong>。它的方法与 Proxy 拦截器一一对应，既能替代传统的对象操作方式（如 <code>delete</code>、<code>in</code>），又能解决旧语法的不一致问题，是元编程和 Proxy 配合的 “最佳搭档”。</p>\n</blockquote>\n<h2 id=\"关联知识\"><a href=\"#关联知识\" class=\"headerlink\" title=\"关联知识\"></a>关联知识</h2><p>可以将 Proxy 和 Reflect 合并在一起学习～</p>\n<div calss=\"anzhiyu-tag-link\"><a class=\"tag-Link\" target=\"_blank\" href=\"/2024/08/15/proxy\">\n    <div class=\"tag-link-tips\">站内地址</div>\n    <div class=\"tag-link-bottom\">\n        <div class=\"tag-link-left\" style=\"background-image: url(/img/512.png)\">\n          <i class=\"anzhiyufont anzhiyu-icon-link\" style=\"display: none\"></i>\n        </div>\n        <div class=\"tag-link-right\">\n            <div class=\"tag-link-title\">代理（Proxy）：ES6 元编程的 “对象拦截器”</div>\n            <div class=\"tag-link-sitename\"> Touko</div>\n        </div>\n        <i class=\"anzhiyufont anzhiyu-icon-angle-right\"></i>\n    </div>\n    </a></div>\n\n<h2 id=\"一、为什么需要-Reflect？——-解决旧语法的痛点\"><a href=\"#一、为什么需要-Reflect？——-解决旧语法的痛点\" class=\"headerlink\" title=\"一、为什么需要 Reflect？—— 解决旧语法的痛点\"></a>一、为什么需要 Reflect？—— 解决旧语法的痛点</h2><p>在 Reflect 出现前，JavaScript 操作对象的方式很 “零散”，存在三个明显问题：</p>\n<ol>\n<li><strong>操作形式不统一</strong>：有的是关键字（如 <code>delete obj.prop</code>、<code>prop in obj</code>），有的是 <code>Object</code> 上的方法（如 <code>Object.keys(obj)</code>、<code>Object.defineProperty()</code>），风格混乱。</li>\n<li><strong>错误处理不一致</strong>：有的操作失败会抛出错误（如 <code>Object.defineProperty</code> 遇到不可扩展对象），有的返回布尔值（如 <code>delete obj.prop</code>），处理逻辑复杂。</li>\n<li><strong>this 绑定问题</strong>：传统操作（如 <code>target[prop]</code>）无法正确传递 <code>this</code> 上下文，在代理或继承场景下容易出错。</li>\n</ol>\n<p>Reflect 正是为解决这些问题而生 —— 它把所有对象操作都封装成<strong>函数式方法</strong>，统一了调用形式、错误处理和上下文传递。</p>\n<h2 id=\"二、Reflect-的核心特性\"><a href=\"#二、Reflect-的核心特性\" class=\"headerlink\" title=\"二、Reflect 的核心特性\"></a>二、Reflect 的核心特性</h2><ol>\n<li><strong>与 Proxy 一一对应</strong>：Reflect 的 13 个静态方法，正好对应 Proxy 的 13 种拦截器（如 <code>Reflect.get</code> 对应 Proxy 的 <code>get</code> 拦截器），是 Proxy 实现默认行为的 “标准工具”。</li>\n<li><strong>函数式操作</strong>：所有对象操作（包括读、写、删、判断属性等）都通过函数调用完成，支持函数式编程（如组合、柯里化）。</li>\n<li><strong>统一返回值</strong>：大部分方法返回布尔值（<code>true</code> 表示成功，<code>false</code> 表示失败），避免了传统操作 “有的抛错、有的返回值” 的混乱。</li>\n<li><strong>正确传递 this</strong>：方法支持 <code>receiver</code> 参数，能在继承或代理场景下正确绑定 <code>this</code>（解决传统 <code>target[prop]</code> 的 <code>this</code> 丢失问题）。</li>\n</ol>\n<h2 id=\"三、Reflect-的-13-个静态方法：按场景分类\"><a href=\"#三、Reflect-的-13-个静态方法：按场景分类\" class=\"headerlink\" title=\"三、Reflect 的 13 个静态方法：按场景分类\"></a>三、Reflect 的 13 个静态方法：按场景分类</h2><p>Reflect 的方法一共有 13 个，我将它们分了几类，日常开发中高频使用的是 “基本操作” 类，其他类多用于元编程场景。</p>\n<h3 id=\"3-1-基本操作：读、写、判断、删属性\"><a href=\"#3-1-基本操作：读、写、判断、删属性\" class=\"headerlink\" title=\"3.1 基本操作：读、写、判断、删属性\"></a>3.1 基本操作：读、写、判断、删属性</h3><p>最常用的四类方法，对应日常的属性操作：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>传统等价操作</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Reflect.get(target, propKey[, receiver])</code></td>\n<td>读取对象属性</td>\n<td><code>target[propKey]</code></td>\n<td><code>Reflect.get(user, 'name')</code>（读 <code>user.name</code>）</td>\n</tr>\n<tr>\n<td><code>Reflect.set(target, propKey, value[, receiver])</code></td>\n<td>设置对象属性</td>\n<td><code>target[propKey] = value</code></td>\n<td><code>Reflect.set(user, 'age', 30)</code>（设 <code>user.age = 30</code>）</td>\n</tr>\n<tr>\n<td><code>Reflect.has(target, propKey)</code></td>\n<td>判断属性是否存在</td>\n<td><code>propKey in target</code></td>\n<td><code>Reflect.has(user, 'id')</code>（判断 <code>'id' in user</code>）</td>\n</tr>\n<tr>\n<td><code>Reflect.deleteProperty(target, propKey)</code></td>\n<td>删除对象属性</td>\n<td><code>delete target[propKey]</code></td>\n<td><code>Reflect.deleteProperty(user, 'temp')</code>（删 <code>user.temp</code>）</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-2-原型操作：获取-设置原型\"><a href=\"#3-2-原型操作：获取-设置原型\" class=\"headerlink\" title=\"3.2 原型操作：获取/设置原型\"></a>3.2 原型操作：获取 / 设置原型</h3><p>对应 <code>Object.getPrototypeOf</code> 和 <code>Object.setPrototypeOf</code>，但返回值更合理（布尔值表示成功 / 失败）：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>传统等价操作</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Reflect.getPrototypeOf(target)</code></td>\n<td>获取对象的原型</td>\n<td><code>Object.getPrototypeOf(target)</code></td>\n<td><code>Reflect.getPrototypeOf(user)</code>（同 <code>Object.getPrototypeOf(user)</code>）</td>\n</tr>\n<tr>\n<td><code>Reflect.setPrototypeOf(target, proto)</code></td>\n<td>设置对象的原型</td>\n<td><code>Object.setPrototypeOf(target, proto)</code></td>\n<td><code>Reflect.setPrototypeOf(user, protoObj)</code>（返回 <code>true</code> 表示成功）</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-3-属性定义：定义-获取属性描述符\"><a href=\"#3-3-属性定义：定义-获取属性描述符\" class=\"headerlink\" title=\"3.3 属性定义：定义/获取属性描述符\"></a>3.3 属性定义：定义 / 获取属性描述符</h3><p>对应 <code>Object.defineProperty</code> 和 <code>Object.getOwnPropertyDescriptor</code>，返回布尔值表示操作结果：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>传统等价操作</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Reflect.defineProperty(target, propKey, desc)</code></td>\n<td>定义属性（含描述符）</td>\n<td><code>Object.defineProperty(target, propKey, desc)</code></td>\n<td><code>Reflect.defineProperty(user, 'name', { value: 'Alice' })</code></td>\n</tr>\n<tr>\n<td><code>Reflect.getOwnPropertyDescriptor(target, propKey)</code></td>\n<td>获取属性描述符</td>\n<td><code>Object.getOwnPropertyDescriptor(target, propKey)</code></td>\n<td><code>Reflect.getOwnPropertyDescriptor(user, 'age')</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"3-4-其他方法（元编程常用）\"><a href=\"#3-4-其他方法（元编程常用）\" class=\"headerlink\" title=\"3.4 其他方法（元编程常用）\"></a>3.4 其他方法（元编程常用）</h3><p>这些方法多用于底层对象控制，日常开发中较少直接使用：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n<th>传统等价操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Reflect.isExtensible(target)</code></td>\n<td>判断对象是否可扩展（能否加新属性）</td>\n<td><code>Object.isExtensible(target)</code></td>\n</tr>\n<tr>\n<td><code>Reflect.preventExtensions(target)</code></td>\n<td>阻止对象扩展</td>\n<td><code>Object.preventExtensions(target)</code></td>\n</tr>\n<tr>\n<td><code>Reflect.ownKeys(target)</code></td>\n<td>获取对象所有自身属性（含 Symbol）</td>\n<td><code>Object.getOwnPropertyNames() + Object.getOwnPropertySymbols()</code></td>\n</tr>\n<tr>\n<td><code>Reflect.apply(target, thisArg, args)</code></td>\n<td>调用函数（类似 <code>Function.prototype.apply</code>）</td>\n<td><code>target.apply(thisArg, args)</code></td>\n</tr>\n<tr>\n<td><code>Reflect.construct(target, args[, newTarget])</code></td>\n<td>调用构造函数（类似 <code>new</code>）</td>\n<td><code>new target(...args)</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"四、Reflect-与-Proxy：天生一对\"><a href=\"#四、Reflect-与-Proxy：天生一对\" class=\"headerlink\" title=\"四、Reflect 与 Proxy：天生一对\"></a>四、Reflect 与 Proxy：天生一对</h2><p>Reflect 的最大价值，在于与 Proxy 配合使用 ——Proxy 拦截对象操作后，通过 Reflect 能<strong>安全地执行默认操作</strong>，避免破坏对象的原生行为（如 <code>this</code> 绑定、继承关系）。</p>\n<h3 id=\"4-1-对应关系：拦截器与-Reflect-方法一一匹配\"><a href=\"#4-1-对应关系：拦截器与-Reflect-方法一一匹配\" class=\"headerlink\" title=\"4.1 对应关系：拦截器与 Reflect 方法一一匹配\"></a>4.1 对应关系：拦截器与 Reflect 方法一一匹配</h3><p>Proxy 的每一种拦截器，都能通过对应的 Reflect 方法实现 “默认行为”，它们是<strong>一一对应</strong>的。</p>\n<h3 id=\"4-2-实战示例：Proxy-中用-Reflect-保持默认行为\"><a href=\"#4-2-实战示例：Proxy-中用-Reflect-保持默认行为\" class=\"headerlink\" title=\"4.2 实战示例：Proxy 中用 Reflect 保持默认行为\"></a>4.2 实战示例：Proxy 中用 Reflect 保持默认行为</h3><p>比如拦截对象的 <code>get</code> 和 <code>set</code> 操作，在自定义逻辑后，用 Reflect 执行默认的读写行为：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = { <span class=\"attr\">name</span>: <span class=\"string\">'Alice'</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Proxy 拦截器：监控属性读写</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> userProxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(user, {</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey, receiver</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 自定义逻辑：打印读取日志</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`正在读取属性：<span class=\"subst\">${propKey}</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用 Reflect.get 执行默认读操作（正确传递 this）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey, receiver);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">target, propKey, value, receiver</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 自定义逻辑：验证 age 必须是正数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propKey === <span class=\"string\">'age'</span> &amp;&amp; value &lt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">'年龄不能为负数！'</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用 Reflect.set 执行默认写操作（返回布尔值表示成功）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, propKey, value, receiver);</span><br><span class=\"line\">  },</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试：触发拦截逻辑，同时保持默认行为</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(userProxy.<span class=\"property\">name</span>); <span class=\"comment\">// 打印“正在读取属性：name”，输出“Alice”</span></span><br><span class=\"line\">userProxy.<span class=\"property\">age</span> = <span class=\"number\">30</span>; <span class=\"comment\">// 成功设置（无错误）</span></span><br><span class=\"line\">userProxy.<span class=\"property\">age</span> = -<span class=\"number\">5</span>; <span class=\"comment\">// 抛出错误：年龄不能为负数！</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果不用 Reflect，直接用 <code>target[propKey]</code> 或 <code>target[propKey] = value</code>，会丢失 <code>receiver</code> 上下文（比如在继承场景下 <code>this</code> 指向错误）。</p>\n<h2 id=\"五、Reflect-的核心优势：解决传统操作的痛点\"><a href=\"#五、Reflect-的核心优势：解决传统操作的痛点\" class=\"headerlink\" title=\"五、Reflect 的核心优势：解决传统操作的痛点\"></a>五、Reflect 的核心优势：解决传统操作的痛点</h2><h3 id=\"5-1-统一错误处理：用布尔值判断结果，不用-try-catch\"><a href=\"#5-1-统一错误处理：用布尔值判断结果，不用-try-catch\" class=\"headerlink\" title=\"5.1 统一错误处理：用布尔值判断结果，不用 try/catch\"></a>5.1 统一错误处理：用布尔值判断结果，不用 try / catch</h3><p>传统的 <code>Object.defineProperty</code> 失败时会抛出错误，需要用 <code>try/catch</code> 处理；而 <code>Reflect.defineProperty</code> 直接返回布尔值，逻辑更简洁：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"title class_\">Object</span>.<span class=\"title function_\">preventExtensions</span>({}); <span class=\"comment\">// 让对象不可扩展（不能加新属性）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 传统方式：失败抛错，需 try/catch</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> {</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">'newProp'</span>, { <span class=\"attr\">value</span>: <span class=\"number\">123</span> });</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'定义成功'</span>);</span><br><span class=\"line\">} <span class=\"keyword\">catch</span> (e) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'定义失败'</span>); <span class=\"comment\">// 会执行这里（对象不可扩展）</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Reflect 方式：返回布尔值，直接判断</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"title class_\">Reflect</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">'newProp'</span>, { <span class=\"attr\">value</span>: <span class=\"number\">123</span> })) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'定义成功'</span>);</span><br><span class=\"line\">} <span class=\"keyword\">else</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'定义失败'</span>); <span class=\"comment\">// 会执行这里（更简洁）</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-2-正确传递-this：解决-receiver-问题\"><a href=\"#5-2-正确传递-this：解决-receiver-问题\" class=\"headerlink\" title=\"5.2 正确传递 this：解决 receiver 问题\"></a>5.2 正确传递 this：解决 receiver 问题</h3><p>在代理或继承场景下，传统的 <code>target[prop]</code> 会导致 <code>this</code> 指向错误，而 Reflect 支持 <code>receiver</code> 参数，能正确绑定 <code>this</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> parent = {</span><br><span class=\"line\">  <span class=\"attr\">_name</span>: <span class=\"string\">'Parent'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">name</span>() {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span>; <span class=\"comment\">// this 应该指向调用者</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用 Proxy 代理 parent</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> parentProxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(parent, {</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey, receiver</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 错误方式：target[propKey] 会让 this 指向 target（parent）</span></span><br><span class=\"line\">    <span class=\"comment\">// return target[propKey];</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 正确方式：Reflect.get 传递 receiver（this 指向调用者）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey, receiver);</span><br><span class=\"line\">  },</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子对象继承代理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> child = {</span><br><span class=\"line\">  <span class=\"attr\">__proto__</span>: parentProxy,</span><br><span class=\"line\">  <span class=\"attr\">_name</span>: <span class=\"string\">'Child'</span>, <span class=\"comment\">// 子对象自己的 _name</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(child.<span class=\"property\">name</span>);</span><br><span class=\"line\"><span class=\"comment\">// 错误方式输出 \"Parent\"（this 指向 parent）</span></span><br><span class=\"line\"><span class=\"comment\">// 正确方式输出 \"Child\"（this 指向 child，符合继承逻辑）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-3-支持函数式编程：可组合、可复用\"><a href=\"#5-3-支持函数式编程：可组合、可复用\" class=\"headerlink\" title=\"5.3 支持函数式编程：可组合、可复用\"></a>5.3 支持函数式编程：可组合、可复用</h3><p>Reflect 的方法都是函数，能像其他函数一样组合使用，比如批量执行操作并判断结果：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一组操作：批量设置属性</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> operations = [</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(obj, <span class=\"string\">'a'</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(obj, <span class=\"string\">'b'</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(obj, <span class=\"string\">'c'</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行所有操作，判断是否全部成功</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> allSuccess = operations.<span class=\"title function_\">every</span>(<span class=\"function\">(<span class=\"params\">op</span>) =&gt;</span> <span class=\"title function_\">op</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (allSuccess) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'所有属性设置成功'</span>, obj); <span class=\"comment\">// { a:1, b:2, c:3 }</span></span><br><span class=\"line\">} <span class=\"keyword\">else</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'部分操作失败'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"六、Reflect-的实际应用场景\"><a href=\"#六、Reflect-的实际应用场景\" class=\"headerlink\" title=\"六、Reflect 的实际应用场景\"></a>六、Reflect 的实际应用场景</h2><h3 id=\"6-1-配合-Proxy-实现响应式（如-Vue3）\"><a href=\"#6-1-配合-Proxy-实现响应式（如-Vue3）\" class=\"headerlink\" title=\"6.1 配合 Proxy 实现响应式（如 Vue3）\"></a>6.1 配合 Proxy 实现响应式（如 Vue3）</h3><p>Vue3 的响应式系统中，Proxy 拦截属性读写后，通过 Reflect 执行默认操作，同时收集依赖或触发更新：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reactive</span>(<span class=\"params\">target</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(target, {</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey, receiver</span>) {</span><br><span class=\"line\">      <span class=\"title function_\">track</span>(target, propKey); <span class=\"comment\">// 收集依赖（响应式核心）</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey, receiver); <span class=\"comment\">// 默认读操作</span></span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">target, propKey, value, receiver</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">const</span> oldValue = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey, receiver);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> success = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, propKey, value, receiver);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (success &amp;&amp; oldValue !== value) {</span><br><span class=\"line\">        <span class=\"title function_\">trigger</span>(target, propKey); <span class=\"comment\">// 触发更新（响应式核心）</span></span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">    },</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"6-2-安全的对象操作：避免抛错\"><a href=\"#6-2-安全的对象操作：避免抛错\" class=\"headerlink\" title=\"6.2 安全的对象操作：避免抛错\"></a>6.2 安全的对象操作：避免抛错</h3><p>在工具库或框架中，需要 “安全操作对象”（即使失败也不崩溃），用 Reflect 比传统方法更合适：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 安全设置对象属性的工具函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">safeSet</span>(<span class=\"params\">obj, prop, value</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 先判断对象是否可扩展，再设置属性</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Reflect</span>.<span class=\"title function_\">isExtensible</span>(obj)) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(obj, prop, value);</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">warn</span>(<span class=\"string\">'对象不可扩展，无法设置属性'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试：不可扩展对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> frozenObj = <span class=\"title class_\">Object</span>.<span class=\"title function_\">freeze</span>({}); <span class=\"comment\">// 冻结对象（不可扩展、不可修改）</span></span><br><span class=\"line\"><span class=\"title function_\">safeSet</span>(frozenObj, <span class=\"string\">'name'</span>, <span class=\"string\">'Alice'</span>); <span class=\"comment\">// 输出警告，返回 false（不抛错）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"6-3-实现多继承（通过代理-Reflect）\"><a href=\"#6-3-实现多继承（通过代理-Reflect）\" class=\"headerlink\" title=\"6.3 实现多继承（通过代理+Reflect）\"></a>6.3 实现多继承（通过代理 + Reflect）</h3><p>JavaScript 不支持原生多继承，但通过 Proxy 和 Reflect 可以模拟 “多原型查找”：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 多继承实现：让对象拥有多个原型的方法</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createMultiProto</span>(<span class=\"params\">...prototypes</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(</span><br><span class=\"line\">    {},</span><br><span class=\"line\">    {</span><br><span class=\"line\">      <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey, receiver</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 按顺序在多个原型中查找属性</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> proto <span class=\"keyword\">of</span> prototypes) {</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"title class_\">Reflect</span>.<span class=\"title function_\">has</span>(proto, propKey)) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(proto, propKey, receiver);</span><br><span class=\"line\">          }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">      },</span><br><span class=\"line\">    }</span><br><span class=\"line\">  );</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义三个“能力”对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> canEat = { <span class=\"attr\">eat</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'吃饭'</span>) };</span><br><span class=\"line\"><span class=\"keyword\">const</span> canWalk = { <span class=\"attr\">walk</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'走路'</span>) };</span><br><span class=\"line\"><span class=\"keyword\">const</span> canSwim = { <span class=\"attr\">swim</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'游泳'</span>) };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建多继承对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> person = <span class=\"title function_\">createMultiProto</span>(canEat, canWalk, canSwim);</span><br><span class=\"line\">person.<span class=\"title function_\">eat</span>(); <span class=\"comment\">// 吃饭（来自 canEat）</span></span><br><span class=\"line\">person.<span class=\"title function_\">walk</span>(); <span class=\"comment\">// 走路（来自 canWalk）</span></span><br><span class=\"line\">person.<span class=\"title function_\">swim</span>(); <span class=\"comment\">// 游泳（来自 canSwim）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"七、最佳实践与注意事项\"><a href=\"#七、最佳实践与注意事项\" class=\"headerlink\" title=\"七、最佳实践与注意事项\"></a>七、最佳实践与注意事项</h2><h3 id=\"7-1-什么时候用-Reflect？\"><a href=\"#7-1-什么时候用-Reflect？\" class=\"headerlink\" title=\"7.1 什么时候用 Reflect？\"></a>7.1 什么时候用 Reflect？</h3><ul>\n<li><strong>与 Proxy 配合时</strong>：必须用 Reflect 执行默认操作，避免 <code>this</code> 绑定错误。</li>\n<li><strong>需要安全操作对象时</strong>：比如不确定对象是否可扩展、是否有该属性，用 Reflect 避免抛错。</li>\n<li><strong>函数式编程场景</strong>：需要组合、复用对象操作时，Reflect 的函数式 API 更合适。</li>\n<li><strong>元编程开发</strong>：比如实现框架、工具库，需要统一对象操作方式时。</li>\n</ul>\n<h3 id=\"7-2-什么时候不用-Reflect？\"><a href=\"#7-2-什么时候不用-Reflect？\" class=\"headerlink\" title=\"7.2 什么时候不用 Reflect？\"></a>7.2 什么时候不用 Reflect？</h3><ul>\n<li><strong>简单属性读写</strong>：日常写 <code>obj.prop</code> 或 <code>obj.prop = value</code> 比 <code>Reflect.get</code>/<code>set</code> 更简洁，没必要画蛇添足。</li>\n<li><strong>性能极度敏感的代码</strong>：虽然 Reflect 性能与原生操作接近，但极端场景下（如每秒百万次操作），原生语法略快。</li>\n</ul>\n<h3 id=\"7-3-浏览器兼容性\"><a href=\"#7-3-浏览器兼容性\" class=\"headerlink\" title=\"7.3 浏览器兼容性\"></a>7.3 浏览器兼容性</h3><p>Reflect 不支持 IE 浏览器，现代浏览器（Chrome 49+、Firefox 42+、Safari 10+、Edge 13+）和 Node.js 6.5+ 均支持。如果需要兼容旧环境，需用 <code>Object</code> 方法替代（如 <code>Object.getPrototypeOf</code> 替代 <code>Reflect.getPrototypeOf</code>）。</p>\n<hr>\n<p>Reflect 看似简单，却是 ES6 元编程的 “基石” 之一 —— 它统一了对象操作的标准，让 Proxy 能安全地拦截行为，也让复杂的对象控制逻辑更简洁、更可维护。掌握 Reflect，不仅能更好地理解 Vue3 等框架的底层，还能在开发工具库或复杂系统时，写出更健壮的代码～</p>\n",
            "tags": [
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/async+await/",
            "url": "http://toukoxu.github.io/archives/async+await/",
            "title": "Async / Await：用同步的方式写异步，真香！",
            "date_published": "2024-07-13T12:46:25.000Z",
            "content_html": "<blockquote>\n<p>async/await 是 ES2017 引入的强大特性，使得处理异步操作变得更加简单和直观。使用 async 声明的函数总是返回一个 Promise，而 await 关键字则像是它的指挥棒，允许你暂停函数的执行，直到 Promise 被解决或拒绝。这种方式让异步代码看起来更像同步代码，从而提高了可读性和可维护性。尤其在处理链式异步操作和错误捕获时，async/await 显示出其独特的优势。</p>\n</blockquote>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>如果对生成器函数和 yield 不太熟悉，可以先看看下面这篇，了解基础后再看 Async / Await 会更顺～</p>\n<div calss=\"anzhiyu-tag-link\"><a class=\"tag-Link\" target=\"_blank\" href=\"/2024/07/11/generator\">\n    <div class=\"tag-link-tips\">站内地址</div>\n    <div class=\"tag-link-bottom\">\n        <div class=\"tag-link-left\" style=\"background-image: url(/img/512.png)\">\n          <i class=\"anzhiyufont anzhiyu-icon-link\" style=\"display: none\"></i>\n        </div>\n        <div class=\"tag-link-right\">\n            <div class=\"tag-link-title\">生成器函数与 yield</div>\n            <div class=\"tag-link-sitename\"> Touko</div>\n        </div>\n        <i class=\"anzhiyufont anzhiyu-icon-angle-right\"></i>\n    </div>\n    </a></div>\n\n<h2 id=\"一、Async-Await-的本质：老熟人的默契配合\"><a href=\"#一、Async-Await-的本质：老熟人的默契配合\" class=\"headerlink\" title=\"一、Async/Await 的本质：老熟人的默契配合\"></a>一、Async / Await 的本质：老熟人的默契配合</h2><p>你可能觉得 Async / Await 是 JavaScript 里的 “新黑科技”，但其实它的底层是三个老熟人在搭班子干活。说穿了，就是把咱们早就眼熟的技术组合得更顺手了。</p>\n<h3 id=\"1-1-三大核心组件\"><a href=\"#1-1-三大核心组件\" class=\"headerlink\" title=\"1.1 三大核心组件\"></a>1.1 三大核心组件</h3><ul>\n<li><strong>Generator（生成器）</strong>：提供<strong>暂停 - 恢复</strong>的能力，就像给函数装了个暂停键</li>\n<li><strong>Promise</strong>：处理<strong>异步操作</strong>的 “标准接口”，负责管理异步结果</li>\n<li><strong>自动执行器</strong>：默默工作的<strong>调度员</strong>，悄悄驱动生成器跑完全程</li>\n</ul>\n<h3 id=\"1-2-从代码看转换逻辑\"><a href=\"#1-2-从代码看转换逻辑\" class=\"headerlink\" title=\"1.2 从代码看转换逻辑\"></a>1.2 从代码看转换逻辑</h3><p>咱们写的 Async 函数，其实会被引擎偷偷转换成类似生成器的结构。比如这样一段代码：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 咱们写的优雅代码</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> api.<span class=\"title function_\">get</span>(<span class=\"string\">'/data'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">process</span>(data);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>引擎背地里会把它转成差不多这样（简化版）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引擎实际处理的样子</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// spawn就是那个自动执行器，负责驱动生成器</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">spawn</span>(<span class=\"keyword\">function</span>* () {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">yield</span> api.<span class=\"title function_\">get</span>(<span class=\"string\">'/data'</span>); <span class=\"comment\">// 用yield代替await</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">process</span>(data);</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<div class=\"note info flat\"><p><strong>这里有个小细节：</strong> 每个 Async 函数都被转换成一个生成器函数，由<mark>自动执行器</mark>接管执行！</p>咱们不用手动调用<code>next()</code>，全是执行器在后台搞定，这也是<code>Async/Await</code>比直接用<code>Generator</code>方便的地方～</div>\n\n<h2 id=\"二、自动执行器：幕后的引擎\"><a href=\"#二、自动执行器：幕后的引擎\" class=\"headerlink\" title=\"二、自动执行器：幕后的引擎\"></a>二、自动执行器：幕后的引擎</h2><p>自动执行器是 Async / Await 能自动跑起来的关键，我试着简化了它的核心代码，大概长这样：</p>\n<h3 id=\"2-1-核心逻辑（简化版）\"><a href=\"#2-1-核心逻辑（简化版）\" class=\"headerlink\" title=\"2.1 核心逻辑（简化版）\"></a>2.1 核心逻辑（简化版）</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">spawn</span>(<span class=\"params\">generatorFunc</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个Promise，这也是async函数总返回Promise的原因</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> generator = <span class=\"title function_\">generatorFunc</span>(); <span class=\"comment\">// 创建生成器实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 步进函数：驱动生成器一步步执行</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">step</span>(<span class=\"params\">nextFn</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">try</span> {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> { value, done } = <span class=\"title function_\">nextFn</span>(); <span class=\"comment\">// 执行到下一个yield</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (done) {</span><br><span class=\"line\">          <span class=\"comment\">// 生成器跑完了，把结果传给Promise</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把yield后的结果包装成Promise（不管是不是Promise）</span></span><br><span class=\"line\">        <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(value).<span class=\"title function_\">then</span>(</span><br><span class=\"line\">          <span class=\"comment\">// 成功了就把结果传给下一次next()，继续执行</span></span><br><span class=\"line\">          <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"title function_\">next</span>(v)),</span><br><span class=\"line\">          <span class=\"comment\">// 失败了就把错误抛回生成器，让try/catch接住</span></span><br><span class=\"line\">          <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"keyword\">throw</span>(e))</span><br><span class=\"line\">        );</span><br><span class=\"line\">      } <span class=\"keyword\">catch</span> (e) {</span><br><span class=\"line\">        <span class=\"comment\">// 捕获生成器内部的错误</span></span><br><span class=\"line\">        <span class=\"title function_\">reject</span>(e);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 启动生成器</span></span><br><span class=\"line\">    <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"title function_\">next</span>());</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"2-2-执行过程图解\"><a href=\"#2-2-执行过程图解\" class=\"headerlink\" title=\"2.2 执行过程图解\"></a>2.2 执行过程图解</h3><p>我画了个流程图帮大家理解，其实就是执行器在中间当 “裁判”，协调生成器和异步操作：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  sequenceDiagram\nparticipant 调用者\nparticipant Async 函数\nparticipant 执行器\nparticipant 生成器\n\n    调用者-&gt;&gt;Async函数: 调用 asyncFunc()\n    Async函数-&gt;&gt;执行器: “麻烦帮我跑一下这个生成器”\n    执行器-&gt;&gt;生成器: “开始执行咯（调用next()）”\n    生成器--&gt;&gt;执行器: “遇到await了，先停在这”（返回yield的值）\n    执行器-&gt;&gt;Promise: “等你结果出来喊我”\n    Promise--&gt;&gt;执行器: “搞定，结果在这”\n    执行器-&gt;&gt;生成器:  “继续跑吧，这是刚才的结果”（调用next(结果)）\n    生成器--&gt;&gt;执行器: “跑完了，这是最终结果”\n    执行器-&gt;&gt;调用者: “任务完成，给你结果”（Promise resolved）\n\n  </pre></div>\n\n<p>简单说就是：执行器启动生成器后，每次遇到 yield（也就是咱们写的 await）就停下来等异步结果，拿到结果再叫醒生成器继续跑，直到结束。全程不用手动干预，比直接用 Generator 省太多事了～</p>\n<h2 id=\"三、await-到底做了什么？四步看懂它的“小动作”\"><a href=\"#三、await-到底做了什么？四步看懂它的“小动作”\" class=\"headerlink\" title=\"三、await 到底做了什么？四步看懂它的“小动作”\"></a>三、await 到底做了什么？四步看懂它的 “小动作”</h2><p>每次写<code>await</code>的时候，引擎其实在背后干了四件事，我拆开来给大家说说：</p>\n<ol>\n<li><strong>暂停当前函数</strong>：就像按了暂停键，当前的变量、执行位置都被 “冻” 起来</li>\n<li><strong>包装异步结果</strong>：不管 await 后面是 Promise 还是普通值（比如 await 42），都会被转成 Promise。普通值会被 Promise.resolve() 包一层，确保统一用 Promise 处理</li>\n<li><strong>注册回调</strong>：把 await 后面的代码（比如拿到 data 后处理的逻辑）打包成一个微任务，注册到事件循环里</li>\n<li><strong>让出主线程</strong>：当前函数暂停后，主线程会去执行其他任务（比如渲染、处理其他事件），等 Promise 有结果了，再回头执行刚才打包的微任务</li>\n</ol>\n<div class=\"note info flat\"><p><strong>这里有个性能小细节：</strong> <code>await</code>不会阻塞主线程！它只是把后续代码挂起（包装成<mark>微任务</mark>），让主线程先忙别的。这也是为什么用<code>await</code>的时候，页面不会卡 —— 因为它会主动 “让道”。</p>\n</div>\n\n<h2 id=\"四、错误处理：try-catch-居然能管到异步操作？\"><a href=\"#四、错误处理：try-catch-居然能管到异步操作？\" class=\"headerlink\" title=\"四、错误处理：try/catch 居然能管到异步操作？\"></a>四、错误处理：try / catch 居然能管到异步操作？</h2><p>这是我觉得 Async/Await 最方便的一点：用同步代码里的 try/catch 就能搞定异步错误，不用像回调那样嵌套多层 error 处理。</p>\n<h3 id=\"4-1-同步式的错误处理\"><a href=\"#4-1-同步式的错误处理\" class=\"headerlink\" title=\"4.1 同步式的错误处理\"></a>4.1 同步式的错误处理</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchUser</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">'/user'</span>); <span class=\"comment\">// 可能失败</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> posts = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">`/posts/<span class=\"subst\">${user.id}</span>`</span>); <span class=\"comment\">// 依赖上一步结果，也可能失败</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> { user, posts };</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">    <span class=\"comment\">// 不管哪一步失败，都会跑到这里</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">'请求失败:'</span>, error);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> { <span class=\"attr\">user</span>: <span class=\"literal\">null</span>, <span class=\"attr\">posts</span>: [] };</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-2-背后的错误传递\"><a href=\"#4-2-背后的错误传递\" class=\"headerlink\" title=\"4.2 背后的错误传递\"></a>4.2 背后的错误传递</h3><p>为什么 try / catch 能抓到异步错误？秘密在自动执行器的这段代码里：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自动执行器处理Promise的部分</span></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(value).<span class=\"title function_\">then</span>(</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"title function_\">next</span>(v)), <span class=\"comment\">// 成功就传结果继续执行</span></span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"keyword\">throw</span>(e)) <span class=\"comment\">// 失败就把错误抛回生成器！</span></span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>当 await 后面的 Promise 失败时，执行器会调用<code>generator.throw(e)</code>，把错误 “扔回” 生成器函数内部。这时候生成器里的 try / catch 就会像捕获同步错误一样，把这个异步错误接住。</p>\n<blockquote>\n<p>之前用回调的时候，每次异步操作都要单独写 error 处理，现在一个 try / catch 全搞定，代码清爽多了～</p>\n</blockquote>\n<h2 id=\"五、性能优化：我在项目里掉过的性能坑\"><a href=\"#五、性能优化：我在项目里掉过的性能坑\" class=\"headerlink\" title=\"五、性能优化：我在项目里掉过的性能坑\"></a>五、性能优化：我在项目里掉过的性能坑</h2><p>分享几个我实际开发中遇到的问题，都是关于 Async / Await 性能的，新手很容易踩坑：</p>\n<h3 id=\"5-1-坑一：没必要的顺序执行\"><a href=\"#5-1-坑一：没必要的顺序执行\" class=\"headerlink\" title=\"5.1 坑一：没必要的顺序执行\"></a>5.1 坑一：没必要的顺序执行</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反面例子：两个请求本来可以同时跑，却写成了顺序执行</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">slowFetch</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"keyword\">await</span> <span class=\"title function_\">fetchA</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = <span class=\"keyword\">await</span> <span class=\"title function_\">fetchB</span>(); <span class=\"comment\">// 等A完了才开始B</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> [a, b];</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这两个请求如果没依赖关系（比如 A 不影响 B 的参数），完全可以同时启动，我后来改成这样：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 优化后：同时启动两个请求，总耗时是最慢那个的时间</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fastFetch</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 先同时发起请求，拿到两个Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> promiseA = <span class=\"title function_\">fetchA</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promiseB = <span class=\"title function_\">fetchB</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 再等它们结果</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"keyword\">await</span> promiseA;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = <span class=\"keyword\">await</span> promiseB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> [a, b];</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-2-坑二：多余的-await-包装\"><a href=\"#5-2-坑二：多余的-await-包装\" class=\"headerlink\" title=\"5.2 坑二：多余的 await 包装\"></a>5.2 坑二：多余的 await 包装</h3><p>有时候会下意识地在 return 前面加 await，但其实没必要：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 多余的await</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getData</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"title function_\">fetchData</span>(); <span class=\"comment\">// fetchData本身已经返回Promise</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>因为 Async 函数会自动把返回值包成 Promise，这里的 await 纯属多此一举，直接 return 就行：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更简洁高效</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getData</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">fetchData</span>(); <span class=\"comment\">// 等价于上面的写法，但少一层Promise包装</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-3-多个异步操作：用-Promise-all-处理并行\"><a href=\"#5-3-多个异步操作：用-Promise-all-处理并行\" class=\"headerlink\" title=\"5.3 多个异步操作：用 Promise.all()处理并行\"></a>5.3 多个异步操作：用 Promise.all() 处理并行</h3><p>如果需要等多个异步操作都完成，<code>Promise.all()</code>配合 await 是绝配，下面的写法在实际项目中会经常用到哦~</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchAll</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 同时启动，等所有请求完成</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [user, posts] = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([<span class=\"title function_\">fetch</span>(<span class=\"string\">'/user'</span>), <span class=\"title function_\">fetch</span>(<span class=\"string\">'/posts'</span>)]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> { user, posts };</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<div class=\"note warning flat\"><p><strong>不过要注意：</strong> <code>Promise.all()</code>是 “一损俱损”，只要有一个请求失败，整个就会报错，这时候可以用<code>Promise.allSettled()</code>处理需要全部结果的场景（哪怕部分失败）。</p>\n</div>\n\n<h3 id=\"5-4-高级技巧：模块里的顶级-await\"><a href=\"#5-4-高级技巧：模块里的顶级-await\" class=\"headerlink\" title=\"5.4 高级技巧：模块里的顶级 await\"></a>5.4 高级技巧：模块里的顶级 await</h3><p>现在很多打包工具（比如 Webpack、Vite）已经支持模块顶层的 await 了，不用再包在 Async 函数里：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接在模块顶层用await</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = <span class=\"keyword\">await</span> <span class=\"title function_\">loadConfig</span>(); <span class=\"comment\">// 加载配置</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> settings = <span class=\"title function_\">process</span>(config);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其实引擎会把模块转成类似这样</span></span><br><span class=\"line\"><span class=\"title function_\">loadConfig</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">config</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">const</span> settings = <span class=\"title function_\">process</span>(config);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在做一个工具库的时候用过这个，用来加载动态配置，比以前用 IIFE（立即执行函数）清爽多了。</p>\n<h2 id=\"六、Async-Await-实战场景：这些地方用起来超顺手\"><a href=\"#六、Async-Await-实战场景：这些地方用起来超顺手\" class=\"headerlink\" title=\"六、Async/Await 实战场景：这些地方用起来超顺手\"></a>六、Async / Await 实战场景：这些地方用起来超顺手</h2><h3 id=\"6-1-异步初始化（比如数据库连接）\"><a href=\"#6-1-异步初始化（比如数据库连接）\" class=\"headerlink\" title=\"6.1 异步初始化（比如数据库连接）\"></a>6.1 异步初始化（比如数据库连接）</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Database</span> {</span><br><span class=\"line\">  <span class=\"comment\">// 静态方法做异步初始化</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">init</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> connection = <span class=\"keyword\">await</span> <span class=\"title function_\">createConnection</span>(); <span class=\"comment\">// 建立连接（异步）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Database</span>(connection);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用的时候直接await</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> db = <span class=\"keyword\">await</span> <span class=\"title class_\">Database</span>.<span class=\"title function_\">init</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这种场景如果用回调，很容易写成嵌套的 init 回调，用 Async / Await 就清晰多了。</p>\n<h3 id=\"6-2-有依赖关系的顺序请求\"><a href=\"#6-2-有依赖关系的顺序请求\" class=\"headerlink\" title=\"6.2 有依赖关系的顺序请求\"></a>6.2 有依赖关系的顺序请求</h3><p>比如先拿用户 ID，再用 ID 查订单：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">purchase</span>(<span class=\"params\">itemId</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> <span class=\"title function_\">getUser</span>(); <span class=\"comment\">// 先查用户</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> item = <span class=\"keyword\">await</span> <span class=\"title function_\">getItem</span>(itemId); <span class=\"comment\">// 再查商品</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">validatePurchase</span>(user, item); <span class=\"comment\">// 验证能否购买（异步）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> receipt = <span class=\"keyword\">await</span> <span class=\"title function_\">createReceipt</span>(user, item); <span class=\"comment\">// 生成订单</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> receipt;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>步骤再复杂，用顺序 await 写出来也像同步代码一样好懂。</p>\n<h3 id=\"6-3-带重试的请求\"><a href=\"#6-3-带重试的请求\" class=\"headerlink\" title=\"6.3 带重试的请求\"></a>6.3 带重试的请求</h3><p>处理可能偶尔失败的接口时，用 Async / Await 写重试逻辑很直观：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchWithRetry</span>(<span class=\"params\">url, retries = <span class=\"number\">3</span></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retries &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> error; <span class=\"comment\">// 重试次数用完</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">delay</span>(<span class=\"number\">1000</span>); <span class=\"comment\">// 等1秒再重试</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">fetchWithRetry</span>(url, retries - <span class=\"number\">1</span>); <span class=\"comment\">// 递归重试</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在对接一个不稳定的第三方接口时，就用这个逻辑做了重试，成功率提高了不少。</p>\n<h3 id=\"6-4-超时控制（防止请求卡太久）\"><a href=\"#6-4-超时控制（防止请求卡太久）\" class=\"headerlink\" title=\"6.4 超时控制（防止请求卡太久）\"></a>6.4 超时控制（防止请求卡太久）</h3><p>结合<code>Promise.race()</code>实现超时控制：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchWithTimeout</span>(<span class=\"params\">url, timeout = <span class=\"number\">5000</span></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchPromise = <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">  <span class=\"comment\">// 超时Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> timeoutPromise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">_, reject</span>) =&gt;</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">reject</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">'请求超时'</span>)), timeout)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 谁先完成就用谁的结果</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">race</span>([fetchPromise, timeoutPromise]);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这个在做支付回调的时候特别有用，防止因为网络问题让用户一直等。</p>\n<h2 id=\"七、踩过的坑：这些细节要注意\"><a href=\"#七、踩过的坑：这些细节要注意\" class=\"headerlink\" title=\"七、踩过的坑：这些细节要注意\"></a>七、踩过的坑：这些细节要注意</h2><h3 id=\"7-1-箭头函数的-this-陷阱\"><a href=\"#7-1-箭头函数的-this-陷阱\" class=\"headerlink\" title=\"7.1 箭头函数的 this 陷阱\"></a>7.1 箭头函数的 this 陷阱</h3><p>用 Async 箭头函数当对象方法时，<code>this</code>会丢：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有问题：this指向不对</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">  <span class=\"attr\">print</span>: <span class=\"title function_\">async</span> () =&gt; {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>); <span class=\"comment\">// undefined! 因为箭头函数的this是定义时的上下文</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确写法：用传统函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"title function_\">print</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>); <span class=\"comment\">// 42，this指向obj</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在写一个类的方法时犯过这个错，调试了半天才发现是箭头函数的锅。</p>\n<h3 id=\"7-2-控制并发数量\"><a href=\"#7-2-控制并发数量\" class=\"headerlink\" title=\"7.2 控制并发数量\"></a>7.2 控制并发数量</h3><p>如果并行请求太多（比如一次发 20 个接口），可能会触发浏览器的并发限制，这时候需要控制并发数：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">processBatch</span>(<span class=\"params\">items</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = items.<span class=\"title function_\">map</span>(processItem); <span class=\"comment\">// 所有任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 控制最多同时跑5个</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> results = <span class=\"keyword\">await</span> <span class=\"title function_\">throttlePromises</span>(promises, <span class=\"number\">5</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这里的<code>throttlePromises</code>是一个工具函数，原理是把任务分成多批，一批批执行（每批 5 个），避免一次性发起太多请求。</p>\n<h3 id=\"7-3-可取消的异步任务（结合-AbortSignal）\"><a href=\"#7-3-可取消的异步任务（结合-AbortSignal）\" class=\"headerlink\" title=\"7.3 可取消的异步任务（结合 AbortSignal）\"></a>7.3 可取消的异步任务（结合 AbortSignal）</h3><p>有时候需要中途取消异步操作（比如用户离开页面），可以用<code>AbortSignal</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">longRunningTask</span>(<span class=\"params\">abortSignal</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!abortSignal.<span class=\"property\">aborted</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">doWork</span>();<span class=\"comment\">// 每次做一点工作</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每次循环检查退出信号</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (abortSignal.<span class=\"property\">aborted</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"title function_\">cleanup</span>(); <span class=\"comment\">// 做清理工作</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> controller = <span class=\"keyword\">new</span> <span class=\"title class_\">AbortController</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> signal = controller.<span class=\"property\">signal</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动长时间运行的任务</span></span><br><span class=\"line\"><span class=\"title function_\">longRunningTask</span>(signal);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> cancelTask {</span><br><span class=\"line\">  controller.<span class=\"title function_\">abort</span>(); <span class=\"comment\">// 中止任务</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置一个定时器，以便在 3 秒后中止任务</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  <span class=\"title function_\">cancelTask</span>();</span><br><span class=\"line\">}, <span class=\"number\">3000</span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在做一个文件上传组件时用过这个，用户点取消按钮时，就通过<code>AbortSignal</code>终止上传。</p>\n<h2 id=\"八、常见问题解答（我当初学的时候也纠结过）\"><a href=\"#八、常见问题解答（我当初学的时候也纠结过）\" class=\"headerlink\" title=\"八、常见问题解答（我当初学的时候也纠结过）\"></a>八、常见问题解答（我当初学的时候也纠结过）</h2><h3 id=\"Q1-Async-函数会阻塞主线程吗？\"><a href=\"#Q1-Async-函数会阻塞主线程吗？\" class=\"headerlink\" title=\"Q1: Async 函数会阻塞主线程吗？\"></a>Q1: Async 函数会阻塞主线程吗？</h3><p><strong>不会！</strong> Async 函数遇到 await 时会<strong>暂停并释放主线程</strong>，JavaScript 的单线程模型通过事件循环实现异步执行。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'开始'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">delay</span>(<span class=\"number\">1000</span>); <span class=\"comment\">// 假设delay是个等待1秒的Promise</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'结束'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行到 await 时，函数会暂停，主线程可以去处理其他任务（比如点击事件、渲染），等 1 秒后才回头执行 console.log(‘结束’)，所以不会卡页面。</p>\n<h3 id=\"Q2-可以-await-一个非-Promise-值吗？\"><a href=\"#Q2-可以-await-一个非-Promise-值吗？\" class=\"headerlink\" title=\"Q2: 可以 await 一个非 Promise 值吗？\"></a>Q2: 可以 await 一个非 Promise 值吗？</h3><p><strong>可以！</strong> 引擎会自动用 <code>Promise.resolve()</code> 包装非 Promise 值：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getNumber</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> num = <span class=\"keyword\">await</span> <span class=\"number\">42</span>; <span class=\"comment\">// 合法！等价于 await Promise.resolve(42)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>不过实际开发中很少这么用，一般 await 后面都是异步操作返回的 Promise。</p>\n<h3 id=\"Q3-为什么-Async-函数不管-return-什么，最后都返回-Promise？\"><a href=\"#Q3-为什么-Async-函数不管-return-什么，最后都返回-Promise？\" class=\"headerlink\" title=\"Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？\"></a>Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？</h3><p>因为它本质是异步操作的包装器。哪怕你 return 一个原始值，引擎也会用 Promise.resolve() 包一层：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">answer</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">42</span>; <span class=\"comment\">// 等价于 return Promise.resolve(42)</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>所以调用 Async 函数时，必须用<code>await</code>或者<code>.then()</code>才能拿到结果。</p>\n<h3 id=\"Q4-用-Promise-all-的时候，如果有一个请求失败怎么办？\"><a href=\"#Q4-用-Promise-all-的时候，如果有一个请求失败怎么办？\" class=\"headerlink\" title=\"Q4: 用 Promise.all()的时候，如果有一个请求失败怎么办？\"></a>Q4: 用 Promise.all() 的时候，如果有一个请求失败怎么办？</h3><p>之前已经提到过了，Promise.all() 会 “快速失败”—— 只要有一个 Promise 被拒绝，整个 Promise.all() 就会立刻失败，进入 catch。如果需要等所有请求完成（不管成功失败），可以用<code>Promise.allSettled()</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchAll</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> results = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">allSettled</span>([<span class=\"title function_\">fetchA</span>(), <span class=\"title function_\">fetchB</span>()]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 过滤出成功的结果</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> successData = results.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> r.<span class=\"property\">status</span> === <span class=\"string\">'fulfilled'</span>).<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> r.<span class=\"property\">value</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Q5-为什么说-Async-Await-比回调好？\"><a href=\"#Q5-为什么说-Async-Await-比回调好？\" class=\"headerlink\" title=\"Q5: 为什么说 Async/Await 比回调好？\"></a>Q5: 为什么说 Async / Await 比回调好？</h3><p>我总结了几个实际开发中的感受：</p>\n<ul>\n<li>代码不嵌套，扁平结构更易读（告别 “回调地狱”）</li>\n<li>错误处理统一用 try / catch，不用每层回调都写 error 处理</li>\n<li>逻辑顺序和代码执行顺序一致，不用跳来跳去看代码</li>\n<li>调试更方便，错误堆栈更完整（回调的堆栈经常被异步操作打断）</li>\n</ul>\n<hr>\n<p>其实 Async/Await 不算什么高深的技术，就是把 Generator、Promise 这些老东西包装得更好用了。但正是这种 “语法糖”，让我们写异步代码时能少掉很多头发～ 如果你也有过用 Async/Await 踩坑的经历，欢迎在评论区分享呀！</p>\n",
            "tags": [
                "JavaScript",
                "ES2017(ES8)",
                "性能优化"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/generator/",
            "url": "http://toukoxu.github.io/archives/generator/",
            "title": "生成器函数与 yield：掌控函数执行的 “暂停键”",
            "date_published": "2024-07-11T12:46:25.000Z",
            "content_html": "<blockquote>\n<p>生成器函数是 ES6 里很实用的特性，而 <code>yield</code> 就像给函数装了个 “暂停开关”—— 能让函数执行到一半停下来，需要的时候再接着跑。这种 “可控的执行流程”，在处理异步操作、遍历大数据、实现状态切换时特别好用。</p>\n</blockquote>\n<h2 id=\"一、生成器：能“中场休息”的特殊函数\"><a href=\"#一、生成器：能“中场休息”的特殊函数\" class=\"headerlink\" title=\"一、生成器：能“中场休息”的特殊函数\"></a>一、生成器：能 “中场休息” 的特殊函数</h2><h3 id=\"1-1-什么是生成器函数？\"><a href=\"#1-1-什么是生成器函数？\" class=\"headerlink\" title=\"1.1 什么是生成器函数？\"></a>1.1 什么是生成器函数？</h3><p><strong>生成器函数是可以暂停执行、后续恢复的特殊函数</strong>，它的语法很容易识别：用 <code>function*</code> 定义，内部用 <code>yield</code> 控制暂停。</p>\n<p>举个最简单的例子，感受下它的 “暂停 - 恢复” 能力：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用 function* 定义生成器函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">stepGenerator</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'第一步：准备'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'第二步：执行'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'第三步：完成'</span>; <span class=\"comment\">// return 的值会作为最后一次 next() 的 value</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用生成器函数：不会立即执行，而是返回一个“生成器对象”（类似控制器）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> generator = <span class=\"title function_\">stepGenerator</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 next() 恢复执行，直到遇到下一个 yield 或 return</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(generator.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 输出“第一步：准备”（执行到第一个 yield 暂停）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(generator.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 输出“第二步：执行”（恢复后到第二个 yield 暂停）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(generator.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 输出“第三步：完成”（恢复后执行到 return，生成器结束）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"1-2-生成器对象的核心方法\"><a href=\"#1-2-生成器对象的核心方法\" class=\"headerlink\" title=\"1.2 生成器对象的核心方法\"></a>1.2 生成器对象的核心方法</h3><p>生成器对象（比如上面的 <code>generator</code>）有三个关键方法，用来控制函数执行：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>next(value)</code></td>\n<td>恢复执行，可给上一个 <code>yield</code> 传值</td>\n<td><code>generator.next('传入的数据')</code></td>\n</tr>\n<tr>\n<td><code>return(value)</code></td>\n<td>提前结束生成器，后续 <code>next()</code> 都会返回 <code>done: true</code></td>\n<td><code>generator.return('提前终止')</code></td>\n</tr>\n<tr>\n<td><code>throw(error)</code></td>\n<td>向生成器内部抛错，可在生成器里用 <code>try/catch</code> 捕获</td>\n<td><code>generator.throw(new Error('出错了'))</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"1-3-必须注意的两个点\"><a href=\"#1-3-必须注意的两个点\" class=\"headerlink\" title=\"1.3 必须注意的两个点\"></a>1.3 必须注意的两个点</h3><ol>\n<li><p>箭头函数不能做生成器<br>箭头函数没有自己的 <code>this</code> 和 <code>arguments</code>，也不支持 <code>yield</code>，所以没法写成 <code>()* =&gt; {}</code> 这种形式。</p>\n</li>\n<li><p>调用生成器不立即执行<br>和普通函数不同，<code>stepGenerator()</code> 调用后不会跑函数体，而是先返回生成器对象 —— 必须调用 <code>next()</code> 才会开始执行。</p>\n</li>\n</ol>\n<h2 id=\"二、yield：生成器的“暂停开关”与“数据通道”\"><a href=\"#二、yield：生成器的“暂停开关”与“数据通道”\" class=\"headerlink\" title=\"二、yield：生成器的“暂停开关”与“数据通道”\"></a>二、yield：生成器的 “暂停开关” 与 “数据通道”</h2><p><code>yield</code> 不只是 “暂停键”，还能在生成器和外部之间传递数据，相当于一个 “双向通道”。</p>\n<h3 id=\"2-1-yield-的两个核心作用\"><a href=\"#2-1-yield-的两个核心作用\" class=\"headerlink\" title=\"2.1 yield 的两个核心作用\"></a>2.1 yield 的两个核心作用</h3><ol>\n<li>暂停执行，向外传值<br><code>yield 表达式</code> 会让函数暂停，同时把 “表达式的值” 传给外部（通过 <code>next().value</code> 获取）：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">fruitGenerator</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'苹果'</span>; <span class=\"comment\">// 暂停时，向外传“苹果”</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'香蕉'</span>; <span class=\"comment\">// 再次暂停时，向外传“香蕉”</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"title function_\">fruitGenerator</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 拿到“苹果”</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 拿到“香蕉”</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li>接收外部传入的值<br>外部调用 <code>next(值)</code> 时，这个 “值” 会作为<strong>上一个 <code>yield</code> 表达式的返回值</strong>，传给生成器内部：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">chatGenerator</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 第一个 yield：向外传“你叫什么名字？”，暂停后等待外部传值</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> name = <span class=\"keyword\">yield</span> <span class=\"string\">'你叫什么名字？'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 外部传值后，恢复执行：用收到的 name 拼接新内容，再向外传</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">`你好，<span class=\"subst\">${name}</span>！`</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> chat = <span class=\"title function_\">chatGenerator</span>();</span><br><span class=\"line\"><span class=\"comment\">// 第一次 next()：执行到第一个 yield，拿到“你叫什么名字？”</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(chat.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>);</span><br><span class=\"line\"><span class=\"comment\">// 第二次 next('小明')：把“小明”传给上一个 yield，作为 name 的值，执行到第二个 yield</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(chat.<span class=\"title function_\">next</span>(<span class=\"string\">'小明'</span>).<span class=\"property\">value</span>); <span class=\"comment\">// 输出“你好，小明！”</span></span><br></pre></td></tr></tbody></table></figure>\n\n<div class=\"note warning flat\"><p><strong>注意：</strong> <code>next(值)</code> 的 “值”<strong>只给上一个 <code>yield</code></strong>。如果是第一次调用 <code>next()</code>，传值是无效的 —— 因为此时还没有执行过任何 <code>yield</code>。</p>\n</div>\n\n<h3 id=\"2-2-yield-的使用限制\"><a href=\"#2-2-yield-的使用限制\" class=\"headerlink\" title=\"2.2 yield 的使用限制\"></a>2.2 yield 的使用限制</h3><p><code>yield</code> 只能在生成器函数内部用，哪怕是生成器里的嵌套函数也不行，否则会报错：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">wrongGenerator</span>(<span class=\"params\">items</span>) {</span><br><span class=\"line\">  items.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 错误：yield 不能在 forEach 的回调里用（超出了生成器函数的直接作用域）</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> item + <span class=\"number\">1</span>;</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote>\n<p>原理和 <code>return</code> 类似：嵌套函数的 <code>return</code> 不能直接让外层函数返回，<code>yield</code> 也无法跨越函数边界。</p>\n</blockquote>\n<h2 id=\"三、生成器的实际用途：这些场景用它很顺手\"><a href=\"#三、生成器的实际用途：这些场景用它很顺手\" class=\"headerlink\" title=\"三、生成器的实际用途：这些场景用它很顺手\"></a>三、生成器的实际用途：这些场景用它很顺手</h2><p>生成器不是花架子，实际开发中很多场景都能用到，分享几个高频用法：</p>\n<h3 id=\"3-1-自定义迭代器：轻松遍历复杂数据\"><a href=\"#3-1-自定义迭代器：轻松遍历复杂数据\" class=\"headerlink\" title=\"3.1 自定义迭代器：轻松遍历复杂数据\"></a>3.1 自定义迭代器：轻松遍历复杂数据</h3><p>JavaScript 里的 <code>for...of</code> 循环需要 “可迭代对象”（比如数组、字符串），而生成器可以轻松创建自定义的迭代器，不用手动实现 <code>Symbol.iterator</code>。</p>\n<p>比如实现一个 “指定范围的数字迭代器”：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成 从 start 到 end、步长为 step 的数字</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">range</span>(<span class=\"params\">start, end, step = <span class=\"number\">1</span></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = start; i &lt;= end; i += step) {</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> i; <span class=\"comment\">// 每次迭代返回一个数字</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用 for...of 遍历生成器（生成器对象默认是可迭代的）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> num <span class=\"keyword\">of</span> <span class=\"title function_\">range</span>(<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>)) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num); <span class=\"comment\">// 输出 1、3、5</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 也可以用 [...gen] 转成数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> numArray = [...<span class=\"title function_\">range</span>(<span class=\"number\">2</span>, <span class=\"number\">6</span>)];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(numArray); <span class=\"comment\">// 输出 [2, 3, 4, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-2-无限序列：按需生成，不占内存\"><a href=\"#3-2-无限序列：按需生成，不占内存\" class=\"headerlink\" title=\"3.2 无限序列：按需生成，不占内存\"></a>3.2 无限序列：按需生成，不占内存</h3><p>如果需要无限循环的序列（比如斐波那契数列），用普通函数会陷入死循环，但生成器可以 “按需产出”，想要多少要多少：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成无限的斐波那契数列</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">fibonacci</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> [prev, curr] = [<span class=\"number\">0</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 无限循环，但不会卡，因为每次 yield 都会暂停</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> curr; <span class=\"comment\">// 产出当前项</span></span><br><span class=\"line\">    [prev, curr] = [curr, prev + curr]; <span class=\"comment\">// 更新下一项</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fib = <span class=\"title function_\">fibonacci</span>();</span><br><span class=\"line\"><span class=\"comment\">// 想要几项就调用几次 next()</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fib.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fib.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fib.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fib.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fib.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"comment\">// 什么时候停，完全由外部控制</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-3-异步流程管理：async-await-之前的方案\"><a href=\"#3-3-异步流程管理：async-await-之前的方案\" class=\"headerlink\" title=\"3.3 异步流程管理：async/await 之前的方案\"></a>3.3 异步流程管理：async / await 之前的方案</h3><p>在 async / await（👉 <a href=\"/archives/async+await/\" title=\"Async/Await：用同步的方式写异步，真香！\">Async / Await：用同步的方式写异步，真香！</a>）普及前，生成器常用来简化异步代码（避免回调地狱）。核心思路是：用 <code>yield</code> 暂停等待异步结果，拿到结果后再恢复执行。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模拟两个异步请求</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fetchUser</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">resolve</span>({ <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">'小明'</span> }), <span class=\"number\">1000</span>));</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fetchUserOrders</span>(<span class=\"params\">userId</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">resolve</span>([{ <span class=\"attr\">id</span>: <span class=\"number\">101</span>, <span class=\"attr\">goods</span>: <span class=\"string\">'手机'</span> }]), <span class=\"number\">1000</span>));</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用生成器管理异步流程</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">asyncFlow</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 等待 fetchUser 完成，拿到用户数据</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = <span class=\"keyword\">yield</span> <span class=\"title function_\">fetchUser</span>();</span><br><span class=\"line\">  <span class=\"comment\">// 用用户 id 发起第二个请求，等待完成</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> orders = <span class=\"keyword\">yield</span> <span class=\"title function_\">fetchUserOrders</span>(user.<span class=\"property\">id</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 返回最终结果</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> { user, orders };</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自动执行器：帮我们调用 next()，不用手动处理异步</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">runAsync</span>(<span class=\"params\">gen</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> generator = <span class=\"title function_\">gen</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 递归处理异步结果</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">handleResult</span>(<span class=\"params\">result</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result.<span class=\"property\">done</span>) {</span><br><span class=\"line\">      <span class=\"comment\">// 生成器结束，返回最终结果</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(result.<span class=\"property\">value</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 结果是 Promise，等待完成后把数据传给下一个 next()</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result.<span class=\"property\">value</span>.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> <span class=\"title function_\">handleResult</span>(generator.<span class=\"title function_\">next</span>(data)));</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">handleResult</span>(generator.<span class=\"title function_\">next</span>());</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行异步流程</span></span><br><span class=\"line\"><span class=\"title function_\">runAsync</span>(asyncFlow).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'最终结果：'</span>, result);</span><br><span class=\"line\">  <span class=\"comment\">// 2秒后输出：{ user: { id:1, name:'小明' }, orders: [{ id:101, goods:'手机' }] }</span></span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<p>现在虽然 <code>async/await</code> 更常用，但理解这种思路，能帮你更好地掌握异步编程的本质。</p>\n<h3 id=\"3-4-状态机：清晰管理状态切换\"><a href=\"#3-4-状态机：清晰管理状态切换\" class=\"headerlink\" title=\"3.4 状态机：清晰管理状态切换\"></a>3.4 状态机：清晰管理状态切换</h3><p>比如交通灯的 “红 → 绿 → 黄” 循环，用生成器实现状态切换，逻辑特别清晰：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 交通灯状态机</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">trafficLight</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'红灯：等待3秒'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'绿灯：通行5秒'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'黄灯：准备2秒'</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> light = <span class=\"title function_\">trafficLight</span>();</span><br><span class=\"line\"><span class=\"comment\">// 每次调用 next()，切换一次状态</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(light.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 红灯：等待3秒</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(light.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 绿灯：通行5秒</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(light.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 黄灯：准备2秒</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(light.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 红灯：等待3秒（循环）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"四、yield-：生成器的“委托执行”\"><a href=\"#四、yield-：生成器的“委托执行”\" class=\"headerlink\" title=\"四、yield*：生成器的“委托执行”\"></a>四、yield*：生成器的 “委托执行”</h2><p>如果一个生成器需要调用另一个生成器，可以用 <code>yield*</code> 实现 “委托”—— 让被调用的生成器先执行完，再回到当前生成器。</p>\n<h3 id=\"4-1-基本用法：委托执行其他生成器\"><a href=\"#4-1-基本用法：委托执行其他生成器\" class=\"headerlink\" title=\"4.1 基本用法：委托执行其他生成器\"></a>4.1 基本用法：委托执行其他生成器</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成器 A</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">generatorA</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'A1'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'A2'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成器 B：委托 generatorA 执行</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">generatorB</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'B1'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span>* <span class=\"title function_\">generatorA</span>(); <span class=\"comment\">// 委托：先把 generatorA 执行完</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'B2'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历 generatorB，看看顺序</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = [...<span class=\"title function_\">generatorB</span>()];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result); <span class=\"comment\">// 输出 [\"B1\", \"A1\", \"A2\", \"B2\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>可以看到，<code>yield* generatorA()</code> 会让 <code>generatorA</code> 的所有 <code>yield</code> 先执行，再继续 <code>generatorB</code> 后续的代码。</p>\n<h3 id=\"4-2-实用场景：递归遍历树形结构\"><a href=\"#4-2-实用场景：递归遍历树形结构\" class=\"headerlink\" title=\"4.2 实用场景：递归遍历树形结构\"></a>4.2 实用场景：递归遍历树形结构</h3><p>比如遍历 DOM 树、文件夹目录这种层级结构，用 <code>yield*</code> 递归委托特别方便：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历树形结构（比如 DOM 树）</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">traverseTree</span>(<span class=\"params\">node</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> node; <span class=\"comment\">// 先产出当前节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果有子节点，递归委托遍历子节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.<span class=\"property\">children</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> child <span class=\"keyword\">of</span> node.<span class=\"property\">children</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">yield</span>* <span class=\"title function_\">traverseTree</span>(child);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历 body 下的所有 DOM 节点</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bodyTree = <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> node <span class=\"keyword\">of</span> <span class=\"title function_\">traverseTree</span>(bodyTree)) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(node.<span class=\"property\">tagName</span>); <span class=\"comment\">// 依次输出 body、div、p、span 等标签名</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"五、生成器最佳实践：避坑与优化\"><a href=\"#五、生成器最佳实践：避坑与优化\" class=\"headerlink\" title=\"五、生成器最佳实践：避坑与优化\"></a>五、生成器最佳实践：避坑与优化</h2><h3 id=\"5-1-资源清理：用-try…finally-确保释放\"><a href=\"#5-1-资源清理：用-try…finally-确保释放\" class=\"headerlink\" title=\"5.1 资源清理：用 try…finally 确保释放\"></a>5.1 资源清理：用 try…finally 确保释放</h3><p>如果生成器里用到了需要手动释放的资源（比如文件句柄、网络连接），一定要用 <code>try...finally</code>—— 哪怕生成器被提前终止（比如调用 <code>return()</code>），<code>finally</code> 里的代码也会执行，避免资源泄漏。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">resourceGenerator</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 模拟获取资源（比如打开文件）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> resource = <span class=\"title function_\">openResource</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'使用资源处理数据'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'继续使用资源'</span>;</span><br><span class=\"line\">  } <span class=\"keyword\">finally</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 无论生成器正常结束还是提前终止，都会执行这里</span></span><br><span class=\"line\">    <span class=\"title function_\">closeResource</span>(resource); <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"title function_\">resourceGenerator</span>();</span><br><span class=\"line\">gen.<span class=\"title function_\">next</span>(); <span class=\"comment\">// 执行到第一个 yield</span></span><br><span class=\"line\">gen.<span class=\"keyword\">return</span>(<span class=\"string\">'提前结束'</span>); <span class=\"comment\">// 提前终止，会触发 finally 里的 closeResource</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-2-避免无限循环：加安全边界\"><a href=\"#5-2-避免无限循环：加安全边界\" class=\"headerlink\" title=\"5.2 避免无限循环：加安全边界\"></a>5.2 避免无限循环：加安全边界</h3><p>除非确实需要 “无限序列”（比如斐波那契），否则一定要给生成器加终止条件 —— 避免不小心写成死循环，导致内存溢出。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 安全的生成器：最多生成 100 个值</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">limitedGenerator</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (count &lt; <span class=\"number\">100</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 终止条件：count 到 100 就停</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> count++;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-3-异常处理：用-throw-抛错，try-catch-捕获\"><a href=\"#5-3-异常处理：用-throw-抛错，try-catch-捕获\" class=\"headerlink\" title=\"5.3 异常处理：用 throw() 抛错，try/catch 捕获\"></a>5.3 异常处理：用 throw () 抛错，try / catch 捕获</h3><p>如果生成器执行中需要处理错误，可以在外部调用 <code>generator.throw(错误)</code>，然后在生成器内部用 <code>try/catch</code> 捕获：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">errorHandleGenerator</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'正常执行中'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'这一步可能出错'</span>;</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span> (err) {</span><br><span class=\"line\">    <span class=\"comment\">// 捕获外部抛入的错误</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">`捕获到错误：<span class=\"subst\">${err.message}</span>`</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"title function_\">errorHandleGenerator</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 输出“正常执行中”</span></span><br><span class=\"line\"><span class=\"comment\">// 向生成器抛错</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"keyword\">throw</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">'测试错误'</span>)).<span class=\"property\">value</span>); <span class=\"comment\">// 输出“捕获到错误：测试错误”</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"六、生成器-vs-普通函数：核心差异对比\"><a href=\"#六、生成器-vs-普通函数：核心差异对比\" class=\"headerlink\" title=\"六、生成器 vs 普通函数：核心差异对比\"></a>六、生成器 vs 普通函数：核心差异对比</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>普通函数</th>\n<th>生成器函数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>执行流程</strong></td>\n<td>一旦开始，必须执行完</td>\n<td>可暂停（<code>yield</code>）、可恢复（<code>next()</code>）</td>\n</tr>\n<tr>\n<td><strong>返回值</strong></td>\n<td>只能返回一次值（<code>return</code>）</td>\n<td>可多次返回值（<code>yield</code>），最后一次 <code>return</code> 是收尾</td>\n</tr>\n<tr>\n<td><strong>内存效率</strong></td>\n<td>一次性处理所有数据，大数据易内存溢出</td>\n<td>按需生成值，处理大数据更高效</td>\n</tr>\n<tr>\n<td><strong>状态保持</strong></td>\n<td>执行完后局部变量销毁，不保持状态</td>\n<td>暂停时保留局部变量状态，恢复后继续使用</td>\n</tr>\n<tr>\n<td><strong>定义语法</strong></td>\n<td><code>function 函数名() {}</code></td>\n<td><code>function* 函数名() {}</code></td>\n</tr>\n</tbody></table>\n<hr>\n<p>生成器的核心价值在于 “可控的执行流程” 和 “按需产出数据”—— 它不像 <code>async/await</code> 那样专门解决异步问题，而是在迭代、状态管理、大数据处理等场景都能发挥作用。如果你需要更灵活地控制函数执行，或者想简化复杂的遍历逻辑，不妨试试生成器～</p>\n",
            "tags": [
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/message-channel/",
            "url": "http://toukoxu.github.io/archives/message-channel/",
            "title": "MessageChannel 详解：浏览器中的 “点对点双向通信管道”",
            "date_published": "2024-06-23T12:46:25.000Z",
            "content_html": "<blockquote>\n<p><code>MessageChannel</code> 是浏览器提供的<strong>点对点双向通信 API</strong>，核心是创建一对关联的 “通信端口”（<code>port1</code> 和 <code>port2</code>），让不同上下文（比如主线程与 Worker、父页面与 iframe）能安全、高效地传递消息。它不像全局事件那样容易污染，也比普通 <code>postMessage</code> 更专注于 “一对一” 通信场景。</p>\n</blockquote>\n<h2 id=\"一、核心概念：从创建到通信的基本流程\"><a href=\"#一、核心概念：从创建到通信的基本流程\" class=\"headerlink\" title=\"一、核心概念：从创建到通信的基本流程\"></a>一、核心概念：从创建到通信的基本流程</h2><p><code>MessageChannel</code> 的用法很直观：先创建通道，拿到两个端口，再通过端口的 <code>postMessage</code> 发消息、<code>onmessage</code> 收消息，形成双向通信链路。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建一个 MessageChannel 实例（相当于建立一条通信管道）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> channel = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageChannel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 从管道中获取两个相互关联的端口（port1 和 port2 是“一对”）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> port1 = channel.<span class=\"property\">port1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> port2 = channel.<span class=\"property\">port2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 端口1 发送消息（可传字符串、对象等结构化数据）</span></span><br><span class=\"line\">port1.<span class=\"title function_\">postMessage</span>(<span class=\"string\">'你好，我是 port1！'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 端口2 监听并接收消息</span></span><br><span class=\"line\">port2.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'port2 收到消息：'</span>, event.<span class=\"property\">data</span>); <span class=\"comment\">// 输出“你好，我是 port1！”</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5. 端口2 也能回复消息（双向通信）</span></span><br><span class=\"line\">  port2.<span class=\"title function_\">postMessage</span>(<span class=\"string\">'收到啦，port1！'</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 6. 端口1 接收端口2 的回复</span></span><br><span class=\"line\">port1.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'port1 收到回复：'</span>, event.<span class=\"property\">data</span>); <span class=\"comment\">// 输出“收到啦，port1！”</span></span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这里有个关键逻辑：<code>port1</code> 发的消息只有 <code>port2</code> 能收，<code>port2</code> 发的消息也只有 <code>port1</code> 能收 —— 它们是 “点对点绑定” 的，不会被其他上下文干扰。</p>\n<h2 id=\"二、MessageChannel-的核心特性\"><a href=\"#二、MessageChannel-的核心特性\" class=\"headerlink\" title=\"二、MessageChannel 的核心特性\"></a>二、MessageChannel 的核心特性</h2><ol>\n<li><strong>双向平等通信</strong>：<code>port1</code> 和 <code>port2</code> 没有 “主从” 之分，双方都能主动发消息、收消息，通信是双向的。</li>\n<li><strong>独立消息队列</strong>：每个端口都有自己的消息队列，消息按发送顺序处理，不会出现 “插队” 或混乱。</li>\n<li><strong>同源安全限制</strong>：和 <code>postMessage</code> 一样，默认遵循同源策略（协议、域名、端口一致），跨域通信需要额外配置（如 <code>postMessage</code> 的目标 Origin）。</li>\n<li><strong>支持 “可转移对象”</strong>：能传递 <code>ArrayBuffer</code>、<code>MessagePort</code> 这类特殊对象，转移后原上下文会失去对对象的控制权（避免数据拷贝，提升性能）。</li>\n<li><strong>低延迟任务调度</strong>：比 <code>setTimeout(fn, 0)</code> 更高效 ——<code>MessageChannel</code> 的消息回调会进入 “微任务队列”，执行时机更早，延迟更低。</li>\n</ol>\n<h2 id=\"三、实战场景：这些地方用-MessageChannel-更合适\"><a href=\"#三、实战场景：这些地方用-MessageChannel-更合适\" class=\"headerlink\" title=\"三、实战场景：这些地方用 MessageChannel 更合适\"></a>三、实战场景：这些地方用 MessageChannel 更合适</h2><h3 id=\"3-1-主线程与-Web-Worker-的“专用通信”\"><a href=\"#3-1-主线程与-Web-Worker-的“专用通信”\" class=\"headerlink\" title=\"3.1 主线程与 Web Worker 的“专用通信”\"></a>3.1 主线程与 Web Worker 的 “专用通信”</h3><p>Web Worker 是主线程之外的独立线程，两者通信常用 <code>postMessage</code>，但如果需要 “长期、专用” 的通信链路（比如频繁传递大数据），<code>MessageChannel</code> 更合适 —— 避免和其他消息混在一起。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程代码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(<span class=\"string\">'worker.js'</span>); <span class=\"comment\">// 新建 Worker</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> channel = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageChannel</span>(); <span class=\"comment\">// 创建通信管道</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把 port2 传给 Worker（通过 postMessage 的“转移列表”，确保端口唯一）</span></span><br><span class=\"line\">worker.<span class=\"title function_\">postMessage</span>(<span class=\"string\">'初始化通信端口'</span>, [channel.<span class=\"property\">port2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主线程通过 port1 与 Worker 通信</span></span><br><span class=\"line\">channel.<span class=\"property\">port1</span>.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'主线程收到 Worker 消息：'</span>, event.<span class=\"property\">data</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主线程给 Worker 发消息</span></span><br><span class=\"line\">channel.<span class=\"property\">port1</span>.<span class=\"title function_\">postMessage</span>({ <span class=\"attr\">type</span>: <span class=\"string\">'FETCH_DATA'</span>, <span class=\"attr\">url</span>: <span class=\"string\">'/api/data'</span> });</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// worker.js（Worker 线程代码）</span></span><br><span class=\"line\">self.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"comment\">// 接收主线程传来的 port2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.<span class=\"property\">data</span> === <span class=\"string\">'初始化通信端口'</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> port = event.<span class=\"property\">ports</span>[<span class=\"number\">0</span>]; <span class=\"comment\">// 拿到 port2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Worker 通过 port 接收主线程消息</span></span><br><span class=\"line\">    port.<span class=\"property\">onmessage</span> = <span class=\"title function_\">async</span> (e) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (e.<span class=\"property\">data</span>.<span class=\"property\">type</span> === <span class=\"string\">'FETCH_DATA'</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 模拟请求数据</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(e.<span class=\"property\">data</span>.<span class=\"property\">url</span>);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> res.<span class=\"title function_\">json</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把数据发回主线程</span></span><br><span class=\"line\">        port.<span class=\"title function_\">postMessage</span>({ <span class=\"attr\">type</span>: <span class=\"string\">'DATA_SUCCESS'</span>, data });</span><br><span class=\"line\">      }</span><br><span class=\"line\">    };</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这种方式的好处是：主线程与 Worker 的通信被 “隔离” 在这对端口中，不会和其他 <code>worker.postMessage</code> 消息混淆。</p>\n<h3 id=\"3-2-父页面与-iframe-的跨上下文通信\"><a href=\"#3-2-父页面与-iframe-的跨上下文通信\" class=\"headerlink\" title=\"3.2 父页面与 iframe 的跨上下文通信\"></a>3.2 父页面与 iframe 的跨上下文通信</h3><p>如果页面里有 iframe，且需要和 iframe 进行 “一对一” 通信（比如父子页面传递表单数据），<code>MessageChannel</code> 比直接用 <code>iframe.contentWindow.postMessage</code> 更安全（避免消息被其他 iframe 监听）。</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 父页面代码 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">id</span>=<span class=\"string\">\"childIframe\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"child.html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">const</span> iframe = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'childIframe'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">const</span> channel = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageChannel</span>();</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"comment\">// 等 iframe 加载完成后，传递 port2 给子页面</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  iframe.<span class=\"property\">onload</span> = <span class=\"function\">() =&gt;</span> {</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 第三个参数是“转移列表”，把 port2 的控制权转给 iframe</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    iframe.<span class=\"property\">contentWindow</span>.<span class=\"title function_\">postMessage</span>(<span class=\"string\">'绑定通信端口'</span>, <span class=\"string\">'*'</span>, [channel.<span class=\"property\">port2</span>]);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  };</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"comment\">// 父页面通过 port1 接收 iframe 消息</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  channel.<span class=\"property\">port1</span>.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'父页面收到 iframe 消息：'</span>, event.<span class=\"property\">data</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 比如收到 iframe 传来的表单数据，做后续处理</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  };</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"comment\">// 父页面给 iframe 发消息（比如传递配置）</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  channel.<span class=\"property\">port1</span>.<span class=\"title function_\">postMessage</span>({ <span class=\"attr\">theme</span>: <span class=\"string\">'dark'</span>, <span class=\"attr\">userId</span>: <span class=\"number\">123</span> });</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- child.html（iframe 子页面代码） --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"comment\">// 监听父页面传来的“绑定端口”消息</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'message'</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">if</span> (event.<span class=\"property\">data</span> === <span class=\"string\">'绑定通信端口'</span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> port = event.<span class=\"property\">ports</span>[<span class=\"number\">0</span>]; <span class=\"comment\">// 拿到父页面传来的 port2</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"comment\">// 子页面给父页面发消息（比如传递表单数据）</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">      port.<span class=\"title function_\">postMessage</span>({</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"attr\">formData</span>: { <span class=\"attr\">username</span>: <span class=\"string\">'test'</span>, <span class=\"attr\">email</span>: <span class=\"string\">'test@xxx.com'</span> },</span></span><br><span class=\"line\"><span class=\"language-javascript\">      });</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"comment\">// 子页面接收父页面的消息（比如配置）</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">      port.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> {</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'iframe 收到父页面配置：'</span>, e.<span class=\"property\">data</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"comment\">// 根据配置设置页面主题等</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">      };</span></span><br><span class=\"line\"><span class=\"language-javascript\">    }</span></span><br><span class=\"line\"><span class=\"language-javascript\">  });</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-3-非父子组件通信（以-React-为例）\"><a href=\"#3-3-非父子组件通信（以-React-为例）\" class=\"headerlink\" title=\"3.3 非父子组件通信（以 React 为例）\"></a>3.3 非父子组件通信（以 React 为例）</h3><p>在 React、Vue 等框架中，如果两个组件没有直接的父子关系（比如兄弟组件、跨层级组件），用 <code>MessageChannel</code> 可以实现 “无侵入” 的通信，不用依赖全局状态（如 Redux）或事件总线。</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 先创建一个全局的 MessageChannel（可放在单独的工具文件中）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> componentChannel = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageChannel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 组件 A（发送消息的一方）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">ComponentA</span> = (<span class=\"params\"></span>) =&gt; {</span><br><span class=\"line\">  <span class=\"comment\">// 点击按钮时给 ComponentB 发消息</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">sendMessage</span> = (<span class=\"params\"></span>) =&gt; {</span><br><span class=\"line\">    componentChannel.<span class=\"property\">port2</span>.<span class=\"title function_\">postMessage</span>({</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"string\">'UPDATE_COUNT'</span>,</span><br><span class=\"line\">      <span class=\"attr\">count</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">    });</span><br><span class=\"line\">  };</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{sendMessage}</span>&gt;</span>给 ComponentB 发消息<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 组件 B（接收消息的一方）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">ComponentB</span> = (<span class=\"params\"></span>) =&gt; {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 组件挂载时，监听 port1 的消息</span></span><br><span class=\"line\">  <span class=\"title class_\">React</span>.<span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">handleMessage</span> = (<span class=\"params\">event</span>) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (event.<span class=\"property\">data</span>.<span class=\"property\">type</span> === <span class=\"string\">'UPDATE_COUNT'</span>) {</span><br><span class=\"line\">        <span class=\"title function_\">setCount</span>(event.<span class=\"property\">data</span>.<span class=\"property\">count</span>); <span class=\"comment\">// 更新组件状态</span></span><br><span class=\"line\">      }</span><br><span class=\"line\">    };</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绑定消息监听</span></span><br><span class=\"line\">    componentChannel.<span class=\"property\">port1</span>.<span class=\"property\">onmessage</span> = handleMessage;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 组件卸载时，关闭端口（避免内存泄漏）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      componentChannel.<span class=\"property\">port1</span>.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">    };</span><br><span class=\"line\">  }, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>从 ComponentA 收到的 count：{count}<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这种方式的好处是：组件间通信不依赖框架 API，逻辑更独立，也不会污染全局事件。</p>\n<h3 id=\"3-4-性能优化：替代-setTimeout-的“微任务调度”\"><a href=\"#3-4-性能优化：替代-setTimeout-的“微任务调度”\" class=\"headerlink\" title=\"3.4 性能优化：替代 setTimeout 的“微任务调度”\"></a>3.4 性能优化：替代 setTimeout 的 “微任务调度”</h3><p><code>setTimeout(fn, 0)</code> 会把任务推到 “宏任务队列”，延迟较高（通常 4ms 以上）；而 <code>MessageChannel</code> 的消息回调会进入 “微任务队列”，执行时机更早，适合需要 “尽快执行但不阻塞当前同步代码” 的场景（比如 DOM 更新后执行回调）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用 MessageChannel 实现“微任务调度”</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">scheduleMicroTask</span>(<span class=\"params\">task</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> { port1, port2 } = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageChannel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// port1 收到消息后执行任务</span></span><br><span class=\"line\">  port1.<span class=\"property\">onmessage</span> = <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"title function_\">task</span>();</span><br><span class=\"line\">    port1.<span class=\"title function_\">close</span>(); <span class=\"comment\">// 执行完关闭端口，避免内存泄漏</span></span><br><span class=\"line\">  };</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 发送一条空消息，触发 port1 的回调</span></span><br><span class=\"line\">  port2.<span class=\"title function_\">postMessage</span>(<span class=\"string\">'run'</span>);</span><br><span class=\"line\">  port2.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用示例：</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'同步代码开始'</span>);</span><br><span class=\"line\"><span class=\"title function_\">scheduleMicroTask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'微任务执行（MessageChannel）'</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'宏任务执行（setTimeout）'</span>);</span><br><span class=\"line\">}, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'同步代码结束'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行顺序：</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 同步代码开始</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 同步代码结束</span></span><br><span class=\"line\"><span class=\"comment\">// 3. 微任务执行（MessageChannel）</span></span><br><span class=\"line\"><span class=\"comment\">// 4. 宏任务执行（setTimeout）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-5-主线程与-Service-Worker-的双向通信\"><a href=\"#3-5-主线程与-Service-Worker-的双向通信\" class=\"headerlink\" title=\"3.5 主线程与 Service Worker 的双向通信\"></a>3.5 主线程与 Service Worker 的双向通信</h3><p>Service Worker 负责离线缓存、后台同步等功能，主线程与它通信时，<code>MessageChannel</code> 可以建立 “长期专用链路”，避免消息混淆（比如同时处理缓存更新和推送通知）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程代码（页面中）</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator) {</span><br><span class=\"line\">  navigator.<span class=\"property\">serviceWorker</span>.<span class=\"title function_\">register</span>(<span class=\"string\">'/sw.js'</span>).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">registration</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 注册成功后，创建 MessageChannel</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> channel = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageChannel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 把 port2 传给 Service Worker</span></span><br><span class=\"line\">    registration.<span class=\"property\">active</span>.<span class=\"title function_\">postMessage</span>(<span class=\"string\">'绑定 SW 通信端口'</span>, [channel.<span class=\"property\">port2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 主线程通过 port1 接收 SW 消息（比如缓存更新结果）</span></span><br><span class=\"line\">    channel.<span class=\"property\">port1</span>.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'主线程收到 SW 消息：'</span>, event.<span class=\"property\">data</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (event.<span class=\"property\">data</span>.<span class=\"property\">type</span> === <span class=\"string\">'CACHE_UPDATED'</span>) {</span><br><span class=\"line\">        <span class=\"title function_\">alert</span>(<span class=\"string\">'缓存已更新，下次访问更快速！'</span>);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    };</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 主线程给 SW 发消息（比如触发缓存更新）</span></span><br><span class=\"line\">    channel.<span class=\"property\">port1</span>.<span class=\"title function_\">postMessage</span>({</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"string\">'UPDATE_CACHE'</span>,</span><br><span class=\"line\">      <span class=\"attr\">urls</span>: [<span class=\"string\">'/index.html'</span>, <span class=\"string\">'/style.css'</span>],</span><br><span class=\"line\">    });</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// sw.js（Service Worker 代码）</span></span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'message'</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.<span class=\"property\">data</span> === <span class=\"string\">'绑定 SW 通信端口'</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> port = event.<span class=\"property\">ports</span>[<span class=\"number\">0</span>]; <span class=\"comment\">// 拿到主线程传来的 port2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// SW 接收主线程消息（比如处理缓存更新）</span></span><br><span class=\"line\">    port.<span class=\"property\">onmessage</span> = <span class=\"title function_\">async</span> (e) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (e.<span class=\"property\">data</span>.<span class=\"property\">type</span> === <span class=\"string\">'UPDATE_CACHE'</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">          <span class=\"comment\">// 模拟更新缓存</span></span><br><span class=\"line\">          <span class=\"keyword\">const</span> cache = <span class=\"keyword\">await</span> caches.<span class=\"title function_\">open</span>(<span class=\"string\">'v2'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">await</span> cache.<span class=\"title function_\">addAll</span>(e.<span class=\"property\">data</span>.<span class=\"property\">urls</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 给主线程回复“缓存更新成功”</span></span><br><span class=\"line\">          port.<span class=\"title function_\">postMessage</span>({ <span class=\"attr\">type</span>: <span class=\"string\">'CACHE_UPDATED'</span>, <span class=\"attr\">success</span>: <span class=\"literal\">true</span> });</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (err) {</span><br><span class=\"line\">          port.<span class=\"title function_\">postMessage</span>({ <span class=\"attr\">type</span>: <span class=\"string\">'CACHE_ERROR'</span>, <span class=\"attr\">error</span>: err.<span class=\"property\">message</span> });</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">    };</span><br><span class=\"line\">  }</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"四、关键注意事项：避坑指南\"><a href=\"#四、关键注意事项：避坑指南\" class=\"headerlink\" title=\"四、关键注意事项：避坑指南\"></a>四、关键注意事项：避坑指南</h2><ol>\n<li><p><strong>使用后必须关闭端口，避免内存泄漏</strong><br>端口如果不手动关闭，会一直占用内存（尤其是在组件卸载、Worker 终止时）。关闭端口用 <code>port.close()</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件卸载或通信结束时关闭端口</span></span><br><span class=\"line\">port1.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">port2.<span class=\"title function_\">close</span>();</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p><strong>消息传递遵循 “结构化克隆算法”</strong><br>能传递的对象包括：字符串、数字、数组、普通对象、<code>Map</code>、<code>Set</code>、<code>ArrayBuffer</code>、<code>Blob</code> 等，但<strong>不能传递函数、DOM 元素、循环引用对象</strong>。如果传递不支持的类型，会触发 <code>onmessageerror</code>。</p>\n</li>\n<li><p><strong>必须监听错误事件（onmessageerror）</strong><br>当消息无法解析（比如传递了不支持的类型）时，会触发 <code>onmessageerror</code>，不监听会导致控制台报错：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port1.<span class=\"property\">onmessageerror</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">'消息解析失败：'</span>, event.<span class=\"property\">error</span>);</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p><strong>端口只能 “转移”，不能 “复制”</strong><br>把端口通过 <code>postMessage</code> 传递给其他上下文时，必须放在 “转移列表”（第三个参数）中 —— 转移后，原上下文的端口会失效，只能在目标上下文使用（确保端口唯一，避免通信混乱）。</p>\n</li>\n</ol>\n<h2 id=\"五、对比其他通信方式：该选哪一个？\"><a href=\"#五、对比其他通信方式：该选哪一个？\" class=\"headerlink\" title=\"五、对比其他通信方式：该选哪一个？\"></a>五、对比其他通信方式：该选哪一个？</h2><table>\n<thead>\n<tr>\n<th>通信方式</th>\n<th>适用场景</th>\n<th>核心特点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MessageChannel</code></td>\n<td>点对点精确通信（如主线程 - Worker、父 - iframe）</td>\n<td>双向、低延迟、专用链路、可转移对象</td>\n<td>只支持 “一对一”，不适合广播</td>\n</tr>\n<tr>\n<td>普通 <code>postMessage</code></td>\n<td>简单的跨窗口通信（如父 - iframe 单次消息）</td>\n<td>无需创建通道，用法简单</td>\n<td>需持有目标上下文引用，易混淆</td>\n</tr>\n<tr>\n<td><code>BroadcastChannel</code></td>\n<td>同源所有上下文广播（如多标签页同步状态）</td>\n<td>一对多、无需目标引用</td>\n<td>不支持可转移对象，跨域受限</td>\n</tr>\n<tr>\n<td><code>SharedWorker</code></td>\n<td>多标签页共享数据 / 计算（如共享缓存）</td>\n<td>持久化连接，多上下文共享</td>\n<td>实现复杂，浏览器兼容性稍差</td>\n</tr>\n<tr>\n<td><code>CustomEvent</code></td>\n<td>同文档内组件通信（如父子组件）</td>\n<td>同步执行，易集成</td>\n<td>受事件冒泡影响，无法跨上下文</td>\n</tr>\n</tbody></table>\n<p>简单总结：</p>\n<ul>\n<li>若需要 “一对一、低延迟、长期通信” → 选 <code>MessageChannel</code>；</li>\n<li>若需要 “一对多广播” → 选 <code>BroadcastChannel</code>；</li>\n<li>若只是 “同文档内简单通信” → 选 <code>CustomEvent</code>；</li>\n<li>若需要 “多标签页共享计算” → 选 <code>SharedWorker</code>。</li>\n</ul>\n<hr>\n<p><code>MessageChannel</code> 虽然不是日常开发中 “天天用” 的 API，但在处理 “跨上下文专用通信” 和 “高性能任务调度” 时，它是比其他方案更优雅、更高效的选择。掌握它，能让你在面对复杂通信场景时多一种可靠的解决方案～</p>\n",
            "tags": [
                "JavaScript",
                "性能优化"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/iterator/",
            "url": "http://toukoxu.github.io/archives/iterator/",
            "title": "迭代器（Iterator）与解构：JS 数据遍历与拆箱的实用指南",
            "date_published": "2024-06-14T12:46:25.000Z",
            "content_html": "<blockquote>\n<p>迭代器是 JS 统一数据遍历的 “通用接口”，解构则是简化数据提取的 “语法糖”—— 两者结合能让你更优雅地处理数组、对象、DOM 集合等各种数据结构。这篇文章从原理到实战，带你吃透这两个高频用到的核心特性。</p>\n</blockquote>\n<h2 id=\"一、迭代器：统一数据遍历的“通用接口”\"><a href=\"#一、迭代器：统一数据遍历的“通用接口”\" class=\"headerlink\" title=\"一、迭代器：统一数据遍历的“通用接口”\"></a>一、迭代器：统一数据遍历的 “通用接口”</h2><h3 id=\"1-1-什么是迭代器？\"><a href=\"#1-1-什么是迭代器？\" class=\"headerlink\" title=\"1.1 什么是迭代器？\"></a>1.1 什么是迭代器？</h3><p>迭代器本质是一套 <strong>标准化协议</strong>（Iterator Protocol），定义了 “如何按顺序访问数据集合” 的规则。简单说：只要一个对象实现了这套协议，就能用统一的方式（比如 <code>for...of</code>）遍历，不管它是数组、字符串还是自定义对象。</p>\n<p>举个生活化的例子：你有一个文件夹，里面有多个文件。迭代器就像一个 “文件读取器”—— 它记住当前读到哪个文件，每次告诉你 “下一个文件是什么”，直到所有文件读完。</p>\n<p>看个自定义迭代器的实现，理解它的核心逻辑：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模拟一个“文件夹”对象，里面有多个“文件”</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> folder = {</span><br><span class=\"line\">  <span class=\"attr\">files</span>: [<span class=\"string\">'笔记.txt'</span>, <span class=\"string\">'照片.jpg'</span>, <span class=\"string\">'文档.pdf'</span>],</span><br><span class=\"line\">  <span class=\"comment\">// 实现迭代器协议的核心：[Symbol.iterator] 方法</span></span><br><span class=\"line\">  [<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]() {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> currentIndex = <span class=\"number\">0</span>; <span class=\"comment\">// 记录当前遍历位置（迭代状态）</span></span><br><span class=\"line\">    <span class=\"comment\">// 返回迭代器对象，必须有 next() 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> {</span><br><span class=\"line\">      <span class=\"attr\">next</span>: <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">        <span class=\"comment\">// next() 必须返回 { value: 当前值, done: 是否遍历完 }</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentIndex &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">files</span>.<span class=\"property\">length</span>) {</span><br><span class=\"line\">          <span class=\"keyword\">return</span> {</span><br><span class=\"line\">            <span class=\"attr\">value</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">files</span>[currentIndex++],</span><br><span class=\"line\">            <span class=\"attr\">done</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          };</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">          <span class=\"comment\">// 遍历完，done 设为 true，value 可省略</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> { <span class=\"attr\">done</span>: <span class=\"literal\">true</span> };</span><br><span class=\"line\">        }</span><br><span class=\"line\">      },</span><br><span class=\"line\">    };</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用迭代器遍历文件夹</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fileIterator = folder[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>]();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fileIterator.<span class=\"title function_\">next</span>()); <span class=\"comment\">// { value: \"笔记.txt\", done: false }</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fileIterator.<span class=\"title function_\">next</span>()); <span class=\"comment\">// { value: \"照片.jpg\", done: false }</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fileIterator.<span class=\"title function_\">next</span>()); <span class=\"comment\">// { value: \"文档.pdf\", done: false }</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fileIterator.<span class=\"title function_\">next</span>()); <span class=\"comment\">// { done: true }</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"1-2-迭代器的三个核心要素\"><a href=\"#1-2-迭代器的三个核心要素\" class=\"headerlink\" title=\"1.2 迭代器的三个核心要素\"></a>1.2 迭代器的三个核心要素</h3><p>要实现迭代器协议，必须满足以下三点：</p>\n<ol>\n<li><strong><code>[Symbol.iterator]</code> 方法</strong>：对象必须有这个特殊方法（用 <code>Symbol.iterator</code> 作为键），调用后返回一个 “迭代器对象”。</li>\n<li><strong><code>next()</code> 方法</strong>：迭代器对象必须有 <code>next()</code> 方法，调用后返回 <code>{ value, done }</code> 结构的对象。<ul>\n<li><code>value</code>：当前遍历到的值（遍历完时可省略）。</li>\n<li><code>done</code>：布尔值，<code>false</code> 表示还有值，<code>true</code> 表示遍历结束。</li>\n</ul>\n</li>\n<li><strong>内部状态</strong>：迭代器需要记录当前遍历位置（比如上面的 <code>currentIndex</code>），确保每次 <code>next()</code> 能拿到下一个值。</li>\n</ol>\n<h3 id=\"1-3-可迭代对象：能被遍历的“合格对象”\"><a href=\"#1-3-可迭代对象：能被遍历的“合格对象”\" class=\"headerlink\" title=\"1.3 可迭代对象：能被遍历的“合格对象”\"></a>1.3 可迭代对象：能被遍历的 “合格对象”</h3><p>只要实现了 <code>[Symbol.iterator]()</code> 方法的对象，它就是<u>可迭代对象</u>。JS 中很多原生对象天生就是可迭代的，比如：</p>\n<ul>\n<li>数组、字符串、<code>Map</code>、<code>Set</code>、<code>TypedArray</code></li>\n<li>DOM 集合：<code>NodeList</code>（比如 <code>document.querySelectorAll</code> 的返回值）</li>\n<li>生成器对象（<code>function*</code> 生成的对象）</li>\n</ul>\n<p>这些可迭代对象能被以下语法 “消费”（即遍历或提取数据）：</p>\n<ul>\n<li><code>for...of</code> 循环</li>\n<li>展开运算符（<code>...</code>）</li>\n<li>解构赋值</li>\n<li><code>Array.from()</code>（把可迭代对象转数组）</li>\n<li><code>Promise.all()</code>/<code>Promise.race()</code>（接收可迭代的 Promise 集合）</li>\n</ul>\n<h2 id=\"二、解构：简化数据提取的“语法糖”\"><a href=\"#二、解构：简化数据提取的“语法糖”\" class=\"headerlink\" title=\"二、解构：简化数据提取的“语法糖”\"></a>二、解构：简化数据提取的 “语法糖”</h2><h3 id=\"2-1-解构的本质：基于迭代器的便捷操作\"><a href=\"#2-1-解构的本质：基于迭代器的便捷操作\" class=\"headerlink\" title=\"2.1 解构的本质：基于迭代器的便捷操作\"></a>2.1 解构的本质：基于迭代器的便捷操作</h3><p>解构赋值（Destructuring）看似是 “直接拆数据”，其实底层依赖迭代器协议。比如对数组解构时，JS 引擎会悄悄做两件事：</p>\n<ol>\n<li>调用数组的 <code>[Symbol.iterator]()</code> 方法，获取迭代器。</li>\n<li>多次调用迭代器的 <code>next()</code> 方法，按顺序提取值，赋值给变量。</li>\n</ol>\n<p>看个例子，理解解构的底层逻辑：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们写的解构代码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [a, b] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引擎实际执行的逻辑（简化版）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> tempIterator = [<span class=\"number\">1</span>, <span class=\"number\">2</span>][<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>](); <span class=\"comment\">// 拿到迭代器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = tempIterator.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>; <span class=\"comment\">// 第一个 next() 的值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = tempIterator.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>; <span class=\"comment\">// 第二个 next() 的值</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这也解释了为什么 “普通对象不能用数组解构”—— 因为普通对象没实现 <code>[Symbol.iterator]()</code> 方法，不是可迭代对象。</p>\n<h3 id=\"2-2-解构的常用能力：告别繁琐的取值\"><a href=\"#2-2-解构的常用能力：告别繁琐的取值\" class=\"headerlink\" title=\"2.2 解构的常用能力：告别繁琐的取值\"></a>2.2 解构的常用能力：告别繁琐的取值</h3><p>解构最核心的价值是 “少写重复代码”，比如不用再写 <code>arr[0]</code>、<code>obj.name</code> 这种重复的取值逻辑。分享几个高频用法：</p>\n<ol>\n<li><p><strong>跳过不需要的值</strong>：用逗号跳过不想取的元素（比如只想要数组的第三个值）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [, , third] = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(third); <span class=\"comment\">// \"c\"</span></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p><strong>收集剩余值</strong>：用 <code>...变量名</code> 收集解构后剩下的所有值（只能放在最后）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(first); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rest); <span class=\"comment\">// [2, 3, 4]</span></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p><strong>设置默认值</strong>：当解构的值是 <code>undefined</code> 时，使用默认值（注意：<code>null</code>、<code>0</code>、<code>\"\"</code> 不会触发默认值）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组解构默认值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [name = <span class=\"string\">'匿名用户'</span>] = [];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name); <span class=\"comment\">// \"匿名用户\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象解构默认值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> { age = <span class=\"number\">18</span> } = { <span class=\"attr\">name</span>: <span class=\"string\">'小明'</span> };</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age); <span class=\"comment\">// 18</span></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p><strong>交换变量</strong>：不用临时变量，一行代码交换两个变量的值。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>,</span><br><span class=\"line\">  y = <span class=\"number\">2</span>;</span><br><span class=\"line\">[x, y] = [y, x]; <span class=\"comment\">// x=2，y=1</span></span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h2 id=\"三、不同数据结构的解构实战\"><a href=\"#三、不同数据结构的解构实战\" class=\"headerlink\" title=\"三、不同数据结构的解构实战\"></a>三、不同数据结构的解构实战</h2><p>不同数据结构的解构方式略有差异，这里整理了日常开发中最常用的 8 种场景，附具体代码示例：</p>\n<h3 id=\"3-1-字符串解构：按字符拆分\"><a href=\"#3-1-字符串解构：按字符拆分\" class=\"headerlink\" title=\"3.1 字符串解构：按字符拆分\"></a>3.1 字符串解构：按字符拆分</h3><p>字符串是可迭代对象，解构时会按单个字符提取：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本字符解构</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [firstChar, secondChar] = <span class=\"string\">'JS'</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstChar); <span class=\"comment\">// \"J\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(secondChar); <span class=\"comment\">// \"S\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 收集剩余字符</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [head, ...tail] = <span class=\"string\">'JavaScript'</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(head); <span class=\"comment\">// \"J\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tail); <span class=\"comment\">// [\"a\", \"v\", \"a\", \"S\", \"c\", \"r\", \"i\", \"p\", \"t\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解构字符串的属性（对象解构）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> { <span class=\"attr\">length</span>: strLen } = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(strLen); <span class=\"comment\">// 5</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-2-数组解构：按位置取值\"><a href=\"#3-2-数组解构：按位置取值\" class=\"headerlink\" title=\"3.2 数组解构：按位置取值\"></a>3.2 数组解构：按位置取值</h3><p>数组解构最常用，变量的位置和数组元素的位置一一对应：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本解构</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [x, y] = [<span class=\"number\">10</span>, <span class=\"number\">20</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x, y); <span class=\"comment\">// 10 20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 嵌套数组解构（对应数组的嵌套结构）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [foo, [[bar], baz]] = [<span class=\"number\">1</span>, [[<span class=\"number\">2</span>], <span class=\"number\">3</span>]];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bar); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(baz); <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 部分解构</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [, , third] = [<span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'baz'</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(third); <span class=\"comment\">// \"baz\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 剩余模式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [head, ...tail] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(head); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tail); <span class=\"comment\">// [2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解构失败，变量的值为 undefined</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [a, b, ...c] = [<span class=\"string\">'a'</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// \"a\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c); <span class=\"comment\">// []</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不完全解构</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [d, [e], f] = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(f); <span class=\"comment\">// 4</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-3-对象解构：按属性名取值\"><a href=\"#3-3-对象解构：按属性名取值\" class=\"headerlink\" title=\"3.3 对象解构：按属性名取值\"></a>3.3 对象解构：按属性名取值</h3><p>对象解构和数组不同 —— 变量名必须和对象的属性名一致，和属性的顺序无关：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = {</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'Alice'</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">30</span>,</span><br><span class=\"line\">  <span class=\"attr\">address</span>: {</span><br><span class=\"line\">    <span class=\"attr\">city</span>: <span class=\"string\">'London'</span>,</span><br><span class=\"line\">    <span class=\"attr\">zip</span>: <span class=\"number\">10001</span>,</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"attr\">hobbies</span>: [<span class=\"string\">'reading'</span>, <span class=\"string\">'hiking'</span>],</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基本解构，变量必须与属性同名，与属性的顺序无关</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = {</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'Alice'</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: <span class=\"number\">28</span>,</span><br><span class=\"line\">  <span class=\"attr\">address</span>: {</span><br><span class=\"line\">    <span class=\"attr\">city</span>: <span class=\"string\">'Beijing'</span>,</span><br><span class=\"line\">    <span class=\"attr\">street</span>: <span class=\"string\">'Main St'</span>,</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基本对象解构</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> { name, age } = user;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name); <span class=\"comment\">// \"Alice\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age); <span class=\"comment\">// 28</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重命名变量（属性名和变量名不同时用）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> { <span class=\"attr\">name</span>: userName } = user;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(userName); <span class=\"comment\">// \"Alice\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 嵌套对象解构（对应对象的嵌套结构）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> {</span><br><span class=\"line\">  <span class=\"attr\">address</span>: { city },</span><br><span class=\"line\">} = user;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(city); <span class=\"comment\">// \"Beijing\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给对象属性设默认值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> { gender = <span class=\"string\">'unknown'</span> } = user;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gender); <span class=\"comment\">// \"unknown\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-4-Map-解构：按键值对拆分\"><a href=\"#3-4-Map-解构：按键值对拆分\" class=\"headerlink\" title=\"3.4 Map 解构：按键值对拆分\"></a>3.4 Map 解构：按键值对拆分</h3><p><code>Map</code> 是 “键值对集合”，解构时会按 <code>[key, value]</code> 的形式提取每一项：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> userMap = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>([</span><br><span class=\"line\">  [<span class=\"string\">'name'</span>, <span class=\"string\">'Bob'</span>],</span><br><span class=\"line\">  [<span class=\"string\">'age'</span>, <span class=\"number\">30</span>],</span><br><span class=\"line\">  [<span class=\"string\">'isAdmin'</span>, <span class=\"literal\">false</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for...of 中解构键值对</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> [key, value] <span class=\"keyword\">of</span> userMap) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">${key}</span>: <span class=\"subst\">${value}</span>`</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 输出：name: Bob、age: 30、isAdmin: false</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解构特定键值对</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [firstEntry, secondEntry] = userMap;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstEntry); <span class=\"comment\">// [\"name\", \"Bob\"]（第一个键值对）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(secondEntry[<span class=\"number\">1</span>]); <span class=\"comment\">// 30（第二个键值对的 value）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提取所有 key/value（结合展开运算符）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> allKeys = [...userMap.<span class=\"title function_\">keys</span>()];</span><br><span class=\"line\"><span class=\"keyword\">const</span> allValues = [...userMap.<span class=\"title function_\">values</span>()];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(allKeys); <span class=\"comment\">// [\"name\", \"age\", \"isAdmin\"]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-5-Set-解构：按元素顺序拆分\"><a href=\"#3-5-Set-解构：按元素顺序拆分\" class=\"headerlink\" title=\"3.5 Set 解构：按元素顺序拆分\"></a>3.5 Set 解构：按元素顺序拆分</h3><p><code>Set</code> 是 “唯一值集合”，解构时按元素插入顺序提取：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tagSet = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"string\">'html'</span>, <span class=\"string\">'css'</span>, <span class=\"string\">'js'</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基本解构</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [firstTag, secondTag] = tagSet;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(firstTag); <span class=\"comment\">// \"html\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(secondTag); <span class=\"comment\">// \"css\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转数组后解构（更灵活）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> tagArray = [...tagSet];</span><br><span class=\"line\"><span class=\"keyword\">const</span> [, , thirdTag] = tagArray;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(thirdTag); <span class=\"comment\">// \"js\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-6-函数参数解构：简化参数处理\"><a href=\"#3-6-函数参数解构：简化参数处理\" class=\"headerlink\" title=\"3.6 函数参数解构：简化参数处理\"></a>3.6 函数参数解构：简化参数处理</h3><p>函数参数如果是对象或数组，用解构能直接提取需要的属性，不用再手动 <code>obj.xxx</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 对象参数解构（常用场景：配置项）</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">renderChart</span>(<span class=\"params\">{</span></span><br><span class=\"line\"><span class=\"params\">  width = <span class=\"number\">400</span>, // 默认宽度</span></span><br><span class=\"line\"><span class=\"params\">  height = <span class=\"number\">300</span>, // 默认高度</span></span><br><span class=\"line\"><span class=\"params\">  type = <span class=\"string\">'line'</span>, // 默认图表类型</span></span><br><span class=\"line\"><span class=\"params\">}</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`绘制 <span class=\"subst\">${type}</span> 图表，尺寸 <span class=\"subst\">${width}</span>x<span class=\"subst\">${height}</span>`</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用时只需传需要修改的配置</span></span><br><span class=\"line\"><span class=\"title function_\">renderChart</span>({ <span class=\"attr\">width</span>: <span class=\"number\">600</span> });</span><br><span class=\"line\"><span class=\"comment\">// 输出：绘制 line 图表，尺寸 600x300</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 嵌套参数解构</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printUser</span>(<span class=\"params\">{ name, address: { city } }</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">${name}</span> 住在 <span class=\"subst\">${city}</span>`</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">printUser</span>({</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">'Charlie'</span>,</span><br><span class=\"line\">  <span class=\"attr\">address</span>: { <span class=\"attr\">city</span>: <span class=\"string\">'Shanghai'</span>, <span class=\"attr\">zip</span>: <span class=\"string\">'200000'</span> },</span><br><span class=\"line\">});</span><br><span class=\"line\"><span class=\"comment\">// 输出：Charlie 住在 Shanghai</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-7-DOM-集合（NodeList）解构\"><a href=\"#3-7-DOM-集合（NodeList）解构\" class=\"headerlink\" title=\"3.7 DOM 集合（NodeList）解构\"></a>3.7 DOM 集合（NodeList）解构</h3><p><code>document.querySelectorAll</code> 返回的 <code>NodeList</code> 是可迭代对象，能直接解构：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 页面中有三个 .item 元素 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item\"</span>&gt;</span>列表<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item\"</span>&gt;</span>详情<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">const</span> items = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">'.item'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"comment\">// 解构前两个元素</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">const</span> [homeItem, listItem] = items;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(homeItem.<span class=\"property\">textContent</span>); <span class=\"comment\">// \"首页\"</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"comment\">// 转数组后解构（支持更多数组方法）</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">const</span> [, , detailItem] = [...items];</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(detailItem.<span class=\"property\">textContent</span>); <span class=\"comment\">// \"详情\"</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-8-生成器对象解构\"><a href=\"#3-8-生成器对象解构\" class=\"headerlink\" title=\"3.8 生成器对象解构\"></a>3.8 生成器对象解构</h3><p>生成器函数（<code>function*</code>）返回的对象是可迭代的，解构时会按 <code>yield</code> 的顺序提取值：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成器函数：产生 1、2、3</span></span><br><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">generateNumbers</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解构生成器对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [num1, num2] = <span class=\"title function_\">generateNumbers</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(num1, num2); <span class=\"comment\">// 1 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提取所有值（结合展开运算符）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> allNums = [...<span class=\"title function_\">generateNumbers</span>()];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(allNums); <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"四、高级解构技巧：解决复杂场景\"><a href=\"#四、高级解构技巧：解决复杂场景\" class=\"headerlink\" title=\"四、高级解构技巧：解决复杂场景\"></a>四、高级解构技巧：解决复杂场景</h2><h3 id=\"4-1-动态属性名解构：按变量名提取属性\"><a href=\"#4-1-动态属性名解构：按变量名提取属性\" class=\"headerlink\" title=\"4.1 动态属性名解构：按变量名提取属性\"></a>4.1 动态属性名解构：按变量名提取属性</h3><p>如果对象的属性名是动态的（比如由变量决定），可以用 <code>[变量名]</code> 来解构：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接口返回的状态信息，属性名是“status_状态码”</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> apiRes = {</span><br><span class=\"line\">  <span class=\"attr\">status_200</span>: <span class=\"string\">'请求成功'</span>,</span><br><span class=\"line\">  <span class=\"attr\">status_404</span>: <span class=\"string\">'资源未找到'</span>,</span><br><span class=\"line\">  <span class=\"attr\">status_500</span>: <span class=\"string\">'服务器错误'</span>,</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态获取状态码对应的信息</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> statusCode = <span class=\"number\">404</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> { [<span class=\"string\">`status_<span class=\"subst\">${statusCode}</span>`</span>]: message } = apiRes;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message); <span class=\"comment\">// \"资源未找到\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-2-混合解构：处理嵌套复杂的数据\"><a href=\"#4-2-混合解构：处理嵌套复杂的数据\" class=\"headerlink\" title=\"4.2 混合解构：处理嵌套复杂的数据\"></a>4.2 混合解构：处理嵌套复杂的数据</h3><p>实际开发中，API 响应常是 “对象嵌套数组” 的结构，用混合解构能一步提取关键数据：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模拟 API 响应数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> apiResponse = {</span><br><span class=\"line\">  <span class=\"attr\">code</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">  <span class=\"attr\">data</span>: {</span><br><span class=\"line\">    <span class=\"attr\">products</span>: [</span><br><span class=\"line\">      { <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">'手机'</span>, <span class=\"attr\">price</span>: <span class=\"number\">5999</span> },</span><br><span class=\"line\">      { <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">'平板'</span>, <span class=\"attr\">price</span>: <span class=\"number\">3999</span> },</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">pagination</span>: { <span class=\"attr\">current</span>: <span class=\"number\">1</span>, <span class=\"attr\">total</span>: <span class=\"number\">10</span> },</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 混合解构：提取 code、第一个商品名、总页数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> {</span><br><span class=\"line\">  code,</span><br><span class=\"line\">  <span class=\"attr\">data</span>: {</span><br><span class=\"line\">    <span class=\"attr\">products</span>: [{ <span class=\"attr\">name</span>: firstProductName }], <span class=\"comment\">// 数组嵌套对象解构</span></span><br><span class=\"line\">    <span class=\"attr\">pagination</span>: { total }, <span class=\"comment\">// 对象嵌套解构</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">} = apiResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`状态码：<span class=\"subst\">${code}</span>，第一个商品：<span class=\"subst\">${firstProductName}</span>，总页数：<span class=\"subst\">${total}</span>`</span>);</span><br><span class=\"line\"><span class=\"comment\">// 输出：状态码：200，第一个商品：手机，总页数：10</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-3-解构-迭代器：处理分页数据\"><a href=\"#4-3-解构-迭代器：处理分页数据\" class=\"headerlink\" title=\"4.3 解构 + 迭代器：处理分页数据\"></a>4.3 解构 + 迭代器：处理分页数据</h3><p>结合生成器（迭代器）和解构，可以优雅地处理分页数据（比如一次获取前三页数据）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分页数据生成器：每次 yield 一页数据</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span>* <span class=\"title function_\">fetchPages</span>(<span class=\"params\">url</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> page = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">`<span class=\"subst\">${url}</span>?page=<span class=\"subst\">${page}</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> { data, hasMore } = <span class=\"keyword\">await</span> res.<span class=\"title function_\">json</span>();</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> data; <span class=\"comment\">// 产出当前页数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasMore) <span class=\"keyword\">break</span>; <span class=\"comment\">// 没有更多页，停止迭代</span></span><br><span class=\"line\">    page++;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一次获取前三页数据</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getFirstThreePages</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> pageGenerator = <span class=\"title function_\">fetchPages</span>(<span class=\"string\">'/api/articles'</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 解构前三次 next() 的结果</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [page1, page2, page3] = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([</span><br><span class=\"line\">    pageGenerator.<span class=\"title function_\">next</span>(),</span><br><span class=\"line\">    pageGenerator.<span class=\"title function_\">next</span>(),</span><br><span class=\"line\">    pageGenerator.<span class=\"title function_\">next</span>(),</span><br><span class=\"line\">  ]).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">results</span>) =&gt;</span> results.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> r.<span class=\"property\">value</span>)); <span class=\"comment\">// 提取 value</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> { page1, page2, page3 };</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"五、避坑指南：解构的常见问题\"><a href=\"#五、避坑指南：解构的常见问题\" class=\"headerlink\" title=\"五、避坑指南：解构的常见问题\"></a>五、避坑指南：解构的常见问题</h2><h3 id=\"5-1-普通对象不能用数组解构\"><a href=\"#5-1-普通对象不能用数组解构\" class=\"headerlink\" title=\"5.1 普通对象不能用数组解构\"></a>5.1 普通对象不能用数组解构</h3><p>普通对象没实现迭代器协议，直接用数组解构会报错：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = { <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> };</span><br><span class=\"line\"><span class=\"keyword\">const</span> [x, y] = obj; <span class=\"comment\">// TypeError: obj is not iterable</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-2-解构声明必须用-let-const-var\"><a href=\"#5-2-解构声明必须用-let-const-var\" class=\"headerlink\" title=\"5.2 解构声明必须用 let/const/var\"></a>5.2 解构声明必须用 <code>let/const/var</code></h3><p>如果直接写 <code>{ name } = obj</code>，会被引擎解析为 “代码块”，导致语法错误：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误写法</span></span><br><span class=\"line\">{ name } = { <span class=\"attr\">name</span>: <span class=\"string\">\"Alice\"</span> }; <span class=\"comment\">// SyntaxError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确写法：加 const/let</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> { name } = { <span class=\"attr\">name</span>: <span class=\"string\">\"Alice\"</span> };</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-3-默认值只在值为-undefined-时生效\"><a href=\"#5-3-默认值只在值为-undefined-时生效\" class=\"headerlink\" title=\"5.3 默认值只在值为 undefined 时生效\"></a>5.3 默认值只在值为 <code>undefined</code> 时生效</h3><p>如果解构的值是 <code>null</code>、<code>0</code>、<code>\"\"</code> 等 “假值”，默认值不会触发：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// value 是 null，不会用默认值 10</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> { value = <span class=\"number\">10</span> } = { <span class=\"attr\">value</span>: <span class=\"literal\">null</span> };</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value); <span class=\"comment\">// null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// value 是 undefined，会用默认值 10</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> { value = <span class=\"number\">10</span> } = { <span class=\"attr\">otherKey</span>: <span class=\"string\">'test'</span> };</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value); <span class=\"comment\">// 10</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-4-嵌套解构时，外层属性必须存在\"><a href=\"#5-4-嵌套解构时，外层属性必须存在\" class=\"headerlink\" title=\"5.4 嵌套解构时，外层属性必须存在\"></a>5.4 嵌套解构时，外层属性必须存在</h3><p>如果嵌套解构的外层属性不存在，会报错：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> user = { <span class=\"attr\">name</span>: <span class=\"string\">'Dave'</span> };</span><br><span class=\"line\"><span class=\"comment\">// 错误：user.address 不存在，无法解构 city</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> {</span><br><span class=\"line\">  <span class=\"attr\">address</span>: { city },</span><br><span class=\"line\">} = user; <span class=\"comment\">// TypeError: Cannot destructure property 'city' of 'user.address' as it is undefined.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确写法：给外层属性设默认值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> { <span class=\"attr\">address</span>: { city } = {} } = user;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(city); <span class=\"comment\">// undefined（不会报错）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"六、实际应用场景：让代码更优雅\"><a href=\"#六、实际应用场景：让代码更优雅\" class=\"headerlink\" title=\"六、实际应用场景：让代码更优雅\"></a>六、实际应用场景：让代码更优雅</h2><h3 id=\"场景-1：简化函数参数\"><a href=\"#场景-1：简化函数参数\" class=\"headerlink\" title=\"场景 1：简化函数参数\"></a>场景 1：简化函数参数</h3><p>之前写函数参数要记顺序，用解构后直接按属性名取，不用关心顺序：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 改造前：参数顺序难记，新增参数要改调用方式</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createUser</span>(<span class=\"params\">id, name, email, role</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改造后：参数清晰，支持默认值，新增参数不影响旧调用</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createUser</span>(<span class=\"params\">{ id, name, email, role = <span class=\"string\">'user'</span> }</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用时只需传必要参数</span></span><br><span class=\"line\"><span class=\"title function_\">createUser</span>({ <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">'Eve'</span>, <span class=\"attr\">email</span>: <span class=\"string\">'eve@test.com'</span> });</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"场景-2：处理-API-响应\"><a href=\"#场景-2：处理-API-响应\" class=\"headerlink\" title=\"场景 2：处理 API 响应\"></a>场景 2：处理 API 响应</h3><p>不用层层 <code>res.data.xxx</code>，一步提取需要的数据：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getArticleDetail</span>(<span class=\"params\">id</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> {</span><br><span class=\"line\">      <span class=\"attr\">data</span>: {</span><br><span class=\"line\">        <span class=\"attr\">article</span>: { title, content },</span><br><span class=\"line\">        <span class=\"attr\">author</span>: { <span class=\"attr\">name</span>: authorName },</span><br><span class=\"line\">      },</span><br><span class=\"line\">    } = <span class=\"keyword\">await</span> axios.<span class=\"title function_\">get</span>(<span class=\"string\">`/api/articles/<span class=\"subst\">${id}</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 直接使用提取的数据</span></span><br><span class=\"line\">    <span class=\"title function_\">renderArticle</span>(title, content, authorName);</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span> ({ message }) {</span><br><span class=\"line\">    <span class=\"comment\">// 解构错误信息</span></span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"string\">`获取文章失败：<span class=\"subst\">${message}</span>`</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"场景-3：组件-props-处理（以-React-为例）\"><a href=\"#场景-3：组件-props-处理（以-React-为例）\" class=\"headerlink\" title=\"场景 3：组件 props 处理（以 React 为例）\"></a>场景 3：组件 props 处理（以 React 为例）</h3><p>组件接收 props 时，用解构直接提取需要的属性，代码更简洁：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件接收 props</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">ProductCard</span> = (<span class=\"params\">{</span></span><br><span class=\"line\"><span class=\"params\">  product: { name, price, image },</span></span><br><span class=\"line\"><span class=\"params\">  theme = <span class=\"string\">'light'</span>, // 默认主题</span></span><br><span class=\"line\"><span class=\"params\">  onAddToCart,</span></span><br><span class=\"line\"><span class=\"params\">}</span>) =&gt; (</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">{</span>`<span class=\"attr\">product-card</span> ${<span class=\"attr\">theme</span>}`}&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">{image}</span> <span class=\"attr\">alt</span>=<span class=\"string\">{name}</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>{name}<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>¥{price}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{onAddToCart}</span>&gt;</span>加入购物车<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用组件时只需传必要数据</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">ProductCard</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">  <span class=\"attr\">product</span>=<span class=\"string\">{{</span> <span class=\"attr\">name:</span> '<span class=\"attr\">耳机</span>', <span class=\"attr\">price:</span> <span class=\"attr\">799</span>, <span class=\"attr\">image:</span> '<span class=\"attr\">headphone.jpg</span>' }}</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">  <span class=\"attr\">onAddToCart</span>=<span class=\"string\">{()</span> =&gt;</span> console.log('加入购物车')}</span></span><br><span class=\"line\"><span class=\"language-xml\">/&gt;</span>;</span><br></pre></td></tr></tbody></table></figure>\n\n<hr>\n<p>迭代器和解构是 JS 中 “提升代码优雅度” 的关键特性 —— 迭代器统一了数据遍历的方式，解构简化了数据提取的逻辑。掌握它们后，不管是处理简单的数组对象，还是复杂的 API 响应、DOM 集合，都能写出更简洁、更易维护的代码～</p>\n",
            "tags": [
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/event/",
            "url": "http://toukoxu.github.io/archives/event/",
            "title": "JS 事件系统完全指南与性能优化",
            "date_published": "2022-02-01T12:46:25.000Z",
            "content_html": "<blockquote>\n<p>在 JavaScript 的世界里，事件就像网页的 “交互信号”—— 用户点击按钮、滚动页面、输入文字，都是通过事件让网页做出反应。今天我们从基础到进阶，把浏览器事件机制拆解开，再聊聊怎么用得更高效，避免常见的性能坑！</p>\n</blockquote>\n<h2 id=\"一、事件系统：网页的“交互逻辑骨架”\"><a href=\"#一、事件系统：网页的“交互逻辑骨架”\" class=\"headerlink\" title=\"一、事件系统：网页的“交互逻辑骨架”\"></a>一、事件系统：网页的 “交互逻辑骨架”</h2><h3 id=\"1-1-事件流三阶段：从顶层到目标，再回到顶层\"><a href=\"#1-1-事件流三阶段：从顶层到目标，再回到顶层\" class=\"headerlink\" title=\"1.1 事件流三阶段：从顶层到目标，再回到顶层\"></a>1.1 事件流三阶段：从顶层到目标，再回到顶层</h3><p>事件触发后，不是直接定位到目标元素，而是会经历 “捕获 → 目标 → 冒泡” 三个阶段，就像水流先向下流到目标，再向上回流：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  graph LR\nA[捕获阶段] --&gt; B[目标阶段] --&gt; C[冒泡阶段]\nstyle A fill:#4CAF50,stroke:#388E3C\nstyle B fill:#2196F3,stroke:#1976D2\nstyle C fill:#FF9800,stroke:#F57C00\n  </pre></div>\n\n<ul>\n<li><strong>捕获阶段 (Capture Phase)</strong>：事件从 <code>window</code> 开始，顺着 DOM 树向下传递，直到目标元素的父级（比如点击按钮时，先经过 <code>body</code>、<code>div</code>，再到按钮的父元素）</li>\n<li><strong>目标阶段 (Target Phase)</strong>：事件终于到达触发的目标元素（比如刚才的按钮）</li>\n<li><strong>冒泡阶段 (Bubble Phase)</strong>：事件从目标元素开始，顺着 DOM 树向上 “回流”，回到 <code>window</code>（按钮 → 父 <code>div</code>→<code>body</code>→<code>window</code>）</li>\n</ul>\n<h3 id=\"1-2-三种事件监听方式：哪种最实用？\"><a href=\"#1-2-三种事件监听方式：哪种最实用？\" class=\"headerlink\" title=\"1.2 三种事件监听方式：哪种最实用？\"></a>1.2 三种事件监听方式：哪种最实用？</h3><p>日常开发中，绑定事件主要有三种方式，各有优劣，我整理成了表格：</p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>示例</th>\n<th>👍 优点</th>\n<th>👎 缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>HTML 属性绑定</strong></td>\n<td><code>&lt;button onclick=\"handleClick()\"&gt;</code></td>\n<td>写起来快，适合简单 demo</td>\n<td>HTML 和 JS 混在一起，代码难维护；无法绑定多个处理函数</td>\n</tr>\n<tr>\n<td><strong>DOM 属性绑定</strong></td>\n<td><code>btn.onclick = handleClick</code></td>\n<td>比 HTML 属性清晰，不用混写</td>\n<td>一个事件只能绑一个函数，后面的会覆盖前面的</td>\n</tr>\n<tr>\n<td><strong><code>addEventListener</code></strong></td>\n<td><code>btn.addEventListener('click', handleClick)</code></td>\n<td>🏆 推荐！支持绑多个函数；能控制事件阶段；可手动移除</td>\n<td>需要手动解绑，否则可能内存泄漏</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>实际开发里，我几乎只用 <code>addEventListener</code>—— 它的灵活性和控制力是另外两种方式比不了的，尤其是复杂项目里，多监听器、阶段控制这些功能很关键。</p>\n</blockquote>\n<h3 id=\"1-3-addEventListener详解：参数怎么用？\"><a href=\"#1-3-addEventListener详解：参数怎么用？\" class=\"headerlink\" title=\"1.3 addEventListener详解：参数怎么用？\"></a>1.3 <code>addEventListener</code>详解：参数怎么用？</h3><h4 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h4><p>它有三种调用形式，核心是控制事件的触发规则：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 基础版：事件类型 + 处理函数</span></span><br><span class=\"line\"><span class=\"title function_\">addEventListener</span>(type, listener);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 旧版阶段控制：加个布尔值控制捕获/冒泡</span></span><br><span class=\"line\"><span class=\"title function_\">addEventListener</span>(type, listener, useCapture);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 新版选项控制：更灵活的配置（推荐）</span></span><br><span class=\"line\"><span class=\"title function_\">addEventListener</span>(type, listener, options);</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"关键参数说明\"><a href=\"#关键参数说明\" class=\"headerlink\" title=\"关键参数说明\"></a>关键参数说明</h4><ul>\n<li><p><strong><code>useCapture</code>（布尔值，旧版）</strong>：<br>控制事件在哪个阶段触发。<code>true</code> 是捕获阶段，<code>false</code>（默认）是冒泡阶段，和新版 <code>options.capture</code> 功能完全一样。</p>\n</li>\n<li><p><strong><code>options</code>（对象，新版）</strong>：<br>能精细控制事件行为，常用选项如下：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>类型</th>\n<th>默认值</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>capture</code></td>\n<td>Boolean</td>\n<td><code>false</code></td>\n<td>决定事件在哪个阶段触发：<code>false</code>（冒泡阶段）、<code>true</code>（捕获阶段）</td>\n</tr>\n<tr>\n<td><code>once</code></td>\n<td>Boolean</td>\n<td><code>false</code></td>\n<td><code>true</code> 时，函数只执行一次，执行完自动解绑（比如 “点击后失效” 的按钮）</td>\n</tr>\n<tr>\n<td><code>passive</code></td>\n<td>Boolean</td>\n<td><code>false</code></td>\n<td><code>true</code> 时，告诉浏览器 “这个函数不会调用 <code>preventDefault()</code>”，能提升滚动、触摸等高频事件的性能</td>\n</tr>\n<tr>\n<td><code>signal</code></td>\n<td>AbortSignal</td>\n<td>-</td>\n<td>配合 <code>AbortController</code> 使用，调用 <code>abort()</code> 就能批量解绑事件</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h2 id=\"二、常用事件类型：按场景分类整理\"><a href=\"#二、常用事件类型：按场景分类整理\" class=\"headerlink\" title=\"二、常用事件类型：按场景分类整理\"></a>二、常用事件类型：按场景分类整理</h2><p>浏览器事件类型非常多，我附上关键属性和用法，不用死记，需要时查就行。</p>\n<h3 id=\"先看事件的继承关系\"><a href=\"#先看事件的继承关系\" class=\"headerlink\" title=\"先看事件的继承关系\"></a>先看事件的继承关系</h3><p>所有事件都基于 <code>Event</code> 这个 “基类”，再衍生出不同场景的事件，比如鼠标事件、键盘事件等，关系如下：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  classDiagram\nclass Event {\n&lt;&lt;interface&gt;&gt;\n+type: string\n+bubbles: boolean\n+cancelable: boolean\n+target: EventTarget\n+currentTarget: EventTarget\n+eventPhase: number\n+timeStamp: DOMHighResTimeStamp\n+isTrusted: boolean\n+defaultPrevented: boolean\n+composed: boolean\n+preventDefault() void\n+stopPropagation() void\n+stopImmediatePropagation() void\n+composedPath() EventTarget[]\n}\n\nEvent &lt;|-- UIEvent\nEvent &lt;|-- AnimationEvent\nEvent &lt;|-- TransitionEvent\nEvent &lt;|-- ClipboardEvent\nEvent &lt;|-- CustomEvent\nEvent &lt;|-- ProgressEvent\nEvent &lt;|-- StorageEvent\nEvent &lt;|-- MessageEvent\nEvent &lt;|-- ToggleEvent\nEvent &lt;|-- SubmitEvent\n\nclass UIEvent {\n+view: WindowProxy\n+detail: number\n+sourceCapabilities: InputDeviceCapabilities\n}\n\nUIEvent &lt;|-- MouseEvent\nUIEvent &lt;|-- KeyboardEvent\nUIEvent &lt;|-- FocusEvent\nUIEvent &lt;|-- TouchEvent\nUIEvent &lt;|-- InputEvent\n\nclass MouseEvent {\n+screenX: number\n+screenY: number\n+clientX: number\n+clientY: number\n+pageX: number\n+pageY: number\n+offsetX: number\n+offsetY: number\n+button: number\n+buttons: number\n+relatedTarget: EventTarget\n+altKey: boolean\n+ctrlKey: boolean\n+shiftKey: boolean\n+metaKey: boolean\n+getModifierState(key: string) boolean\n}\n\nMouseEvent &lt;|-- PointerEvent\nMouseEvent &lt;|-- DragEvent\nMouseEvent &lt;|-- WheelEvent\n\nclass PointerEvent {\n+pointerId: number\n+width: number\n+height: number\n+pressure: number\n+tangentialPressure: number\n+tiltX: number\n+tiltY: number\n+twist: number\n+pointerType: string\n+isPrimary: boolean\n}\n\nclass WheelEvent {\n+deltaX: number\n+deltaY: number\n+deltaZ: number\n+deltaMode: number\n}\n\nclass KeyboardEvent {\n+key: string\n+code: string\n+location: number\n+repeat: boolean\n+isComposing: boolean\n+getModifierState(key: string) boolean\n}\n\nclass FocusEvent {\n+relatedTarget: EventTarget\n}\n\nclass TouchEvent {\n+touches: TouchList\n+targetTouches: TouchList\n+changedTouches: TouchList\n+altKey: boolean\n+ctrlKey: boolean\n+shiftKey: boolean\n+metaKey: boolean\n}\n\nclass AnimationEvent {\n+animationName: string\n+elapsedTime: number\n+pseudoElement: string\n}\n\nclass TransitionEvent {\n+propertyName: string\n+elapsedTime: number\n+pseudoElement: string\n}\n\nclass CustomEvent {\n+detail: any\n+initCustomEvent() void\n}\n\nclass InputEvent {\n+data: string\n+isComposing: boolean\n+inputType: string\n}\n\nclass ClipboardEvent {\n+clipboardData: DataTransfer\n}\n\nclass ProgressEvent {\n+lengthComputable: boolean\n+loaded: number\n+total: number\n}\n\nclass StorageEvent {\n+key: string\n+oldValue: any\n+newValue: any\n+url: string\n+storageArea: Storage\n}\n\nclass MessageEvent {\n+data: any\n+origin: string\n+lastEventId: string\n+source: WindowProxy\n+ports: MessagePort[]\n}\n\nclass ToggleEvent {\n+newState: string\n+oldState: string\n}\n\nclass DragEvent {\n+dataTransfer: DataTransfer\n}\n  </pre></div>\n\n<h3 id=\"1-Event（基础事件）\"><a href=\"#1-Event（基础事件）\" class=\"headerlink\" title=\"1. Event（基础事件）\"></a>1. Event（基础事件）</h3><p>所有事件的 “祖宗”，提供最基础的属性和方法，比如判断事件是否冒泡、阻止默认行为等。</p>\n<h4 id=\"常用属性\"><a href=\"#常用属性\" class=\"headerlink\" title=\"常用属性\"></a>常用属性</h4><ul>\n<li><code>type</code>：事件类型（如 “click”）</li>\n<li><code>target</code>：实际触发事件的元素（比如点击按钮，<code>target</code> 就是按钮）</li>\n<li><code>currentTarget</code>：始终为绑定事件的元素（比如给父容器绑事件，点击子元素时，<code>currentTarget</code> 是父容器）</li>\n<li><code>bubbles</code>：布尔值，判断事件是否会冒泡</li>\n<li><code>cancelable</code>：布尔值，判断事件能否用 <code>preventDefault()</code> 阻止默认行为</li>\n<li><code>eventPhase</code>：事件当前阶段（0 = NONE, 1 = CAPTURING, 2 = AT_TARGET, 3 = BUBBLING）</li>\n<li><code>timeStamp</code>：事件发生的时间戳</li>\n<li><code>isTrusted</code>：事件是否由用户触发（true）还是脚本创建（false）</li>\n<li><code>defaultPrevented</code>：是否已阻止默认行为</li>\n</ul>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><ul>\n<li><code>preventDefault()</code>：阻止默认行为（比如阻止表单提交、链接跳转），可以使用<code>Event.cancelable</code>来检查该事件是否支持取消</li>\n<li><code>stopPropagation()</code>：阻止事件继续冒泡或捕获（比如点击子元素后，父元素的事件不触发）</li>\n<li><code>stopImmediatePropagation()</code>：阻止其他监听器执行</li>\n</ul>\n<h4 id=\"高频基础事件\"><a href=\"#高频基础事件\" class=\"headerlink\" title=\"高频基础事件\"></a>高频基础事件</h4><table>\n<thead>\n<tr>\n<th>事件</th>\n<th>触发时机</th>\n<th>常用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DOMContentLoaded</code></td>\n<td>DOM 解析完成（不用等图片、CSS 加载）</td>\n<td>页面初始化逻辑（比如绑定事件、渲染列表）</td>\n</tr>\n<tr>\n<td><code>load</code></td>\n<td>整个页面（图片、CSS 等）加载完成</td>\n<td>处理图片相关逻辑（比如获取图片尺寸）</td>\n</tr>\n<tr>\n<td><code>scroll</code></td>\n<td>元素或页面滚动时</td>\n<td>滚动加载、导航栏吸顶</td>\n</tr>\n<tr>\n<td><code>resize</code></td>\n<td>窗口或元素大小改变时</td>\n<td>响应式布局调整（比如窗口缩小后重排内容）</td>\n</tr>\n<tr>\n<td><code>submit</code></td>\n<td>表单点击提交按钮或按回车时</td>\n<td>表单验证、阻止默认提交后用 AJAX 提交</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-UIEvent（用户界面事件）\"><a href=\"#2-UIEvent（用户界面事件）\" class=\"headerlink\" title=\"2. UIEvent（用户界面事件）\"></a>2. UIEvent（用户界面事件）</h3><p>继承自<strong> Event</strong>，处理与浏览器 UI 相关的事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>view</code>：关联的窗口对象</li>\n<li><code>detail</code>：事件详情（如点击次数）</li>\n</ul>\n<h4 id=\"2-1-MouseEvent（鼠标事件）\"><a href=\"#2-1-MouseEvent（鼠标事件）\" class=\"headerlink\" title=\"2.1 MouseEvent（鼠标事件）\"></a>2.1 MouseEvent（鼠标事件）</h4><p>继承自<strong> UIEvent</strong>，处理所有鼠标相关事件，比如点击、移动、滚轮操作都属于这类。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>screenX</code>, <code>screenY</code>：屏幕坐标</li>\n<li><code>clientX</code>, <code>clientY</code>：视口坐标</li>\n<li><code>pageX</code>, <code>pageY</code>：文档坐标</li>\n<li><code>screenX</code>, <code>screenY</code>：屏幕坐标</li>\n<li><code>offsetX</code>, <code>offsetY</code>：目标元素坐标</li>\n<li><code>button</code>：按下的鼠标按钮（0 = 左键, 1 = 中键, 2 = 右键）</li>\n<li><code>buttons</code>：按下的多个按钮</li>\n<li><code>relatedTarget</code>：相关元素（如 mouseover 时的来源元素）</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n<th>是否冒泡</th>\n<th>注意点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>click</code></td>\n<td>鼠标按下并释放（通常是左键）</td>\n<td>✅</td>\n<td>双击会触发两次 <code>click</code></td>\n</tr>\n<tr>\n<td><code>dblclick</code></td>\n<td>双击鼠标</td>\n<td>✅</td>\n<td>响应速度比 <code>click</code> 慢，慎用</td>\n</tr>\n<tr>\n<td><code>mousedown</code>/<code>mouseup</code></td>\n<td>鼠标按下 / 释放</td>\n<td>✅</td>\n<td>区分按下和释放的状态（比如拖拽开始 / 结束）</td>\n</tr>\n<tr>\n<td><code>mousemove</code></td>\n<td>鼠标移动</td>\n<td>✅</td>\n<td>触发频率高，需要节流优化</td>\n</tr>\n<tr>\n<td><code>mouseenter</code>/<code>mouseleave</code></td>\n<td>鼠标进入 / 离开元素</td>\n<td>❌</td>\n<td>不冒泡，子元素不会触发（比如鼠标从父元素进子元素，不会触发父元素的 <code>mouseleave</code>）</td>\n</tr>\n<tr>\n<td><code>mouseover</code>/<code>mouseout</code></td>\n<td>鼠标进入 / 离开元素或子元素</td>\n<td>✅</td>\n<td>冒泡，子元素会触发（比如鼠标从父元素进子元素，父元素会触发 <code>mouseout</code>）</td>\n</tr>\n<tr>\n<td><code>contextmenu</code></td>\n<td>右键菜单</td>\n<td>✅</td>\n<td></td>\n</tr>\n</tbody></table>\n<h5 id=\"2-1-1-WheelEvent（滚轮事件）\"><a href=\"#2-1-1-WheelEvent（滚轮事件）\" class=\"headerlink\" title=\"2.1.1 WheelEvent（滚轮事件）\"></a>2.1.1 WheelEvent（滚轮事件）</h5><p>继承自<strong> MouseEvent</strong>，处理滚轮 / 触控板滚动事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>deltaX</code>：水平滚动量（像素）</li>\n<li><code>deltaY</code>：垂直滚动量（像素）</li>\n<li><code>deltaZ</code>：Z 轴滚动量（3D 设备）</li>\n<li><code>deltaMode</code>：滚动单位（0 = 像素, 1 = 行, 2 = 页）</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n<th>注意点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>wheel</code></td>\n<td>滚轮滚动</td>\n<td>控制滚动方向和速度（替代旧的 <code>mousewheel</code> 事件）</td>\n</tr>\n</tbody></table>\n<h5 id=\"2-1-2-DragEvent（拖放事件）\"><a href=\"#2-1-2-DragEvent（拖放事件）\" class=\"headerlink\" title=\"2.1.2 DragEvent（拖放事件）\"></a>2.1.2 DragEvent（拖放事件）</h5><p>继承自<strong> MouseEvent</strong>，处理拖放事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>dataTransfer</code>：在拖放交互期间传输的数据</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>drag</code></td>\n<td>拖动元素（含选择的文本，下同）</td>\n</tr>\n<tr>\n<td><code>dragstart</code>, <code>dragend</code></td>\n<td>开始拖动元素, 拖动操作结束（释放鼠标按钮或按下退出键）</td>\n</tr>\n<tr>\n<td><code>dragover</code></td>\n<td>元素拖动到有效放置目标上（每几百毫秒）</td>\n</tr>\n<tr>\n<td><code>dragenter</code>, <code>dragleave</code></td>\n<td>拖动的元素进入放置目标, 拖动的元素离开放置目标</td>\n</tr>\n<tr>\n<td><code>drop</code></td>\n<td>在放置目标上放置元素</td>\n</tr>\n</tbody></table>\n<h5 id=\"2-1-3-PointerEvent（指针事件）\"><a href=\"#2-1-3-PointerEvent（指针事件）\" class=\"headerlink\" title=\"2.1.3 PointerEvent（指针事件）\"></a>2.1.3 PointerEvent（指针事件）</h5><p>继承自<strong> MouseEvent</strong>，统一鼠标、触摸、触控笔事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>pointerId</code>：唯一指针 ID</li>\n<li><code>width</code>, <code>height</code>：接触区域尺寸</li>\n<li><code>pressure</code>：压力值（0-1）</li>\n<li><code>pointerType</code>：设备类型（” mouse”, “pen”, “touch”）</li>\n<li><code>isPrimary</code>：是否为主指针</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pointerdown</code>, <code>pointerup</code></td>\n<td>指针按下, 指针释放</td>\n</tr>\n<tr>\n<td><code>pointermove</code></td>\n<td>指针移动</td>\n</tr>\n<tr>\n<td><code>pointerover</code>, <code>pointerout</code></td>\n<td>指针进入元素, 指针离开元素</td>\n</tr>\n<tr>\n<td><code>pointerenter</code>, <code>pointerleave</code></td>\n<td>指针进入元素, 指针离开元素</td>\n</tr>\n<tr>\n<td><code>pointercancel</code></td>\n<td>指针中断</td>\n</tr>\n<tr>\n<td><code>gotpointercapture</code>, <code>lostpointercapture</code></td>\n<td>元素启用捕获后触发, 捕获被释放后触发</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-2-KeyboardEvent（键盘事件）\"><a href=\"#2-2-KeyboardEvent（键盘事件）\" class=\"headerlink\" title=\"2.2 KeyboardEvent（键盘事件）\"></a>2.2 KeyboardEvent（键盘事件）</h4><p>继承自<strong> UIEvent</strong>，处理键盘输入事件，比如快捷键、输入验证等。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>key</code>：按键的实际内容（比如按 “A” 是 <code>\"a\"</code> 或 <code>\"A\"</code>，按回车是 <code>\"Enter\"</code>）</li>\n<li><code>code</code>：按键的物理位置（比如按 “A” 是 <code>\"KeyA\"</code>，不管是否按 Shift，位置不变）</li>\n<li><code>location</code>：按键位置（0 = 标准, 1 = 左侧, 2 = 右侧, 3 = 数字键盘）</li>\n<li><code>repeat</code>：布尔值，判断是否是长按重复触发</li>\n<li><code>isComposing</code>：布尔值，判断是否在输入法输入中（比如中文输入时避免误触发）</li>\n<li>修饰键状态：<code>altKey</code>, <code>ctrlKey</code>, <code>shiftKey</code>, <code>metaKey</code></li>\n</ul>\n<p>方法：</p>\n<ul>\n<li><code>getModifierState(key)</code>：检查特定修饰键状态</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>触发时机</th>\n<th>是否冒泡</th>\n<th>常用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>keydown</code></td>\n<td>按下任意键（包括功能键）</td>\n<td>✅</td>\n<td>监听快捷键（比如 Ctrl + S 保存）</td>\n</tr>\n<tr>\n<td><code>keyup</code></td>\n<td>释放按键时</td>\n<td>✅</td>\n<td>取消快捷键状态（比如松开 Ctrl 后停止批量操作）</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意：<code>keypress</code> 事件已过时，尽量用 <code>keydown</code> 替代，它支持所有按键类型。</p>\n</blockquote>\n<h4 id=\"2-3-FocusEvent（焦点事件）\"><a href=\"#2-3-FocusEvent（焦点事件）\" class=\"headerlink\" title=\"2.3 FocusEvent（焦点事件）\"></a>2.3 FocusEvent（焦点事件）</h4><p>继承自<strong> UIEvent</strong>，处理元素焦点变化，比如表单输入时的交互。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>relatedTarget</code>：相关元素（如失去焦点时获得焦点的元素）</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n<th>是否冒泡</th>\n<th>注意点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>focus</code>/<code>blur</code></td>\n<td>元素获得 / 失去焦点</td>\n<td>❌</td>\n<td>不冒泡，无法用事件委托</td>\n</tr>\n<tr>\n<td><code>focusin</code>/<code>focusout</code></td>\n<td>元素获得 / 失去焦点</td>\n<td>✅</td>\n<td>冒泡，推荐用它做事件委托（比如表单所有输入框的焦点处理）</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-4-TouchEvent（触摸事件）\"><a href=\"#2-4-TouchEvent（触摸事件）\" class=\"headerlink\" title=\"2.4 TouchEvent（触摸事件）\"></a>2.4 TouchEvent（触摸事件）</h4><p>继承自<strong> UIEvent</strong>，处理触摸屏设备交互。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>touches</code>：当前所有触摸点</li>\n<li><code>targetTouches</code>：当前元素上的触摸点</li>\n<li><code>changedTouches</code>：本次事件相关的触摸点</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>touchstart</code></td>\n<td>触摸开始</td>\n</tr>\n<tr>\n<td><code>touchmove</code></td>\n<td>触摸移动</td>\n</tr>\n<tr>\n<td><code>touchend</code></td>\n<td>触摸结束</td>\n</tr>\n<tr>\n<td><code>touchcancel</code></td>\n<td>触摸中断</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-5-InputEvent（输入事件）\"><a href=\"#2-5-InputEvent（输入事件）\" class=\"headerlink\" title=\"2.5 InputEvent（输入事件）\"></a>2.5 InputEvent（输入事件）</h4><p>继承自<strong> UIEvent</strong>，处理用户输入事件，比如实时监听输入框、文本域的内容变化，比 <code>change</code> 事件更灵敏（<code>change</code> 需要失去焦点才触发）。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>data</code>：插入的字符</li>\n<li><code>dataTransfer</code>：拖放或插入 / 删除的数据</li>\n<li><code>inputType</code>：更改的类型（<code>inserting</code>或<code>deleting</code>）</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n<th>常用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>input</code></td>\n<td>用户输入</td>\n<td>实时搜索提示、输入字数统计</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-AnimationEvent（动画事件）\"><a href=\"#3-AnimationEvent（动画事件）\" class=\"headerlink\" title=\"3. AnimationEvent（动画事件）\"></a>3. AnimationEvent（动画事件）</h3><p>继承自<strong> Event</strong>，处理 CSS 动画相关事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>animationName</code>：动画名称</li>\n<li><code>elapsedTime</code>：动画已运行时间（秒）</li>\n<li><code>pseudoElement</code>：关联的伪元素（如 “::before”）</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>animationstart</code>, <code>animationend</code></td>\n<td>动画开始, 动画结束</td>\n</tr>\n<tr>\n<td><code>animationiteration</code></td>\n<td>动画重复播放</td>\n</tr>\n<tr>\n<td><code>animationcancel</code></td>\n<td>动画被取消</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-TransitionEvent（过渡事件）\"><a href=\"#4-TransitionEvent（过渡事件）\" class=\"headerlink\" title=\"4. TransitionEvent（过渡事件）\"></a>4. TransitionEvent（过渡事件）</h3><p>继承自<strong> Event</strong>，处理 CSS 过渡效果相关事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>propertyName</code>：发生过渡的 CSS 属性</li>\n<li><code>elapsedTime</code>：过渡已运行时间（秒）</li>\n<li><code>pseudoElement</code>：关联的伪元素</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>transitionrun</code></td>\n<td>过渡创建时</td>\n</tr>\n<tr>\n<td><code>transitionstart</code></td>\n<td>过渡实际开始时</td>\n</tr>\n<tr>\n<td><code>transitionend</code></td>\n<td>过渡完成时</td>\n</tr>\n<tr>\n<td><code>transitioncancel</code></td>\n<td>过渡被取消时</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-ClipboardEvent（剪贴板事件）\"><a href=\"#5-ClipboardEvent（剪贴板事件）\" class=\"headerlink\" title=\"5. ClipboardEvent（剪贴板事件）\"></a>5. ClipboardEvent（剪贴板事件）</h3><p>继承自<strong> Event</strong>，用于处理剪切板相关信息的事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>clipboardData</code>：受剪贴板操作影响的数据</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>copy</code></td>\n<td>复制元素的内容</td>\n</tr>\n<tr>\n<td><code>cut</code></td>\n<td>剪切元素的内容</td>\n</tr>\n<tr>\n<td><code>paste</code></td>\n<td>将内容粘贴到元素中</td>\n</tr>\n</tbody></table>\n<h3 id=\"6-CustomEvent（自定义事件）\"><a href=\"#6-CustomEvent（自定义事件）\" class=\"headerlink\" title=\"6. CustomEvent（自定义事件）\"></a>6. CustomEvent（自定义事件）</h3><p>继承自<strong> Event</strong>，用于创建自定义事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>detail</code>：自定义数据</li>\n</ul>\n<p>方法：</p>\n<ul>\n<li><code>initCustomEvent()</code>：初始化自定义事件</li>\n</ul>\n<h4 id=\"用法示例\"><a href=\"#用法示例\" class=\"headerlink\" title=\"用法示例\"></a>用法示例</h4><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建自定义事件：事件名 + 配置（可传自定义数据）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dataLoadedEvent = <span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">'data-loaded'</span>, {</span><br><span class=\"line\">  <span class=\"attr\">detail</span>: { <span class=\"attr\">list</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>] }, <span class=\"comment\">// 自定义数据，通过 event.detail 访问</span></span><br><span class=\"line\">  <span class=\"attr\">bubbles</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 是否冒泡</span></span><br><span class=\"line\">  <span class=\"attr\">cancelable</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 是否可阻止默认行为</span></span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 绑定事件监听</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'data-loaded'</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'收到数据：'</span>, event.<span class=\"property\">detail</span>.<span class=\"property\">list</span>); <span class=\"comment\">// 输出 [1,2,3]</span></span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 触发事件</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">dispatchEvent</span>(dataLoadedEvent);</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"三、事件性能优化：避免卡顿、减少浪费\"><a href=\"#三、事件性能优化：避免卡顿、减少浪费\" class=\"headerlink\" title=\"三、事件性能优化：避免卡顿、减少浪费\"></a>三、事件性能优化：避免卡顿、减少浪费</h2><p>事件处理很容易出性能问题，比如滚动、拖拽这类高频事件，处理不好会让页面卡顿。分享几个我实战中验证过的优化技巧：</p>\n<h3 id=\"3-1-高频事件：用防抖（debounce）和节流（throttle）控频率\"><a href=\"#3-1-高频事件：用防抖（debounce）和节流（throttle）控频率\" class=\"headerlink\" title=\"3.1 高频事件：用防抖（debounce）和节流（throttle）控频率\"></a>3.1 高频事件：用防抖（debounce）和节流（throttle）控频率</h3><p>像 <code>scroll</code>、<code>mousemove</code>、<code>resize</code> 这类事件，触发频率非常高（比如滚动时每秒触发几十次），直接执行处理函数会占用大量主线程，导致页面卡顿。这时候需要用 “防抖” 或 “节流” 控制执行次数。</p>\n<h4 id=\"防抖（debounce）：连续触发只执行最后一次\"><a href=\"#防抖（debounce）：连续触发只执行最后一次\" class=\"headerlink\" title=\"防抖（debounce）：连续触发只执行最后一次\"></a>防抖（debounce）：连续触发只执行最后一次</h4><p>比如窗口 resize 时，用户拖动窗口的过程中不执行，等用户停手后再执行一次，避免频繁计算。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 防抖：最后的胜利者（连续触发只执行最后一次）</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span>(<span class=\"params\">fn, delay</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer; <span class=\"comment\">// 用闭包保存定时器</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) {</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timer); <span class=\"comment\">// 每次触发都清空之前的定时器</span></span><br><span class=\"line\">    <span class=\"comment\">// 重新计时，等 delay 毫秒后执行</span></span><br><span class=\"line\">    timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args), delay);</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法：窗口 resize 时，等 200ms 稳定后再执行</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">'resize'</span>,</span><br><span class=\"line\">  <span class=\"title function_\">debounce</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'窗口大小稳定了，执行调整逻辑'</span>);</span><br><span class=\"line\">  }, <span class=\"number\">200</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"节流（throttle）：固定间隔执行一次\"><a href=\"#节流（throttle）：固定间隔执行一次\" class=\"headerlink\" title=\"节流（throttle）：固定间隔执行一次\"></a>节流（throttle）：固定间隔执行一次</h4><p>比如滚动加载时，不管滚动多快，每隔 100ms 只执行一次，避免请求发送太频繁。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">throttle</span>(<span class=\"params\">fn, interval</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> lastTime = <span class=\"number\">0</span>; <span class=\"comment\">// 上次执行时间</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> now = <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 距离上次执行超过 interval 才执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (now - lastTime &gt;= interval) {</span><br><span class=\"line\">      fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args);</span><br><span class=\"line\">      lastTime = now; <span class=\"comment\">// 更新上次执行时间</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 用法：滚动时每隔 100ms 执行一次</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">'scroll'</span>,</span><br><span class=\"line\">  <span class=\"title function_\">throttle</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'滚动中，按固定间隔执行'</span>);</span><br><span class=\"line\">  }, <span class=\"number\">100</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-2-多元素事件：用事件委托减少监听器\"><a href=\"#3-2-多元素事件：用事件委托减少监听器\" class=\"headerlink\" title=\"3.2 多元素事件：用事件委托减少监听器\"></a>3.2 多元素事件：用事件委托减少监听器</h3><p>如果有很多相同元素需要绑定事件（比如列表里的删除按钮），一个个绑定会创建大量监听器，浪费内存。这时候用 “事件委托”，把监听器绑在父元素上，通过 <code>event.target</code> 判断是否点击目标元素。</p>\n<h4 id=\"反面示例：逐个绑定（低效）\"><a href=\"#反面示例：逐个绑定（低效）\" class=\"headerlink\" title=\"反面示例：逐个绑定（低效）\"></a>反面示例：逐个绑定（低效）</h4><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给每个 .remove-btn 绑事件，元素多的时候很卡</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">'.remove-btn'</span>).<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">btn</span>) =&gt;</span> {</span><br><span class=\"line\">  btn.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    btn.<span class=\"property\">parentElement</span>.<span class=\"title function_\">remove</span>();</span><br><span class=\"line\">  });</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"正面示例：事件委托（高效）\"><a href=\"#正面示例：事件委托（高效）\" class=\"headerlink\" title=\"正面示例：事件委托（高效）\"></a>正面示例：事件委托（高效）</h4><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 只给父容器绑一个事件，不管有多少子元素都能处理</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'list-container'</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"comment\">// 判断点击的是不是 .remove-btn</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.<span class=\"property\">target</span>.<span class=\"title function_\">matches</span>(<span class=\"string\">'.remove-btn'</span>)) {</span><br><span class=\"line\">    event.<span class=\"property\">target</span>.<span class=\"property\">parentElement</span>.<span class=\"title function_\">remove</span>();</span><br><span class=\"line\">  }</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"额外优势：支持动态元素\"><a href=\"#额外优势：支持动态元素\" class=\"headerlink\" title=\"额外优势：支持动态元素\"></a>额外优势：支持动态元素</h4><p>如果列表是动态生成的（比如 AJAX 加载后新增的项），逐个绑定的事件会失效，但事件委托能自动处理 —— 因为监听器在父容器上，新元素只要符合选择器，点击就能触发。</p>\n<div class=\"note success flat\"><p><strong>性能秘诀：</strong> 对<mark>动态内容</mark>使用<mark>事件委托</mark>是高性能 Web 应用的关键！</p></div>\n\n<h3 id=\"3-3-一次性事件：用-once-true-自动解绑\"><a href=\"#3-3-一次性事件：用-once-true-自动解绑\" class=\"headerlink\" title=\"3.3 一次性事件：用 once: true 自动解绑\"></a>3.3 一次性事件：用 <code>once: true</code> 自动解绑</h3><p>有些事件只需要执行一次（比如 “点击后弹出提示，之后再点无效”），不用手动解绑，加个 <code>once: true</code> 选项，执行完会自动移除监听器。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以使用匿名函数，自动在调用后删除，再点不会触发</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'.tips-btn'</span>).<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">'click'</span>,</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"string\">'这是只弹一次的提示'</span>);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  { <span class=\"attr\">once</span>: <span class=\"literal\">true</span> }</span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-4-滚动-触摸事件：用-passive-true-提升流畅度\"><a href=\"#3-4-滚动-触摸事件：用-passive-true-提升流畅度\" class=\"headerlink\" title=\"3.4 滚动/触摸事件：用 passive: true 提升流畅度\"></a>3.4 滚动 / 触摸事件：用 <code>passive: true</code> 提升流畅度</h3><p>浏览器在处理 <code>scroll</code>、<code>touchmove</code> 这类事件时，会先检查函数是否调用 <code>preventDefault()</code>，如果有，会阻塞滚动，导致卡顿。如果你的函数不会阻止默认行为，加 <code>passive: true</code> 告诉浏览器 “不用等检查了，直接执行”，能显著提升滚动流畅度。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 滚动事件加 passive: true，提升流畅度</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">'scroll'</span>,</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'滚动中，不阻止默认行为'</span>);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  { <span class=\"attr\">passive</span>: <span class=\"literal\">true</span> }</span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote>\n<p>注意：如果加了 <code>passive: true</code>，再调用 <code>preventDefault()</code> 会报错，因为浏览器已经认定你不会阻止默认行为了。</p>\n</blockquote>\n<h3 id=\"3-5-事件顺序控制：用-capture-true-精确控制事件触发顺序（不是常规性能优化的手段）\"><a href=\"#3-5-事件顺序控制：用-capture-true-精确控制事件触发顺序（不是常规性能优化的手段）\" class=\"headerlink\" title=\"3.5 事件顺序控制：用 capture: true 精确控制事件触发顺序（不是常规性能优化的手段）\"></a>3.5 事件顺序控制：用 <code>capture: true</code> 精确控制事件触发顺序（不是常规性能优化的手段）</h3><p>在某些特定场景下，捕获阶段可能更早地处理事件，从而能够阻止事件进一步传播。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">'click'</span>,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.<span class=\"property\">target</span>.<span class=\"title function_\">matches</span>(<span class=\"string\">'.should-block'</span>)) {</span><br><span class=\"line\">      e.<span class=\"title function_\">stopPropagation</span>(); <span class=\"comment\">// 阻止所有后续监听器</span></span><br><span class=\"line\">      e.<span class=\"title function_\">preventDefault</span>();</span><br><span class=\"line\">    }</span><br><span class=\"line\">  },</span><br><span class=\"line\">  { <span class=\"attr\">capture</span>: <span class=\"literal\">true</span> } <span class=\"comment\">// 在捕获阶段早期检查</span></span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-6-不再需要的事件：用-removeEventListener-及时解绑避免内存泄漏\"><a href=\"#3-6-不再需要的事件：用-removeEventListener-及时解绑避免内存泄漏\" class=\"headerlink\" title=\"3.6 不再需要的事件：用 removeEventListener 及时解绑避免内存泄漏\"></a>3.6 不再需要的事件：用 <code>removeEventListener</code> 及时解绑避免内存泄漏</h3><p>如果元素被删除（比如单页应用切换组件），但事件监听器没解绑，浏览器会一直持有这个函数和元素的引用，导致内存泄漏。一定要在合适的时机解绑。</p>\n<h4 id=\"正确示例：组件销毁时解绑\"><a href=\"#正确示例：组件销毁时解绑\" class=\"headerlink\" title=\"正确示例：组件销毁时解绑\"></a>正确示例：组件销毁时解绑</h4><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ListComponent</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 绑定this，避免函数内this指向错误</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">handleClick</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">handleClick</span>.<span class=\"title function_\">bind</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">container</span> = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'list-container'</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">container</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">handleClick</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">handleClick</span>(<span class=\"params\">event</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 处理点击逻辑</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 组件销毁时调用，解绑事件</span></span><br><span class=\"line\">  <span class=\"title function_\">destroy</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">container</span>.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">handleClick</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 切换组件时，销毁旧组件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> oldList = <span class=\"keyword\">new</span> <span class=\"title class_\">ListComponent</span>();</span><br><span class=\"line\">oldList.<span class=\"title function_\">destroy</span>(); <span class=\"comment\">// 解绑事件，避免内存泄漏</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><ol>\n<li><p>匿名函数无法移除，要使用具名函数</p>\n</li>\n<li><p>解绑时要和绑定的函数、参数完全一致<br>比如绑定的时候用了 <code>capture: true</code>，解绑时也要加，否则解不掉：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 绑定：加了 capture: true</span></span><br><span class=\"line\">element.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, handleClick, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解绑：必须也加 capture: true，否则无效</span></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">'click'</span>, handleClick, <span class=\"literal\">true</span>);</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h3 id=\"3-7-事件选择原则\"><a href=\"#3-7-事件选择原则\" class=\"headerlink\" title=\"3.7 事件选择原则\"></a>3.7 事件选择原则</h3><ul>\n<li><strong>优先使用不会冒泡的事件</strong>：如 <code>mouseenter/mouseleave</code> 替代 <code>mouseover/mouseout</code><blockquote>\n<p>这样可以减少事件处理函数被意外触发的可能性，同时也能减少事件传播带来的性能开销（尽管在现代浏览器中这种开销通常很小）。但要注意，它们不能用于事件委托（因为不冒泡），所以使用场景是直接绑定到目标元素。</p>\n</blockquote>\n</li>\n<li><strong>移动端优先指针事件</strong>：<code>pointerdown</code> 替代 <code>mousedown/touchstart</code><blockquote>\n<p>使用<code>pointerdown</code>等事件可以同时支持多种输入方式，避免为鼠标和触摸分别写两套事件逻辑。这有助于代码维护和减少重复。</p>\n</blockquote>\n</li>\n<li><strong>焦点事件使用冒泡版本</strong>：<code>focusin/focusout</code> 替代 <code>focus/blur</code><blockquote>\n<p>因为<code>focus</code>和<code>blur</code>事件不冒泡，所以当我们需要在祖先元素上监听焦点变化（例如做表单验证）时，使用冒泡版本的<code>focusin</code>和<code>focusout</code>可以方便地实现事件委托（仅需将事件绑定在表单上），而不必在每个可聚焦元素上单独绑定事件。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"四、实战问题：常见坑与解决方案\"><a href=\"#四、实战问题：常见坑与解决方案\" class=\"headerlink\" title=\"四、实战问题：常见坑与解决方案\"></a>四、实战问题：常见坑与解决方案</h2><h3 id=\"4-1-滚动事件触发太频繁，页面卡顿\"><a href=\"#4-1-滚动事件触发太频繁，页面卡顿\" class=\"headerlink\" title=\"4.1 滚动事件触发太频繁，页面卡顿\"></a>4.1 滚动事件触发太频繁，页面卡顿</h3><p><strong>问题</strong>：<code>scroll</code> 事件每秒触发几十次，处理函数里有 DOM 操作（比如修改样式、计算位置），导致主线程忙不过来，页面卡。<br><strong>解决方案</strong>：</p>\n<ol>\n<li>用节流控制执行频率（比如每隔 100ms 执行一次）；</li>\n<li>复杂计算用 <code>requestAnimationFrame</code> 包裹，让浏览器在重绘时执行，避免掉帧；</li>\n<li>能用 <code>IntersectionObserver</code> 替代的场景，尽量不用滚动事件（比如 “元素进入视口时加载”）。</li>\n</ol>\n<p>优化后的滚动事件处理：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> throttledScroll = <span class=\"title function_\">throttle</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  <span class=\"comment\">// 用 requestAnimationFrame 确保在重绘时执行</span></span><br><span class=\"line\">  <span class=\"title function_\">requestAnimationFrame</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 处理DOM操作</span></span><br><span class=\"line\">    <span class=\"title function_\">updateNavPosition</span>();</span><br><span class=\"line\">  });</span><br><span class=\"line\">}, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'scroll'</span>, throttledScroll, { <span class=\"attr\">passive</span>: <span class=\"literal\">true</span> });</span><br></pre></td></tr></tbody></table></figure>\n\n<p>不使用滚动事件，而是使用<code>IntersectionObserver</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> observer = <span class=\"keyword\">new</span> <span class=\"title class_\">IntersectionObserver</span>(<span class=\"function\">(<span class=\"params\">entries</span>) =&gt;</span> {</span><br><span class=\"line\">  entries.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">entry</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entry.<span class=\"property\">isIntersecting</span>) {</span><br><span class=\"line\">      <span class=\"comment\">// 元素进入视口</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  });</span><br><span class=\"line\">});</span><br><span class=\"line\">observer.<span class=\"title function_\">observe</span>(element);</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-2-移动端点击有-300ms-延迟\"><a href=\"#4-2-移动端点击有-300ms-延迟\" class=\"headerlink\" title=\"4.2 移动端点击有 300ms 延迟\"></a>4.2 移动端点击有 300ms 延迟</h3><p><strong>问题</strong>：早期移动端浏览器为了判断用户是否双击缩放，会在点击后延迟 300ms 再触发 <code>click</code> 事件，导致按钮点击反应慢。</p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li>加 viewport meta 标签，禁用缩放（推荐，简单有效）；<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0, user-scalable=no\"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>\n<li>用 <code>touchstart</code>/<code>touchend</code> 替代 <code>click</code>（需要处理触摸穿透问题）；</li>\n<li>旧项目可用 FastClick 库（现在大部分现代浏览器已优化，但兼容旧设备时可能需要）。<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">if</span> (<span class=\"string\">'addEventListener'</span> <span class=\"keyword\">in</span> <span class=\"variable language_\">document</span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"string\">'DOMContentLoaded'</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"function\">() =&gt;</span> {</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"title class_\">FastClick</span>.<span class=\"title function_\">attach</span>(<span class=\"variable language_\">document</span>.<span class=\"property\">body</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">      },</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"literal\">false</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    );</span></span><br><span class=\"line\"><span class=\"language-javascript\">  }</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h3 id=\"4-3-事件冒泡导致父元素事件误触发\"><a href=\"#4-3-事件冒泡导致父元素事件误触发\" class=\"headerlink\" title=\"4.3 事件冒泡导致父元素事件误触发\"></a>4.3 事件冒泡导致父元素事件误触发</h3><p><strong>问题</strong>：点击子元素时，父元素的同类型事件也会触发（比如子按钮和父容器都绑了 <code>click</code> 事件）。</p>\n<p><strong>解决方案</strong>：在子元素的事件处理函数里调用 <code>stopPropagation()</code>，阻止事件继续冒泡。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子元素事件：阻止冒泡，父元素事件不触发</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'.child-btn'</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  event.<span class=\"title function_\">stopPropagation</span>(); <span class=\"comment\">// 阻止事件冒泡到父元素</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'子元素被点击'</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父元素事件：子元素点击时不会触发</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'.parent-container'</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'父元素被点击'</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-4-单页应用切换组件，事件监听器没解绑\"><a href=\"#4-4-单页应用切换组件，事件监听器没解绑\" class=\"headerlink\" title=\"4.4 单页应用切换组件，事件监听器没解绑\"></a>4.4 单页应用切换组件，事件监听器没解绑</h3><p><strong>问题</strong>：单页应用（SPA）切换组件时，旧组件的事件监听器没解绑，导致内存泄漏，甚至出现 “幽灵点击”（切换后旧组件的事件还在触发）。</p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li><p>组件销毁时手动解绑事件（如前面 3.6 的示例）；</p>\n</li>\n<li><p>用 <code>AbortController</code> 批量解绑（现代浏览器推荐）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案2：用 AbortController 批量解绑</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> controller = <span class=\"keyword\">new</span> <span class=\"title class_\">AbortController</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> signal = controller.<span class=\"property\">signal</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定多个事件，都用同一个 signal</span></span><br><span class=\"line\">element1.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, handleClick1, { signal });</span><br><span class=\"line\">element2.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'scroll'</span>, handleScroll2, { signal });</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组件销毁时，调用 abort() 批量解绑所有事件</span></span><br><span class=\"line\">controller.<span class=\"title function_\">abort</span>();</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h2 id=\"五、现代事件处理技巧：更高效的玩法\"><a href=\"#五、现代事件处理技巧：更高效的玩法\" class=\"headerlink\" title=\"五、现代事件处理技巧：更高效的玩法\"></a>五、现代事件处理技巧：更高效的玩法</h2><h3 id=\"5-1-事件总线（Event-Bus）：非关联组件通信\"><a href=\"#5-1-事件总线（Event-Bus）：非关联组件通信\" class=\"headerlink\" title=\"5.1 事件总线（Event Bus）：非关联组件通信\"></a>5.1 事件总线（Event Bus）：非关联组件通信</h3><p>如果两个组件没有直接关系（比如兄弟组件、跨层级组件），可以用 “事件总线” 传递消息，不用一层层传 props 或用全局状态。</p>\n<h4 id=\"简单实现事件总线\"><a href=\"#简单实现事件总线\" class=\"headerlink\" title=\"简单实现事件总线\"></a>简单实现事件总线</h4><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">EventBus</span> = {</span><br><span class=\"line\">  <span class=\"comment\">// 存储事件：key是事件名，value是回调函数数组</span></span><br><span class=\"line\">  <span class=\"attr\">events</span>: {},</span><br><span class=\"line\">  <span class=\"comment\">// 触发事件：传事件名和数据</span></span><br><span class=\"line\">  <span class=\"title function_\">emit</span>(<span class=\"params\">eventName, data</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName]) {</span><br><span class=\"line\">      <span class=\"comment\">// 执行所有绑定的回调</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName].<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">cb</span>) =&gt;</span> <span class=\"title function_\">cb</span>(data));</span><br><span class=\"line\">    }</span><br><span class=\"line\">  },</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 绑定事件：传事件名和回调</span></span><br><span class=\"line\">  <span class=\"title function_\">on</span>(<span class=\"params\">eventName, callback</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName]) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName] = [];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName].<span class=\"title function_\">push</span>(callback);</span><br><span class=\"line\">  },</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 解绑事件（可选）</span></span><br><span class=\"line\">  <span class=\"title function_\">off</span>(<span class=\"params\">eventName, callback</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName]) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName] = <span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName].<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">cb</span>) =&gt;</span> cb !== callback);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组件A：触发事件</span></span><br><span class=\"line\"><span class=\"title class_\">EventBus</span>.<span class=\"title function_\">emit</span>(<span class=\"string\">'user-login'</span>, { <span class=\"attr\">username</span>: <span class=\"string\">'test'</span> });</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组件B：监听事件</span></span><br><span class=\"line\"><span class=\"title class_\">EventBus</span>.<span class=\"title function_\">on</span>(<span class=\"string\">'user-login'</span>, <span class=\"function\">(<span class=\"params\">userInfo</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`用户<span class=\"subst\">${userInfo.username}</span>登录了。`</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-2-AbortController：现代事件管理\"><a href=\"#5-2-AbortController：现代事件管理\" class=\"headerlink\" title=\"5.2 AbortController：现代事件管理\"></a>5.2 AbortController：现代事件管理</h3><p>前面提到过 <code>AbortController</code> 能批量解绑事件，它还能配合 fetch、定时器等使用，是现代浏览器推荐的 “资源管理” 方案。</p>\n<h4 id=\"用-AbortController-取消-fetch-请求\"><a href=\"#用-AbortController-取消-fetch-请求\" class=\"headerlink\" title=\"用 AbortController 取消 fetch 请求\"></a>用 AbortController 取消 fetch 请求</h4><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> controller = <span class=\"keyword\">new</span> <span class=\"title class_\">AbortController</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> signal = controller.<span class=\"property\">signal</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发起fetch请求，传signal</span></span><br><span class=\"line\"><span class=\"title function_\">fetch</span>(<span class=\"string\">'/api/data'</span>, { signal })</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> res.<span class=\"title function_\">json</span>())</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err.<span class=\"property\">name</span> === <span class=\"string\">'AbortError'</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'请求被取消了'</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  });</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3秒后取消请求（比如用户点击“取消”按钮）</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> controller.<span class=\"title function_\">abort</span>(), <span class=\"number\">3000</span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"最后小测验\"><a href=\"#最后小测验\" class=\"headerlink\" title=\"最后小测验\"></a>最后小测验</h2><p>当用户点击一个按钮时，事件流的哪个阶段最先触发？<br>A) 目标阶段<br>B) 冒泡阶段<br>C) 捕获阶段</p>\n<p><strong>答案</strong>：C) 捕获阶段（事件从 <code>window</code> 向下传递到目标元素，先经过捕获阶段，再到目标阶段，最后是冒泡阶段）</p>\n<hr>\n<p>事件系统是前端交互的核心，掌握它不仅能写出流畅的交互，还能避免很多隐藏的性能问题。建议大家在实际项目中多尝试优化技巧，比如用事件委托替代多监听器、用 <code>passive</code> 提升滚动流畅度 —— 这些小改动能让页面体验提升一大截！</p>\n",
            "tags": [
                "JavaScript",
                "性能优化"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/prototype-chain/",
            "url": "http://toukoxu.github.io/archives/prototype-chain/",
            "title": "原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心",
            "date_published": "2021-05-02T12:46:25.000Z",
            "content_html": "<blockquote>\n<p>原型链是 JavaScript 面向对象的 “底层逻辑”—— 它让对象能 “继承” 其他对象的属性和方法，而 ES6 的 <code>class</code> 只是这套逻辑的 “语法糖”。今天从原型链的本质讲到 Class 的应用，帮你彻底搞懂 JS 继承到底是怎么回事。</p>\n</blockquote>\n<h2 id=\"一、原型链：JS-对象继承的“底层骨架”\"><a href=\"#一、原型链：JS-对象继承的“底层骨架”\" class=\"headerlink\" title=\"一、原型链：JS 对象继承的“底层骨架”\"></a>一、原型链：JS 对象继承的 “底层骨架”</h2><h3 id=\"1-1-什么是原型链？\"><a href=\"#1-1-什么是原型链？\" class=\"headerlink\" title=\"1.1 什么是原型链？\"></a>1.1 什么是原型链？</h3><p>简单说，<strong>原型链是 JS 实现继承的核心机制</strong>：每个对象都有一个隐藏的 “原型”（<code>[[Prototype]]</code>，可通过 <code>Object.getPrototypeOf()</code> 访问），这个原型本身也是一个对象，它也有自己的原型 —— 这样层层向上，就形成了一条 “原型链”。</p>\n<p>当你访问一个对象的属性时，如果当前对象没有这个属性，JS 会自动沿着原型链向上查找，直到找到属性或走到链的尽头（<code>null</code>）。</p>\n<p>看个直观的例子：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父对象：动物，有一个共享属性 eats</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> animal = { <span class=\"attr\">eats</span>: <span class=\"literal\">true</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子对象：兔子，有自己的属性 jumps</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> rabbit = { <span class=\"attr\">jumps</span>: <span class=\"literal\">true</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把 rabbit 的原型设为 animal（让兔子继承动物的属性）</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">setPrototypeOf</span>(rabbit, animal);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在兔子能访问动物的 eats 属性了</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rabbit.<span class=\"property\">eats</span>); <span class=\"comment\">// true（从原型链上找到的）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"1-2-原型链的三个核心概念\"><a href=\"#1-2-原型链的三个核心概念\" class=\"headerlink\" title=\"1.2 原型链的三个核心概念\"></a>1.2 原型链的三个核心概念</h3><p>要理解原型链，必须分清这三个容易混淆的概念：</p>\n<ol>\n<li><strong><code>prototype</code></strong>：只有<strong>函数</strong>才有这个属性，它是一个对象，存储着 “该函数创建的实例要继承的属性和方法”（比如 <code>Person.prototype</code> 里的方法，会被所有 <code>new Person()</code> 出来的实例继承）。</li>\n<li><strong><code>[[Prototype]]</code></strong>：所有对象（包括函数）都有的隐藏属性，指向该对象的 “原型对象”（可通过 <code>Object.getPrototypeOf(obj)</code> 访问，旧版的 <code>__proto__</code> 已不推荐使用）。</li>\n<li><strong><code>constructor</code></strong>：原型对象上的属性，指向 “创建该原型对应的实例的构造函数”（比如 <code>Person.prototype.constructor === Person</code>）。</li>\n</ol>\n<p>它们的关系可以用一张图表示：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  graph LR\nA[\"实例对象（如 new Person()）\"] --&gt;|\"[[Prototype]]\"| B[\"构造函数的 prototype（Person.prototype）\"]\nB --&gt;|\"[[Prototype]]\"| C[\"Object.prototype（所有对象的最终原型）\"]\nC --&gt;|\"[[Prototype]]\"| D[\"null（原型链的终点）\"]\nB --&gt;|constructor| E[\"构造函数（Person）\"]\n  </pre></div>\n\n<h2 id=\"二、原型链是怎么“造”出来的？\"><a href=\"#二、原型链是怎么“造”出来的？\" class=\"headerlink\" title=\"二、原型链是怎么“造”出来的？\"></a>二、原型链是怎么 “造” 出来的？</h2><h3 id=\"2-1-用构造函数创建对象：原型链的常见来源\"><a href=\"#2-1-用构造函数创建对象：原型链的常见来源\" class=\"headerlink\" title=\"2.1 用构造函数创建对象：原型链的常见来源\"></a>2.1 用构造函数创建对象：原型链的常见来源</h3><p>我们平时用 <code>new 构造函数()</code> 创建对象时，原型链会自动生成。比如：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 定义构造函数（用来创建“人”实例）</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 实例独有的属性：每个实例的 name 都不同</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在构造函数的 prototype 上定义共享方法（所有实例共用）</span></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayHello</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`你好，我是<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span>`</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 用 new 创建实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> alice = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">'Alice'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 验证原型关系</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(alice) === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// true（实例的原型是构造函数的 prototype）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>); <span class=\"comment\">// true（原型的构造函数指向原函数）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"2-2-new-操作符的底层逻辑\"><a href=\"#2-2-new-操作符的底层逻辑\" class=\"headerlink\" title=\"2.2 new 操作符的底层逻辑\"></a>2.2 <code>new</code> 操作符的底层逻辑</h3><p>你可能好奇：<code>new</code> 到底做了什么，能让实例和原型链关联起来？其实它只干了四件事：</p>\n<ol>\n<li>创建一个空对象（<code>{}</code>）；</li>\n<li>把这个空对象的原型，设为构造函数的 <code>prototype</code>；</li>\n<li>执行构造函数，把 <code>this</code> 指向这个空对象（给对象加属性）；</li>\n<li>如果构造函数没有返回其他对象，就返回这个新对象（否则返回构造函数的返回值）。</li>\n</ol>\n<p>我们可以手动模拟一个 <code>new</code> 操作符，更直观地看到这个过程：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myNew</span>(<span class=\"params\">constructor, ...args</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 1. 创建空对象，并把它的原型设为构造函数的 prototype</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(constructor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 执行构造函数，this 指向新对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = constructor.<span class=\"title function_\">apply</span>(obj, args);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 返回结果：如果构造函数返回了对象，就用它；否则用新对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span> ? result : obj;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用自定义的 myNew 创建实例，和原生 new 效果一样</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bob = <span class=\"title function_\">myNew</span>(<span class=\"title class_\">Person</span>, <span class=\"string\">'Bob'</span>);</span><br><span class=\"line\">bob.<span class=\"title function_\">sayHello</span>(); <span class=\"comment\">// 你好，我是Bob</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"三、原型链的“查找规则”：属性是怎么找到的？\"><a href=\"#三、原型链的“查找规则”：属性是怎么找到的？\" class=\"headerlink\" title=\"三、原型链的“查找规则”：属性是怎么找到的？\"></a>三、原型链的 “查找规则”：属性是怎么找到的？</h2><h3 id=\"3-1-属性查找的完整流程\"><a href=\"#3-1-属性查找的完整流程\" class=\"headerlink\" title=\"3.1 属性查找的完整流程\"></a>3.1 属性查找的完整流程</h3><p>当你访问 <code>obj.prop</code> 时，JS 会按以下步骤查找：</p>\n<ol>\n<li>先检查 <code>obj</code> 自身有没有 <code>prop</code>（通过 <code>obj.hasOwnProperty('prop')</code> 可判断）；</li>\n<li>如果没有，就找 <code>obj</code> 的原型（<code>Object.getPrototypeOf(obj)</code>），检查原型有没有 <code>prop</code>；</li>\n<li>如果原型也没有，就找原型的原型，以此类推；</li>\n<li>直到找到 <code>prop</code> 并返回，或者走到原型链尽头（<code>null</code>），返回 <code>undefined</code>。</li>\n</ol>\n<p>看个例子理解这个流程：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 定义构造函数 Animal</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Animal</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name; <span class=\"comment\">// 实例独有的属性</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在 Animal.prototype 上定义共享方法</span></span><br><span class=\"line\"><span class=\"title class_\">Animal</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">eat</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span> 在吃东西`</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 创建实例 cat</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> cat = <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>(<span class=\"string\">'喵星人'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 调用 cat.eat()，查找流程：</span></span><br><span class=\"line\"><span class=\"comment\">// ① 检查 cat 自身：没有 eat 方法 → ② 查 cat 的原型（Animal.prototype）→ 找到 eat 方法，执行</span></span><br><span class=\"line\">cat.<span class=\"title function_\">eat</span>(); <span class=\"comment\">// 喵星人 在吃东西</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-2-原型链的终点：null\"><a href=\"#3-2-原型链的终点：null\" class=\"headerlink\" title=\"3.2 原型链的终点：null\"></a>3.2 原型链的终点：<code>null</code></h3><p>所有原型链的最终尽头都是 <code>null</code>—— 因为 <code>Object.prototype</code> 的原型就是 <code>null</code>，它是 “所有对象的最终原型”（除了用 <code>Object.create(null)</code> 创建的 “纯净对象”）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cat = <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>(<span class=\"string\">'喵星人'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 顺着原型链往上找：</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(cat)); <span class=\"comment\">// Animal.prototype（第一层）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(<span class=\"title class_\">Animal</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>)); <span class=\"comment\">// Object.prototype（第二层）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>)); <span class=\"comment\">// null（第三层，终点）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(<span class=\"literal\">null</span>)); <span class=\"comment\">// 报错（null 没有原型）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这也解释了为什么所有对象都能调用 <code>toString()</code>、<code>hasOwnProperty()</code> 等方法 —— 这些方法其实定义在 <code>Object.prototype</code> 上，所有对象都能通过原型链找到它们。</p>\n<h2 id=\"四、原型链的“动态特性”：改原型会影响实例吗？\"><a href=\"#四、原型链的“动态特性”：改原型会影响实例吗？\" class=\"headerlink\" title=\"四、原型链的“动态特性”：改原型会影响实例吗？\"></a>四、原型链的 “动态特性”：改原型会影响实例吗？</h2><h3 id=\"4-1-动态修改原型：已创建的实例也会受影响\"><a href=\"#4-1-动态修改原型：已创建的实例也会受影响\" class=\"headerlink\" title=\"4.1 动态修改原型：已创建的实例也会受影响\"></a>4.1 动态修改原型：已创建的实例也会受影响</h3><p>JS 的原型是 “活的”—— 即使实例已经创建，后续给原型添加的属性 / 方法，实例也能访问到：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Dog</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\"><span class=\"comment\">// 创建实例 dog1（此时 Dog.prototype 上还没有 bark 方法）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dog1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后续给 Dog.prototype 添加 bark 方法</span></span><br><span class=\"line\"><span class=\"title class_\">Dog</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">bark</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'汪汪！'</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dog1 能调用到新添加的 bark 方法</span></span><br><span class=\"line\">dog1.<span class=\"title function_\">bark</span>(); <span class=\"comment\">// 汪汪！</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这是因为实例访问的是 “原型的引用”，而不是 “原型的副本”—— 原型变了，所有指向它的实例都会跟着变。</p>\n<h3 id=\"4-2-重写原型：旧实例不受影响\"><a href=\"#4-2-重写原型：旧实例不受影响\" class=\"headerlink\" title=\"4.2 重写原型：旧实例不受影响\"></a>4.2 重写原型：旧实例不受影响</h3><p>但如果是 “完全重写原型”（而不是修改原型的属性），情况就不一样了：重写后的原型是一个新对象，只有重写后创建的实例会用新原型，之前的旧实例还是指向原来的原型。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Cat</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\"><span class=\"comment\">// 旧实例：创建于原型重写前</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> cat1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 完全重写 Cat.prototype（新对象）</span></span><br><span class=\"line\"><span class=\"title class_\">Cat</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = {</span><br><span class=\"line\">  <span class=\"title function_\">meow</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'喵喵~'</span>);</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新实例：创建于原型重写后</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> cat2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.<span class=\"title function_\">meow</span>(); <span class=\"comment\">// 报错（cat1 的原型还是原来的空对象，没有 meow 方法）</span></span><br><span class=\"line\">cat2.<span class=\"title function_\">meow</span>(); <span class=\"comment\">// 喵喵~（cat2 的原型是新对象，有 meow 方法）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"五、ES6-Class：原型链的“语法糖”\"><a href=\"#五、ES6-Class：原型链的“语法糖”\" class=\"headerlink\" title=\"五、ES6 Class：原型链的“语法糖”\"></a>五、ES6 Class：原型链的 “语法糖”</h2><h3 id=\"5-1-Class-本质：还是原型继承\"><a href=\"#5-1-Class-本质：还是原型继承\" class=\"headerlink\" title=\"5.1 Class 本质：还是原型继承\"></a>5.1 Class 本质：还是原型继承</h3><p>ES6 引入的 <code>class</code> 语法，看起来像其他语言的 “类”，但底层还是基于原型链实现的 —— 它只是把原型继承的写法变得更简洁、更易读，没有改变 JS 的底层逻辑。</p>\n<p>比如下面两段代码，功能完全一样：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写法1：ES6 Class</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> {</span><br><span class=\"line\">  <span class=\"comment\">// 构造函数：对应原来的构造函数</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实例方法：会被添加到 Animal.prototype 上</span></span><br><span class=\"line\">  <span class=\"title function_\">eat</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span> 在吃东西`</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法2：ES5 原型继承（和上面完全等价）</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Animal</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Animal</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">eat</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span> 在吃东西`</span>);</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-2-Class-继承：extends-怎么工作？\"><a href=\"#5-2-Class-继承：extends-怎么工作？\" class=\"headerlink\" title=\"5.2 Class 继承：extends 怎么工作？\"></a>5.2 Class 继承：<code>extends</code> 怎么工作？</h3><p>Class 的 <code>extends</code> 关键字，本质是帮我们自动搭建了原型链。比如让 <code>Rabbit</code> 继承 <code>Animal</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子类 Rabbit 继承父类 Animal</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rabbit</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Animal</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name, speed</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// super()：调用父类的 constructor，相当于 Animal.call(this, name)</span></span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(name);</span><br><span class=\"line\">    <span class=\"comment\">// 子类独有的属性</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">speed</span> = speed;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 子类独有的方法（添加到 Rabbit.prototype 上）</span></span><br><span class=\"line\">  <span class=\"title function_\">jump</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span> 跳得很快，速度<span class=\"subst\">${<span class=\"variable language_\">this</span>.speed}</span>`</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建子类实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bunny = <span class=\"keyword\">new</span> <span class=\"title class_\">Rabbit</span>(<span class=\"string\">'小兔'</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 验证继承关系</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bunny <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Rabbit</span>); <span class=\"comment\">// true（是 Rabbit 的实例）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bunny <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Animal</span>); <span class=\"comment\">// true（也是 Animal 的实例，因为继承）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bunny <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span>); <span class=\"comment\">// true（最终继承自 Object）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用继承的方法和自己的方法</span></span><br><span class=\"line\">bunny.<span class=\"title function_\">eat</span>(); <span class=\"comment\">// 小兔 在吃东西（继承自 Animal）</span></span><br><span class=\"line\">bunny.<span class=\"title function_\">jump</span>(); <span class=\"comment\">// 小兔 跳得很快，速度10（自己的方法）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>extends</code> 做的核心事情：把 <code>Rabbit.prototype</code> 的原型，设为 <code>Animal.prototype</code>，从而搭建起 “<code>bunny</code> → <code>Rabbit.prototype</code> → <code>Animal.prototype</code> → <code>Object.prototype</code> → <code>null</code>” 的原型链。</p>\n<h2 id=\"六、原型链的实际用途：这些场景会用到\"><a href=\"#六、原型链的实际用途：这些场景会用到\" class=\"headerlink\" title=\"六、原型链的实际用途：这些场景会用到\"></a>六、原型链的实际用途：这些场景会用到</h2><h3 id=\"6-1-共享方法：节省内存\"><a href=\"#6-1-共享方法：节省内存\" class=\"headerlink\" title=\"6.1 共享方法：节省内存\"></a>6.1 共享方法：节省内存</h3><p>如果多个实例需要用同一个方法，把方法放在原型上（而不是每个实例都定义一次），能大幅节省内存 —— 因为所有实例共享同一个方法引用。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">User</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name; <span class=\"comment\">// 每个实例独有的属性</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有 User 实例共享 sayHi 方法</span></span><br><span class=\"line\"><span class=\"title class_\">User</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayHi</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`你好，<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span>`</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user1 = <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">'Alice'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> user2 = <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">'Bob'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 验证：两个实例的 sayHi 是同一个函数</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(user1.<span class=\"property\">sayHi</span> === user2.<span class=\"property\">sayHi</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果把 <code>sayHi</code> 写在构造函数里（<code>this.sayHi = function() {}</code>），每个实例都会有一个独立的函数副本，内存占用会翻倍。</p>\n<h3 id=\"6-2-实现自定义继承（ES5-写法）\"><a href=\"#6-2-实现自定义继承（ES5-写法）\" class=\"headerlink\" title=\"6.2 实现自定义继承（ES5 写法）\"></a>6.2 实现自定义继承（ES5 写法）</h3><p>在 Class 出现前，我们用原型链手动实现继承。比如让 <code>Circle</code> 继承 <code>Shape</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类：图形</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Shape</span>(<span class=\"params\">color</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">color</span> = color;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父类的共享方法</span></span><br><span class=\"line\"><span class=\"title class_\">Shape</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">getColor</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">color</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类：圆形</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Circle</span>(<span class=\"params\">radius, color</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 1. 调用父类构造函数，继承父类的属性（color）</span></span><br><span class=\"line\">  <span class=\"title class_\">Shape</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, color);</span><br><span class=\"line\">  <span class=\"comment\">// 2. 子类独有的属性</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">radius</span> = radius;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 搭建原型链：让 Circle.prototype 继承 Shape.prototype</span></span><br><span class=\"line\"><span class=\"title class_\">Circle</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"title class_\">Shape</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\"><span class=\"comment\">// 4. 修复 constructor 指向（因为上面一步把 Circle.prototype 换成了新对象，constructor 会指向 Shape）</span></span><br><span class=\"line\"><span class=\"title class_\">Circle</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> = <span class=\"title class_\">Circle</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 子类的共享方法</span></span><br><span class=\"line\"><span class=\"title class_\">Circle</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">getArea</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * <span class=\"variable language_\">this</span>.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用子类</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> redCircle = <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>(<span class=\"number\">5</span>, <span class=\"string\">'red'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(redCircle.<span class=\"title function_\">getColor</span>()); <span class=\"comment\">// red（继承自 Shape）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(redCircle.<span class=\"title function_\">getArea</span>()); <span class=\"comment\">// 78.539...（自己的方法）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"6-3-扩展内置对象（谨慎使用）\"><a href=\"#6-3-扩展内置对象（谨慎使用）\" class=\"headerlink\" title=\"6.3 扩展内置对象（谨慎使用）\"></a>6.3 扩展内置对象（谨慎使用）</h3><p>我们可以给内置对象的原型添加方法，让所有该类型的对象都能使用。比如给数组加一个 <code>sum</code> 方法：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给 Array.prototype 加 sum 方法，所有数组都能调用</span></span><br><span class=\"line\"><span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sum</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">total, num</span>) =&gt;</span> total + num, <span class=\"number\">0</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(numbers.<span class=\"title function_\">sum</span>()); <span class=\"comment\">// 10</span></span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote>\n<p>⚠️ 注意：扩展内置原型有风险！可能和其他库的方法重名（比如别人也给数组加了 <code>sum</code> 方法），导致代码冲突。非必要不推荐用。</p>\n</blockquote>\n<div class=\"note warning flat\"><p><strong>注意：</strong> 扩展内置原型有风险！可能和其他库的方法重名（比如别人也给数组加了 `sum` 方法），导致代码冲突。非必要不推荐用。</p></div>\n\n<h2 id=\"七、原型链的坑：这些问题要注意\"><a href=\"#七、原型链的坑：这些问题要注意\" class=\"headerlink\" title=\"七、原型链的坑：这些问题要注意\"></a>七、原型链的坑：这些问题要注意</h2><h3 id=\"7-1-原型污染：修改内置原型影响所有对象\"><a href=\"#7-1-原型污染：修改内置原型影响所有对象\" class=\"headerlink\" title=\"7.1 原型污染：修改内置原型影响所有对象\"></a>7.1 原型污染：修改内置原型影响所有对象</h3><p>如果恶意代码（或不小心）修改了 <code>Object.prototype</code>，所有对象都会受到影响 —— 这就是 “原型污染”。比如：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不小心给 Object.prototype 加了一个 hack 方法</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">hack</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'所有对象都会有这个方法！'</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 即使是新建的空对象，也会有 hack 方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> emptyObj = {};</span><br><span class=\"line\">emptyObj.<span class=\"title function_\">hack</span>(); <span class=\"comment\">// 所有对象都会有这个方法！</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>解决方案</strong>：用 <code>Object.create(null)</code> 创建 “纯净对象”—— 这种对象没有原型（<code>[[Prototype]]</code> 是 <code>null</code>），不会继承 <code>Object.prototype</code> 的属性，也就不会被污染：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pureObj = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(pureObj.<span class=\"property\">hack</span>); <span class=\"comment\">// undefined（不受原型污染影响）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"7-2-实例属性“遮蔽”原型属性\"><a href=\"#7-2-实例属性“遮蔽”原型属性\" class=\"headerlink\" title=\"7.2 实例属性“遮蔽”原型属性\"></a>7.2 实例属性 “遮蔽” 原型属性</h3><p>如果实例有一个和原型同名的属性，实例属性会 “覆盖” 原型属性（这叫 “属性遮蔽”）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\"><span class=\"comment\">// 原型上的 name 属性</span></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">name</span> = <span class=\"string\">'原型默认名'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例上的 name 属性（和原型同名）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">'实例自定义名'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 访问时会优先用实例的属性</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person.<span class=\"property\">name</span>); <span class=\"comment\">// 实例自定义名</span></span><br><span class=\"line\"><span class=\"comment\">// 要访问原型的属性，需要手动找原型</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(person).<span class=\"property\">name</span>); <span class=\"comment\">// 原型默认名</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"7-3-循环引用：导致栈溢出\"><a href=\"#7-3-循环引用：导致栈溢出\" class=\"headerlink\" title=\"7.3 循环引用：导致栈溢出\"></a>7.3 循环引用：导致栈溢出</h3><p>如果两个构造函数的原型互相指向对方，会形成 “循环原型链”，创建实例时会报错：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">A</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">B</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// A 的原型指向 B 的实例</span></span><br><span class=\"line\">A.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title function_\">B</span>();</span><br><span class=\"line\"><span class=\"comment\">// B 的原型指向 A 的实例 → 循环引用！</span></span><br><span class=\"line\">B.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title function_\">A</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试创建实例：会触发无限递归，栈溢出</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> <span class=\"title function_\">A</span>();</span><br><span class=\"line\">} <span class=\"keyword\">catch</span> (e) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(e.<span class=\"property\">message</span>); <span class=\"comment\">// Maximum call stack size exceeded</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"八、原型链最佳实践：写代码更安全\"><a href=\"#八、原型链最佳实践：写代码更安全\" class=\"headerlink\" title=\"八、原型链最佳实践：写代码更安全\"></a>八、原型链最佳实践：写代码更安全</h2><ol>\n<li><p><strong>优先用 Class 语法</strong>：<code>class</code> 和 <code>extends</code> 比 ES5 手动改原型更清晰，不容易出错，比如：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> {}</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rabbit</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Animal</span> {}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p><strong>不用 <code>__proto__</code>，用标准方法操作原型</strong>：</p>\n<ul>\n<li>查原型：<code>Object.getPrototypeOf(obj)</code>（替代 <code>obj.__proto__</code>）</li>\n<li>改原型：<code>Object.setPrototypeOf(obj, newProto)</code>（替代 <code>obj.__proto__ = newProto</code>）</li>\n<li>创建带原型的对象：<code>Object.create(proto)</code>（比 <code>new</code> 更灵活）</li>\n</ul>\n</li>\n<li><p><strong>属性和方法分开放</strong>：构造函数里定义 “实例独有的属性”，原型上定义 “所有实例共享的方法”—— 符合内存高效利用的原则：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name; <span class=\"comment\">// 实例独有属性</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {}; <span class=\"comment\">// 共享方法</span></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p><strong>避免修改内置原型</strong>：除非有绝对必要，否则不要给 <code>Array.prototype</code>、<code>Object.prototype</code> 等加方法，防止冲突。</p>\n</li>\n</ol>\n<h2 id=\"最后小测验\"><a href=\"#最后小测验\" class=\"headerlink\" title=\"最后小测验\"></a>最后小测验</h2><p>看看你有没有掌握原型链的核心逻辑，下面代码会输出什么？</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\"><span class=\"keyword\">const</span> f1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Foo</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(f1 <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(f1) === <span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>答案</strong>：<code>true</code>、<code>true</code>、<code>true</code></p>\n<ul>\n<li><code>f1</code> 是 <code>Foo</code> 的实例，<code>Foo.prototype</code> 继承自 <code>Object.prototype</code>，所以 <code>f1 instanceof Object</code> 为 <code>true</code>；</li>\n<li><code>Foo.prototype</code> 是一个普通对象，继承自 <code>Object.prototype</code>，所以 <code>Foo.prototype instanceof Object</code> 为 <code>true</code>；</li>\n<li><code>new Foo()</code> 创建的实例，原型就是 <code>Foo.prototype</code>，所以第三个判断为 <code>true</code>。</li>\n</ul>\n<hr>\n<p>原型链虽然是 JS 的 “底层概念”，但理解它能帮你避开很多隐藏的坑（比如原型污染、属性遮蔽），也能让你更懂 Class 的本质 —— 不是 “新的继承方式”，只是原型链的优雅包装。掌握这些，你对 JS 面向对象的理解会更上一层楼～</p>\n",
            "tags": [
                "JavaScript",
                "性能优化",
                "ES6"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/closure/",
            "url": "http://toukoxu.github.io/archives/closure/",
            "title": "闭包（Closure）：JavaScript 里的 “记忆小助手”",
            "date_published": "2021-04-03T12:46:25.000Z",
            "content_html": "<blockquote>\n<p>闭包是 JavaScript 中比较容易让人困惑的概念 —— 它能让函数 “记住自己成长的环境”，哪怕后来跑到别的地方工作，也能找回当初的变量。今天就抛开复杂术语，用更通俗的方式拆解闭包，从原理到实战一次讲明白！</p>\n</blockquote>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>如果对作用域链还不熟悉，建议先看下面这篇。理解函数如何查找变量后，再理解闭包会更顺畅～</p>\n<div calss=\"anzhiyu-tag-link\"><a class=\"tag-Link\" target=\"_blank\" href=\"/2021/03/16/scope-chain\">\n    <div class=\"tag-link-tips\">站内地址</div>\n    <div class=\"tag-link-bottom\">\n        <div class=\"tag-link-left\" style=\"background-image: url(/img/512.png)\">\n          <i class=\"anzhiyufont anzhiyu-icon-link\" style=\"display: none\"></i>\n        </div>\n        <div class=\"tag-link-right\">\n            <div class=\"tag-link-title\">作用域链（Scope Chain）</div>\n            <div class=\"tag-link-sitename\"> Touko</div>\n        </div>\n        <i class=\"anzhiyufont anzhiyu-icon-angle-right\"></i>\n    </div>\n    </a></div>\n\n<h2 id=\"一、闭包的本质：函数-诞生环境\"><a href=\"#一、闭包的本质：函数-诞生环境\" class=\"headerlink\" title=\"一、闭包的本质：函数 + 诞生环境\"></a>一、闭包的本质：函数 + 诞生环境</h2><h3 id=\"1-1-到底什么是闭包（Closure）？\"><a href=\"#1-1-到底什么是闭包（Closure）？\" class=\"headerlink\" title=\"1.1 到底什么是闭包（Closure）？\"></a>1.1 到底什么是闭包（Closure）？</h3><p>官方定义有点抽象：<strong>闭包是函数与其声明时所在词法环境的组合</strong>。</p>\n<p>换成人话就是：一个函数在 “老家”（声明时的作用域）定义时，记下了周围的变量；后来就算跑到 “外地”（其他作用域）执行，也能找到这些 “老家的变量”—— 这就形成了闭包。</p>\n<p>举个直观的例子，你看这个 “带记忆的函数”：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createMemory</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 这个变量是“老家的东西”，属于外部函数作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> secret = <span class=\"string\">'我是函数在老家时记住的内容'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 内部函数：相当于能找回“老家东西”的钥匙</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getSecret</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(secret); <span class=\"comment\">// 访问“老家”的变量</span></span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取出这个“带记忆的函数”（此时外部函数已执行完，正常来说内部变量该消失了）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myMemory = <span class=\"title function_\">createMemory</span>();</span><br><span class=\"line\"><span class=\"comment\">// 调用函数：居然还能找到secret！</span></span><br><span class=\"line\"><span class=\"title function_\">myMemory</span>(); <span class=\"comment\">// 输出：\"我是函数在老家时记住的内容\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这里的<code>getSecret</code>就是闭包 —— 它记得自己 “老家” 的环境，所以就算<code>createMemory</code>执行完了，也能找回<code>secret</code>。</p>\n<h3 id=\"1-2-闭包形成的三个关键条件\"><a href=\"#1-2-闭包形成的三个关键条件\" class=\"headerlink\" title=\"1.2 闭包形成的三个关键条件\"></a>1.2 闭包形成的三个关键条件</h3><p>不是所有函数都是闭包，得满足这三个条件：</p>\n<ol>\n<li><strong>函数嵌套</strong>：内部函数定义在外部函数里面（比如<code>getSecret</code>在<code>createMemory</code>里）</li>\n<li><strong>记着老家的变量</strong>：内部函数用到了外部函数的变量或参数（<code>getSecret</code>用了<code>secret</code>）</li>\n<li><strong>离开老家</strong>：内部函数被返回、传递到外部函数作用域之外（<code>getSecret</code>被 return 出去，赋值给<code>myMemory</code>）</li>\n</ol>\n<div class=\"note info flat\"><p><strong>这里有个容易误解的点：</strong> 闭包不是我们 “刻意创建” 的，而是<mark>函数定义时的自然结果</mark>！只要满足上面三个条件，闭包就会自动形成 —— 不用写特殊语法，它就在那了。</p></div>\n\n<h3 id=\"1-3-闭包的核心特点\"><a href=\"#1-3-闭包的核心特点\" class=\"headerlink\" title=\"1.3 闭包的核心特点\"></a>1.3 闭包的核心特点</h3><ol>\n<li><strong>变量持久化</strong>：相当于给变量 “延长了生命周期”。正常情况下，函数执行完，内部变量会被垃圾回收机制清理，但闭包能让变量一直 “活着”（比如上面的<code>secret</code>）</li>\n<li><strong>变量私有权</strong>：外部无法直接碰闭包记住的变量。比如你没法直接改<code>secret</code>，只能通过<code>getSecret</code>这个 “接口” 访问 —— 这就实现了数据私有</li>\n<li><strong>作用域链保留</strong>：闭包不只是记着自己用的变量，而是记着整个 “老家的环境链”（外部函数作用域 → 全局作用域）。比如如果<code>secret</code>还引用了全局变量，闭包也能找到</li>\n</ol>\n<h2 id=\"二、拆解闭包：看看它“记着”哪些东西\"><a href=\"#二、拆解闭包：看看它“记着”哪些东西\" class=\"headerlink\" title=\"二、拆解闭包：看看它“记着”哪些东西\"></a>二、拆解闭包：看看它 “记着” 哪些东西</h2><h3 id=\"2-1-经典案例：带闭包的计数器\"><a href=\"#2-1-经典案例：带闭包的计数器\" class=\"headerlink\" title=\"2.1 经典案例：带闭包的计数器\"></a>2.1 经典案例：带闭包的计数器</h3><p>用闭包实现计数器是最常见的场景，能清晰看到闭包如何 “保管” 变量：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createCounter</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>; <span class=\"comment\">// 被闭包“保管”的变量，外部拿不到</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 返回三个“操作接口”，都是闭包</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> {</span><br><span class=\"line\">    <span class=\"attr\">increment</span>: <span class=\"function\">() =&gt;</span> count++, <span class=\"comment\">// 加1</span></span><br><span class=\"line\">    <span class=\"attr\">decrement</span>: <span class=\"function\">() =&gt;</span> count--, <span class=\"comment\">// 减1</span></span><br><span class=\"line\">    <span class=\"attr\">getValue</span>: <span class=\"function\">() =&gt;</span> count, <span class=\"comment\">// 查当前值</span></span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个计数器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> counter = <span class=\"title function_\">createCounter</span>();</span><br><span class=\"line\">counter.<span class=\"title function_\">increment</span>();</span><br><span class=\"line\">counter.<span class=\"title function_\">increment</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(counter.<span class=\"title function_\">getValue</span>()); <span class=\"comment\">// 输出 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 试着直接访问count：拿不到！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(counter.<span class=\"property\">count</span>); <span class=\"comment\">// undefined！无法直接访问</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这里的<code>increment</code>、<code>decrement</code>、<code>getValue</code>都是闭包，它们共享同一个<code>count</code>变量 —— 不管调用哪个方法，操作的都是同一个计数器，就像几个人共用一个笔记本一样。</p>\n<h3 id=\"2-2-闭包的作用域链\"><a href=\"#2-2-闭包的作用域链\" class=\"headerlink\" title=\"2.2 闭包的作用域链\"></a>2.2 闭包的作用域链</h3><p>闭包能找到变量，靠的是作用域链。拿上面的计数器举例，作用域链是这样的：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  graph LR\nA[\"内部函数（increment）的环境\"] --&gt; B[\"外部函数（createCounter）的环境\"]\nB --&gt; C[全局环境]\n  </pre></div>\n\n<p>当<code>increment</code>执行时，会先在自己的环境找<code>count</code>（没找到），再顺着作用域链往上找，直到在<code>createCounter</code>的环境里找到 —— 这就是闭包能访问外部变量的原理。</p>\n<blockquote>\n<p><strong>关键点</strong>：闭包会保留<strong>整个作用域链</strong>，而不仅仅是它用到的变量！</p>\n</blockquote>\n<h2 id=\"三、闭包的实战场景\"><a href=\"#三、闭包的实战场景\" class=\"headerlink\" title=\"三、闭包的实战场景\"></a>三、闭包的实战场景</h2><p>闭包不是理论概念，实际开发中到处都有它的影子，分享几个我常用的场景：</p>\n<h3 id=\"3-1-数据封装：实现“私有变量”\"><a href=\"#3-1-数据封装：实现“私有变量”\" class=\"headerlink\" title=\"3.1 数据封装：实现“私有变量”\"></a>3.1 数据封装：实现 “私有变量”</h3><p>JavaScript 没有原生的 “私有变量” 语法，但用闭包就能模拟。比如实现一个银行账户，余额只能通过存款、取款接口操作，不能直接修改：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createBankAccount</span>(<span class=\"params\">initialBalance</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> balance = initialBalance; <span class=\"comment\">// 私有变量，外部无法直接访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 存款：只能通过这个方法加余额</span></span><br><span class=\"line\">    <span class=\"attr\">depositMoney</span>: <span class=\"function\">(<span class=\"params\">amount</span>) =&gt;</span> (balance += amount),</span><br><span class=\"line\">    <span class=\"comment\">// 取款：带校验逻辑，防止余额不足</span></span><br><span class=\"line\">    <span class=\"attr\">drawMoney</span>: <span class=\"function\">(<span class=\"params\">amount</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (amount &gt; balance) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">'余额不足'</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (balance -= amount);</span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"comment\">// 查询余额：只能看，不能改</span></span><br><span class=\"line\">    <span class=\"attr\">getAmount</span>: <span class=\"function\">() =&gt;</span> <span class=\"string\">`余额：¥<span class=\"subst\">${balance}</span>`</span>,</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建账户，初始1000元</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myAccount = <span class=\"title function_\">createBankAccount</span>(<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"comment\">// 存500</span></span><br><span class=\"line\">myAccount.<span class=\"title function_\">depositMoney</span>(<span class=\"number\">500</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myAccount.<span class=\"title function_\">getAmount</span>()); <span class=\"comment\">// 余额：¥1500</span></span><br><span class=\"line\"><span class=\"comment\">// 试着取2000：会报错，因为有校验</span></span><br><span class=\"line\">myAccount.<span class=\"title function_\">drawMoney</span>(<span class=\"number\">2000</span>); <span class=\"comment\">// Uncaught Error: 余额不足</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在写组件状态管理时，经常用这种方式封装敏感数据，防止外部代码误改导致 bug。</p>\n<h3 id=\"3-2-函数工厂：批量生成“定制化函数”\"><a href=\"#3-2-函数工厂：批量生成“定制化函数”\" class=\"headerlink\" title=\"3.2 函数工厂：批量生成“定制化函数”\"></a>3.2 函数工厂：批量生成 “定制化函数”</h3><p>如果需要多个逻辑相似但参数不同的函数，用闭包做 “函数工厂” 特别方便。比如生成不同风格的问候语：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createGreeting</span>(<span class=\"params\">prefix</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// prefix是“定制参数”，被闭包记住</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">name</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">${prefix}</span>，<span class=\"subst\">${name}</span>！`</span>;</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成“正式问候”和“友好问候”两个函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> formalGreeting = <span class=\"title function_\">createGreeting</span>(<span class=\"string\">'尊敬的'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> friendlyGreeting = <span class=\"title function_\">createGreeting</span>(<span class=\"string\">'嘿'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用的时候直接传名字就行，不用再重复写前缀</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">formalGreeting</span>(<span class=\"string\">'王总'</span>)); <span class=\"comment\">// \"尊敬的，王总！\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">friendlyGreeting</span>(<span class=\"string\">'小明'</span>)); <span class=\"comment\">// \"嘿，小明！\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>我之前做表单验证时，用这个方法生成了一堆校验函数（比如 “最小长度校验”“最大长度校验”），不用重复写逻辑，代码简洁了很多。</p>\n<h3 id=\"3-3-事件处理：保留“上下文信息”\"><a href=\"#3-3-事件处理：保留“上下文信息”\" class=\"headerlink\" title=\"3.3 事件处理：保留“上下文信息”\"></a>3.3 事件处理：保留 “上下文信息”</h3><p>写事件绑定的时候，经常需要在回调里用外部变量，这时候闭包就派上用场了。比如给多个按钮绑定点击事件，输出各自的索引：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> buttons = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">'button'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; buttons.<span class=\"property\">length</span>; i++) {</span><br><span class=\"line\">  buttons[i].<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`按钮 <span class=\"subst\">${i}</span> 被点击`</span>);</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这里的箭头函数就是闭包，它记住了循环时的<code>i</code>。不过，如果用<code>var</code>声明<code>i</code>（没有块级作用域），反而会出问题，得用 IIFE + 闭包兼容，不过现在有<code>let</code>就简单多了。</p>\n<h3 id=\"3-4-模块模式：早期前端模块化的基础\"><a href=\"#3-4-模块模式：早期前端模块化的基础\" class=\"headerlink\" title=\"3.4 模块模式：早期前端模块化的基础\"></a>3.4 模块模式：早期前端模块化的基础</h3><p>在 ES6 Module 出现之前，前端模块化基本靠闭包实现。比如封装一个工具模块，只暴露需要的接口，内部逻辑隐藏起来：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myModule = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 私有状态：外部看不到</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> state = <span class=\"string\">'初始化'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 私有函数：只能在模块内部用</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">privateMethod</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'执行内部操作'</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 公开接口：外部只能通过这些方法访问内部</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> {</span><br><span class=\"line\">    <span class=\"attr\">action</span>: <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">privateMethod</span>();</span><br><span class=\"line\">      state = <span class=\"string\">'已更新'</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"attr\">getState</span>: <span class=\"function\">() =&gt;</span> state,</span><br><span class=\"line\">  };</span><br><span class=\"line\">})();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用公开方法</span></span><br><span class=\"line\">myModule.<span class=\"title function_\">action</span>(); <span class=\"comment\">// \"执行内部操作\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myModule.<span class=\"title function_\">getState</span>()); <span class=\"comment\">// \"已更新\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 试着访问私有成员：拿不到</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myModule.<span class=\"property\">state</span>); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">myModule.<span class=\"title function_\">privateMethod</span>(); <span class=\"comment\">// Uncaught TypeError: myModule.privateMethod is not a function</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这种模式我在维护老项目时经常见到，虽然现在有 ES Module 了，但闭包的封装思想依然很有用。</p>\n<h2 id=\"四、闭包的坑：内存浪费与优化\"><a href=\"#四、闭包的坑：内存浪费与优化\" class=\"headerlink\" title=\"四、闭包的坑：内存浪费与优化\"></a>四、闭包的坑：内存浪费与优化</h2><p>闭包虽好用，但用不好容易出问题，最常见的就是 “内存浪费”（内存泄漏）。</p>\n<h3 id=\"4-1-为什么会内存浪费？\"><a href=\"#4-1-为什么会内存浪费？\" class=\"headerlink\" title=\"4.1 为什么会内存浪费？\"></a>4.1 为什么会内存浪费？</h3><p>闭包会 “留住” 它记住的环境里的变量，不让垃圾回收机制（GC）清理。如果闭包引用了大对象（比如 DOM 元素、超大数组），又一直没被销毁，这些对象就会一直占着内存，导致内存越用越多。</p>\n<p>举个反面例子：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">heavyOperation</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 模拟一个10MB的大数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> largeData = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"number\">1000000</span>).<span class=\"title function_\">fill</span>(<span class=\"string\">'占用内存的数据'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 闭包引用了largeData</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(largeData.<span class=\"property\">length</span>);</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用后，largeData被闭包记住，无法被清理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> memoryHog = <span class=\"title function_\">heavyOperation</span>();</span><br><span class=\"line\"><span class=\"comment\">// 就算后面不用memoryHog了，largeData也还在内存里</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果这种闭包多了，页面会越来越卡，甚至崩溃。</p>\n<div class=\"note warning flat\"><p><strong>内存泄漏警告：</strong> 闭包会阻止其作用域链上所有变量被回收，不当使用会导致<mark>内存泄漏</mark>！</p></div>\n\n<h3 id=\"4-2-优化技巧：避免内存浪费\"><a href=\"#4-2-优化技巧：避免内存浪费\" class=\"headerlink\" title=\"4.2 优化技巧：避免内存浪费\"></a>4.2 优化技巧：避免内存浪费</h3><p>分享几个我实战中用过的优化方法：</p>\n<ol>\n<li><strong>主动 “忘记” 变量</strong>：不用闭包时，手动把它记住的变量设为<code>null</code>，让 GC 能清理</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createClosure</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = <span class=\"string\">'需要保留的数据'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">closure</span> = (<span class=\"params\"></span>) =&gt; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 给闭包加个“清理方法”</span></span><br><span class=\"line\">  closure.<span class=\"property\">cleanup</span> = <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    data = <span class=\"literal\">null</span>; <span class=\"comment\">// 解除引用，让闭包“忘记”data，GC能回收了</span></span><br><span class=\"line\">  };</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> closure;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> myClosure = <span class=\"title function_\">createClosure</span>();</span><br><span class=\"line\"><span class=\"comment\">// 使用完闭包后，调用清理方法</span></span><br><span class=\"line\">myClosure.<span class=\"title function_\">cleanup</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<ol start=\"2\">\n<li><strong>只记需要的内容</strong>：如果只需要大对象的部分数据，就别引用整个对象</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createClosure</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> largeData = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"number\">1000000</span>).<span class=\"title function_\">fill</span>(<span class=\"string\">'大数据'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 只记需要的小数据（比如长度），不引用整个largeData</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> metaData = { <span class=\"attr\">length</span>: largeData.<span class=\"property\">length</span> };</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(metaData.<span class=\"property\">length</span>);</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-3-闭包-vs-ES6-块级作用域\"><a href=\"#4-3-闭包-vs-ES6-块级作用域\" class=\"headerlink\" title=\"4.3 闭包 vs ES6 块级作用域\"></a>4.3 闭包 vs ES6 块级作用域</h3><p>有些场景下，ES6 的<code>let/const</code>（块级作用域）能替代闭包，代码更简洁。比如之前的循环绑定事件：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 旧方法：用IIFE+闭包兼容var的问题</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) {</span><br><span class=\"line\">  (<span class=\"keyword\">function</span> (<span class=\"params\">j</span>) {</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(j), <span class=\"number\">100</span>);</span><br><span class=\"line\">  })(i);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新方法：用let的块级作用域，不用闭包</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) {</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i), <span class=\"number\">100</span>); <span class=\"comment\">// 输出0,1,2,3,4</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>因为<code>let</code>在循环里每次迭代都会创建一个新的作用域，定时器回调能直接拿到当前的<code>i</code> —— 这时候就不用再写闭包了。</p>\n<h2 id=\"五、底层原理：闭包为什么能“记住”环境？\"><a href=\"#五、底层原理：闭包为什么能“记住”环境？\" class=\"headerlink\" title=\"五、底层原理：闭包为什么能“记住”环境？\"></a>五、底层原理：闭包为什么能 “记住” 环境？</h2><p>其实闭包的底层就是 “作用域链” 的机制。再梳理下它的形成过程：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  graph TD\nA[\"外部函数被调用，创建执行环境\"] --&gt; B[\"内部函数定义，记录当前的词法环境\"]\nB --&gt; C[\"内部函数引用外部函数的变量\"]\nC --&gt; D[\"外部函数执行完，返回内部函数到外部作用域\"]\nD --&gt; E[\"内部函数被调用时，通过作用域链找到外部变量，闭包生效\"]\n  </pre></div>\n\n<p>简单说：函数定义时会 “记下自己在哪出生”（词法作用域），执行时会顺着这个 “出生地链条” 找变量 —— 闭包就是利用了这个机制，让函数在别的地方执行时，还能找到 “老家” 的环境。</p>\n<h3 id=\"5-1-现代引擎的优化：不用怕闭包影响性能\"><a href=\"#5-1-现代引擎的优化：不用怕闭包影响性能\" class=\"headerlink\" title=\"5.1 现代引擎的优化：不用怕闭包影响性能\"></a>5.1 现代引擎的优化：不用怕闭包影响性能</h3><p>很多人担心闭包性能差，但现代 JavaScript 引擎（比如 V8，Chrome 和 Node.js 用的）对闭包做了很多优化：</p>\n<ul>\n<li><strong>按需保留</strong>：只保留闭包真正用到的变量，没用的变量会被 GC 清理（比如上面的<code>largeData</code>如果没被引用，就会被回收）</li>\n<li><strong>缓存常用变量</strong>：频繁访问的闭包变量会被缓存，访问速度更快</li>\n<li><strong>优化对象查找</strong>：对闭包引用的对象做特殊处理，减少属性查找时间</li>\n</ul>\n<p>所以不用过度担心闭包的性能问题 —— 正常使用下，性能开销可以忽略不计。只有在循环里频繁创建闭包（比如每秒创建上千个），才需要注意优化。</p>\n<h2 id=\"六、闭包最佳实践：这些坑我踩过，你别踩\"><a href=\"#六、闭包最佳实践：这些坑我踩过，你别踩\" class=\"headerlink\" title=\"六、闭包最佳实践：这些坑我踩过，你别踩\"></a>六、闭包最佳实践：这些坑我踩过，你别踩</h2><p>分享几个我实战中总结的经验，帮你避开闭包的坑：</p>\n<ol>\n<li><p><strong>少记无关内容</strong>：只让闭包记住必要的变量，别把不需要的东西也带在身上。比如上面的银行账户，只暴露<code>depositMoney</code>等方法，不暴露<code>balance</code>。</p>\n</li>\n<li><p><strong>能不用就不用</strong>：如果用块级作用域（<code>let/const</code>）能解决问题，就别用闭包。比如循环里用<code>let</code>替代<code>var + 闭包</code>，代码更简洁，也少了内存开销。</p>\n</li>\n<li><p><strong>小心循环引用</strong>：闭包引用 DOM 元素时，容易形成 “闭包 →DOM→ 闭包” 的循环引用。解决方法是：事件不用时手动移除监听，或用<code>WeakMap</code>/<code>WeakSet</code>（弱引用）存储 DOM。</p>\n</li>\n<li><p><strong>明确生命周期</strong>：用闭包封装组件时，尽量做成 “自包含” 的模块，不用时调用清理方法，释放内存。</p>\n</li>\n</ol>\n<h2 id=\"七、常见问题解答\"><a href=\"#七、常见问题解答\" class=\"headerlink\" title=\"七、常见问题解答\"></a>七、常见问题解答</h2><h3 id=\"Q1：闭包是什么？举个例子\"><a href=\"#Q1：闭包是什么？举个例子\" class=\"headerlink\" title=\"Q1：闭包是什么？举个例子\"></a>Q1：闭包是什么？举个例子</h3><p><strong>闭包是函数记住并访问其词法作用域的能力</strong>，哪怕函数在词法作用域之外执行。比如实现计数器：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createCounter</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> count++;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">const</span> counter = <span class=\"title function_\">createCounter</span>();</span><br><span class=\"line\"><span class=\"title function_\">counter</span>(); <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title function_\">counter</span>(); <span class=\"comment\">// 1</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Q2：闭包有什么优缺点？\"><a href=\"#Q2：闭包有什么优缺点？\" class=\"headerlink\" title=\"Q2：闭包有什么优缺点？\"></a>Q2：闭包有什么优缺点？</h3><p><strong>优点</strong>：</p>\n<ul>\n<li>实现数据封装（私有变量），防止外部误改</li>\n<li>保留变量状态（比如计数器），不用依赖全局变量</li>\n<li>批量生成定制化函数（函数工厂）</li>\n<li>是早期前端模块化的基础</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>可能导致内存浪费（引用的变量无法清理）</li>\n<li>频繁创建闭包有轻微性能开销</li>\n<li>调试时不容易追踪变量来源（Chrome DevTools 里变量会标为<code>Closure</code>）</li>\n</ul>\n<h3 id=\"Q3：如何避免闭包导致的内存浪费？\"><a href=\"#Q3：如何避免闭包导致的内存浪费？\" class=\"headerlink\" title=\"Q3：如何避免闭包导致的内存浪费？\"></a>Q3：如何避免闭包导致的内存浪费？</h3><ul>\n<li>只让闭包记住必要的变量，减少无关引用</li>\n<li>不用闭包时，主动把引用的变量设为<code>null</code></li>\n<li>避免在闭包里引用大对象（比如大数组、整个 DOM 树）</li>\n<li>用<code>WeakMap</code>/<code>WeakSet</code>存储引用，让 GC 能清理</li>\n<li>明确闭包的生命周期，不用时执行清理逻辑（比如移除事件监听）</li>\n</ul>\n<h2 id=\"八、闭包总结：不是难题，是实用工具\"><a href=\"#八、闭包总结：不是难题，是实用工具\" class=\"headerlink\" title=\"八、闭包总结：不是难题，是实用工具\"></a>八、闭包总结：不是难题，是实用工具</h2><p>最后用一张表总结闭包的核心特性，方便大家回顾：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n<th>应用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>词法作用域</strong></td>\n<td>闭包的基础，函数定义时决定 “老家”</td>\n<td>所有闭包场景</td>\n</tr>\n<tr>\n<td><strong>保留变量状态</strong></td>\n<td>让变量不被清理，持续可用</td>\n<td>计数器、缓存工具</td>\n</tr>\n<tr>\n<td><strong>数据封装</strong></td>\n<td>变量私有，只能通过闭包访问</td>\n<td>模块开发、模拟类</td>\n</tr>\n<tr>\n<td><strong>函数工厂</strong></td>\n<td>动态生成带定制参数的函数</td>\n<td>表单验证、问候语生成</td>\n</tr>\n<tr>\n<td><strong>内存开销</strong></td>\n<td>保留作用域链，可能占内存</td>\n<td>需要优化的场景</td>\n</tr>\n<tr>\n<td><strong>调试标识</strong></td>\n<td>Chrome DevTools 中变量标为<code>Closure</code></td>\n<td>调试闭包相关问题</td>\n</tr>\n</tbody></table>\n<hr>\n<p>很多人觉得闭包难，是因为它 “看不见摸不着”—— 但其实只要理解 “函数记住老家环境” 这个核心，再结合实际场景多练，很快就能掌握。</p>\n<p>闭包不是需要害怕的难题，而是 JavaScript 里实用的工具。用好了它，你就能写出更安全、更优雅的代码，比如封装组件、管理状态、实现模块化 —— 现在就试着用闭包写个小工具吧！</p>\n",
            "tags": [
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/scope-chain/",
            "url": "http://toukoxu.github.io/archives/scope-chain/",
            "title": "作用域链（Scope Chain）：JS 变量查找的 “路线图”",
            "date_published": "2021-03-16T12:46:25.000Z",
            "content_html": "<blockquote>\n<p><strong>作用域链是 JavaScript 查找变量的核心机制</strong> —— 当代码需要访问一个变量时，JS 引擎会沿着 “当前作用域 → 父作用域 → 全局作用域” 的顺序层层查找，这条查找路径就像一张 “路线图”，指引引擎找到目标变量。</p>\n</blockquote>\n<h2 id=\"一、作用域链的本质：静态的查找路径\"><a href=\"#一、作用域链的本质：静态的查找路径\" class=\"headerlink\" title=\"一、作用域链的本质：静态的查找路径\"></a>一、作用域链的本质：静态的查找路径</h2><h3 id=\"1-1-核心概念：从“作用域”到“作用域链”\"><a href=\"#1-1-核心概念：从“作用域”到“作用域链”\" class=\"headerlink\" title=\"1.1 核心概念：从“作用域”到“作用域链”\"></a>1.1 核心概念：从 “作用域” 到 “作用域链”</h3><p>首先要明确：<strong>作用域是变量的 “可访问范围”</strong>（比如函数内部的变量只能在函数内访问），而 “作用域链” 是多个嵌套作用域组成的 “查找链条”。</p>\n<p>比如函数嵌套场景，内部函数会形成包含父函数作用域、祖父函数作用域的链条，最终指向全局作用域：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  graph LR\nA[当前作用域（如 inner 函数）] --&gt; B[父作用域（如 outer 函数）]\nB --&gt; C[祖父作用域（更外层函数）]\nC --&gt; D[...]\nD --&gt; E[全局作用域]\n  </pre></div>\n\n<h3 id=\"1-2-关键特性：作用域链“定义时确定，而非调用时”\"><a href=\"#1-2-关键特性：作用域链“定义时确定，而非调用时”\" class=\"headerlink\" title=\"1.2 关键特性：作用域链“定义时确定，而非调用时”\"></a>1.2 关键特性：作用域链 “定义时确定，而非调用时”</h3><p>这是理解作用域链的核心 —— 函数的作用域链在<strong>函数定义的那一刻就固定了</strong>，和函数什么时候调用、在哪里调用无关。这个特性也是闭包（👉 <a href=\"/archives/closure/\" title=\"闭包（Closure）：JavaScript 里的“记忆小助手”\">闭包（Closure）：JavaScript 里的 “记忆小助手”</a>）能 “记住外部变量” 的底层原因。</p>\n<p>看个例子验证：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">outer</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> outerVar = <span class=\"string\">'我是外层变量'</span>; <span class=\"comment\">// 父作用域的变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// inner 函数在 outer 内部定义，此时就确定了作用域链：inner → outer → 全局</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">inner</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(outerVar); <span class=\"comment\">// 能访问 outerVar，因为作用域链包含 outer 作用域</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> inner; <span class=\"comment\">// 返回 inner 函数（此时 inner 已携带作用域链）</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 outer，拿到 inner 函数（此时 outer 已执行完，但 inner 的作用域链还在）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> innerFunc = <span class=\"title function_\">outer</span>();</span><br><span class=\"line\"><span class=\"title function_\">innerFunc</span>(); <span class=\"comment\">// 输出“我是外层变量”（inner 按定义时的作用域链找到了 outerVar）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<div class=\"note warning flat\"><p><strong>重点：</strong> 作用域链是 “静态” 的 —— 函数定义时就确定，不会因调用位置变化而改变。</p>\n</div>\n\n<h2 id=\"二、作用域链的组成：变量查找的层级结构\"><a href=\"#二、作用域链的组成：变量查找的层级结构\" class=\"headerlink\" title=\"二、作用域链的组成：变量查找的层级结构\"></a>二、作用域链的组成：变量查找的层级结构</h2><p>作用域链由 “嵌套的作用域” 按顺序组成，通常分为以下几层，查找时严格遵循 “从内到外” 的顺序：</p>\n<table>\n<thead>\n<tr>\n<th>层级</th>\n<th>作用域类型</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1️⃣</td>\n<td>局部作用域</td>\n<td>当前执行代码的作用域（如函数内部、<code>if</code>/<code>for</code> 块内）</td>\n<td>函数内用 <code>let</code> 声明的变量</td>\n</tr>\n<tr>\n<td>2️⃣</td>\n<td>父级作用域</td>\n<td>包含当前作用域的外层作用域（如嵌套函数的父函数）</td>\n<td>父函数内的变量</td>\n</tr>\n<tr>\n<td>…</td>\n<td>更多嵌套父级</td>\n<td>层层向外的作用域（如祖父函数、曾祖父函数）</td>\n<td>更外层函数的变量</td>\n</tr>\n<tr>\n<td>🌍</td>\n<td>全局作用域</td>\n<td>最顶层作用域（浏览器中是 <code>window</code>，Node.js 中是 <code>global</code>）</td>\n<td>直接在脚本顶层声明的变量</td>\n</tr>\n</tbody></table>\n<h3 id=\"实际查找过程：按链条顺序查找\"><a href=\"#实际查找过程：按链条顺序查找\" class=\"headerlink\" title=\"实际查找过程：按链条顺序查找\"></a>实际查找过程：按链条顺序查找</h3><p>看一段代码，直观感受变量查找的步骤：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局作用域的变量 🌍</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> globalVar = <span class=\"string\">'我是全局变量'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">outer</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// outer 作用域的变量（父作用域）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> outerVar = <span class=\"string\">'我是外层变量'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">inner</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// inner 作用域的变量（当前作用域）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> innerVar = <span class=\"string\">'我是内层变量'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 变量查找过程：</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(innerVar); <span class=\"comment\">// 1. 先查当前作用域 → 找到，直接使用</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(outerVar); <span class=\"comment\">// 2. 当前作用域没有 → 查父作用域（outer）→ 找到</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globalVar); <span class=\"comment\">// 3. 父作用域没有 → 查全局作用域 → 找到</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(notExistVar); <span class=\"comment\">// 4. 全局作用域也没有 → 抛出 ReferenceError</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">inner</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">outer</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"三、作用域链-vs-执行上下文：别搞混的两个概念\"><a href=\"#三、作用域链-vs-执行上下文：别搞混的两个概念\" class=\"headerlink\" title=\"三、作用域链 vs 执行上下文：别搞混的两个概念\"></a>三、作用域链 vs 执行上下文：别搞混的两个概念</h2><p>很多人会把 “作用域链” 和 “执行上下文” 弄混，其实它们是完全不同的概念 —— 一个是 “静态查找路径”，一个是 “动态执行环境”。</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>作用域链</th>\n<th>执行上下文</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>创建时机</strong></td>\n<td>函数<strong>定义时</strong>（静态固定）</td>\n<td>函数<strong>调用时</strong>（动态创建）</td>\n</tr>\n<tr>\n<td><strong>核心内容</strong></td>\n<td>变量的查找顺序（路径）</td>\n<td>当前执行的代码、<code>this</code> 指向、变量对象等</td>\n</tr>\n<tr>\n<td><strong>是否变化</strong></td>\n<td>不变化（定义后固定）</td>\n<td>每次调用都创建新的执行上下文（动态变化）</td>\n</tr>\n<tr>\n<td><strong>生命周期</strong></td>\n<td>和函数生命周期一致（函数存在则链存在）</td>\n<td>函数执行期间存在，执行完后被销毁</td>\n</tr>\n</tbody></table>\n<p>简单说：<strong>作用域链决定 “变量能在哪里找到”</strong>，而<strong>执行上下文决定 “代码当前如何执行”</strong>。执行上下文会包含作用域链，但作用域链本身是独立的静态结构。</p>\n<h2 id=\"四、ES6-块级作用域：让作用域链更精细\"><a href=\"#四、ES6-块级作用域：让作用域链更精细\" class=\"headerlink\" title=\"四、ES6 块级作用域：让作用域链更精细\"></a>四、ES6 块级作用域：让作用域链更精细</h2><p>ES6 之前，JS 只有 “函数作用域” 和 “全局作用域”，<code>var</code> 声明的变量会 “穿透”<code>if</code>、<code>for</code> 等块级结构。ES6 引入的 <code>let</code>/<code>const</code> 解决了这个问题，带来了 “块级作用域”—— 变量只在 <code>{}</code> 包裹的块内有效，也会加入作用域链。</p>\n<h3 id=\"4-1-块级作用域的影响：变量不再“穿透”\"><a href=\"#4-1-块级作用域的影响：变量不再“穿透”\" class=\"headerlink\" title=\"4.1 块级作用域的影响：变量不再“穿透”\"></a>4.1 块级作用域的影响：变量不再 “穿透”</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"keyword\">let</span> blockVar = <span class=\"string\">'我只在块内有效'</span>; <span class=\"comment\">// let 声明的块级变量</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> funcVar = <span class=\"string\">'我在函数内有效（穿透块）'</span>; <span class=\"comment\">// var 声明的函数级变量</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(funcVar); <span class=\"comment\">// 输出“我在函数内有效（穿透块）”（var 不支持块级）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(blockVar); <span class=\"comment\">// 报错 ReferenceError（let 限制在块内，作用域链找不到）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-2-块级作用域的查找逻辑\"><a href=\"#4-2-块级作用域的查找逻辑\" class=\"headerlink\" title=\"4.2 块级作用域的查找逻辑\"></a>4.2 块级作用域的查找逻辑</h3><p>块级作用域会成为作用域链的一环，查找时同样遵循 “从内到外”：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">blockExample</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> topVar = <span class=\"string\">'顶层变量（函数内）'</span>; <span class=\"comment\">// 函数作用域的变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> innerVar = <span class=\"string\">'块内变量'</span>; <span class=\"comment\">// 块级作用域的变量</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(topVar); <span class=\"comment\">// ✅ 块级作用域 → 函数作用域，找到 topVar</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(innerVar); <span class=\"comment\">// ❌ 函数作用域无法向下查找块级作用域，报错</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">blockExample</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"五、作用域链的实战技巧：优化与封装\"><a href=\"#五、作用域链的实战技巧：优化与封装\" class=\"headerlink\" title=\"五、作用域链的实战技巧：优化与封装\"></a>五、作用域链的实战技巧：优化与封装</h2><h3 id=\"5-1-性能优化：减少作用域链查找次数\"><a href=\"#5-1-性能优化：减少作用域链查找次数\" class=\"headerlink\" title=\"5.1 性能优化：减少作用域链查找次数\"></a>5.1 性能优化：减少作用域链查找次数</h3><p>作用域链层级越深，查找变量的速度越慢。如果某个变量需要频繁访问（比如循环中），可以把它 “缓存” 到当前作用域，减少查找次数。在实际项目中，我经常会用到它来优化代码！</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 优化前：每次循环都要沿作用域链查找全局的 document（层级深，慢）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) {</span><br><span class=\"line\">  <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">`item-<span class=\"subst\">${i}</span>`</span>).<span class=\"property\">style</span>.<span class=\"property\">color</span> = <span class=\"string\">'red'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化后：把全局的 document 缓存到当前作用域（只查找一次，快）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doc = <span class=\"variable language_\">document</span>; <span class=\"comment\">// 一次查找全局作用域，缓存到当前作用域</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) {</span><br><span class=\"line\">  doc.<span class=\"title function_\">getElementById</span>(<span class=\"string\">`item-<span class=\"subst\">${i}</span>`</span>).<span class=\"property\">style</span>.<span class=\"property\">color</span> = <span class=\"string\">'red'</span>; <span class=\"comment\">// 直接访问当前作用域的 doc</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-2-模块模式：用作用域链实现“私有变量”\"><a href=\"#5-2-模块模式：用作用域链实现“私有变量”\" class=\"headerlink\" title=\"5.2 模块模式：用作用域链实现“私有变量”\"></a>5.2 模块模式：用作用域链实现 “私有变量”</h3><p>JS 没有原生的 “私有变量” 语法，但可以通过 “立即执行函数（IIFE）” 创建独立作用域，利用作用域链的 “隔离性” 实现私有变量封装（外部无法访问函数内部变量）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">CounterModule</span> = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量：只能在 IIFE 内部访问（作用域链限制）</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> privateCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 私有函数：同样只能内部访问</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">privateIncrement</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    privateCount++;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 暴露公共接口：外部只能通过这些方法操作私有变量</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> {</span><br><span class=\"line\">    <span class=\"attr\">increment</span>: <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">privateIncrement</span>();</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'当前计数：'</span>, privateCount);</span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"attr\">reset</span>: <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      privateCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'计数已重置'</span>);</span><br><span class=\"line\">    },</span><br><span class=\"line\">  };</span><br><span class=\"line\">})();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用公共接口</span></span><br><span class=\"line\"><span class=\"title class_\">CounterModule</span>.<span class=\"title function_\">increment</span>(); <span class=\"comment\">// 输出“当前计数：1”</span></span><br><span class=\"line\"><span class=\"title class_\">CounterModule</span>.<span class=\"title function_\">increment</span>(); <span class=\"comment\">// 输出“当前计数：2”</span></span><br><span class=\"line\"><span class=\"title class_\">CounterModule</span>.<span class=\"title function_\">reset</span>(); <span class=\"comment\">// 输出“计数已重置”</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试访问私有变量：无法找到（作用域链不包含 IIFE 内部）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">CounterModule</span>.<span class=\"property\">privateCount</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"六、常见陷阱：避开作用域链的坑\"><a href=\"#六、常见陷阱：避开作用域链的坑\" class=\"headerlink\" title=\"六、常见陷阱：避开作用域链的坑\"></a>六、常见陷阱：避开作用域链的坑</h2><h3 id=\"6-1-循环中的变量问题（var-vs-let）\"><a href=\"#6-1-循环中的变量问题（var-vs-let）\" class=\"headerlink\" title=\"6.1 循环中的变量问题（var vs let）\"></a>6.1 循环中的变量问题（var vs let）</h3><p>ES6 之前用 <code>var</code> 声明循环变量，会因 <code>var</code> 没有块级作用域导致 “所有回调共享同一个变量”；用 <code>let</code> 则会为每次循环创建独立的块级作用域，解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 问题代码（var 无块级作用域）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) {</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 输出 3、3、3（所有回调共享全局的 i，循环结束后 i=3）</span></span><br><span class=\"line\">  }, <span class=\"number\">100</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解决方案1：用 let 创建块级作用域</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) {</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 输出 0、1、2（每次循环有独立的 i）</span></span><br><span class=\"line\">  }, <span class=\"number\">100</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解决方案2：ES5 兼容方案（立即执行函数创建作用域）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) {</span><br><span class=\"line\">  (<span class=\"keyword\">function</span> (<span class=\"params\">j</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// j 是每次循环的 i 的副本，存在独立作用域</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(j); <span class=\"comment\">// 输出 0、1、2</span></span><br><span class=\"line\">    }, <span class=\"number\">100</span>);</span><br><span class=\"line\">  })(i);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"6-2-变量遮蔽（Variable-Shadowing）\"><a href=\"#6-2-变量遮蔽（Variable-Shadowing）\" class=\"headerlink\" title=\"6.2 变量遮蔽（Variable Shadowing）\"></a>6.2 变量遮蔽（Variable Shadowing）</h3><p>如果内层作用域的变量名和外层作用域一致，内层变量会 “遮蔽” 外层变量（查找时找到内层变量后就停止，不会继续向上找）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">'全局消息'</span>; <span class=\"comment\">// 外层变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">showMessage</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> message = <span class=\"string\">'局部消息'</span>; <span class=\"comment\">// 内层变量，遮蔽外层的 message</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message); <span class=\"comment\">// 输出“局部消息”（找到内层变量后停止查找）</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">showMessage</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message); <span class=\"comment\">// 输出“全局消息”（外层变量未被影响）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<div class=\"note warning flat\"><p><strong>注意：</strong> 遮蔽是 “暂时性” 的，只影响内层作用域的查找，不会修改外层变量。</p>\n</div>\n\n<h2 id=\"七、作用域链与内存管理：避免内存泄漏\"><a href=\"#七、作用域链与内存管理：避免内存泄漏\" class=\"headerlink\" title=\"七、作用域链与内存管理：避免内存泄漏\"></a>七、作用域链与内存管理：避免内存泄漏</h2><h3 id=\"7-1-作用域链与垃圾回收\"><a href=\"#7-1-作用域链与垃圾回收\" class=\"headerlink\" title=\"7.1 作用域链与垃圾回收\"></a>7.1 作用域链与垃圾回收</h3><p>JS 的垃圾回收机制（GC）会回收 “不再被引用的变量”。如果作用域链断裂（比如函数执行完后，没有闭包引用其内部变量），作用域内的变量就会被 GC 清理。</p>\n<p>流程如下：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  graph TD\nA[变量不再被任何作用域引用] --&gt; B[作用域链对该变量的引用断开]\nB --&gt; C[GC 标记该变量为“可回收”]\nC --&gt; D[内存被释放]\n  </pre></div>\n\n<h3 id=\"7-2-常见内存泄漏场景\"><a href=\"#7-2-常见内存泄漏场景\" class=\"headerlink\" title=\"7.2 常见内存泄漏场景\"></a>7.2 常见内存泄漏场景</h3><h4 id=\"（1）意外创建全局变量\"><a href=\"#（1）意外创建全局变量\" class=\"headerlink\" title=\"（1）意外创建全局变量\"></a>（1）意外创建全局变量</h4><p>忘记用 <code>var</code>/<code>let</code>/<code>const</code> 声明变量，变量会自动成为全局变量，挂载到 <code>window</code> 上，作用域链一直包含它，导致无法回收：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLeak</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 错误：忘记写 let，leak 成为全局变量</span></span><br><span class=\"line\">  leak = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"number\">1000000</span>).<span class=\"title function_\">fill</span>(<span class=\"string\">'大量数据'</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">createLeak</span>(); <span class=\"comment\">// 执行后，leak 一直存在于全局作用域，无法被 GC 回收</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"（2）闭包导致的内存泄漏\"><a href=\"#（2）闭包导致的内存泄漏\" class=\"headerlink\" title=\"（2）闭包导致的内存泄漏\"></a>（2）闭包导致的内存泄漏</h4><p>如果闭包长期被引用（比如挂载到全局），它引用的外层变量（即使很大）也会一直存在于作用域链中，无法回收：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createBigClosure</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 大数组：占用大量内存</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hugeArray = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"number\">1000000</span>).<span class=\"title function_\">fill</span>(<span class=\"string\">'我是大数据'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 闭包：引用了 hugeArray</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(hugeArray.<span class=\"property\">length</span>);</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 闭包被全局变量引用，导致 hugeArray 一直存在于作用域链</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> globalClosure = <span class=\"title function_\">createBigClosure</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote>\n<p>解决办法：不再需要闭包时，手动将其设为 <code>null</code>（<code>globalClosure = null</code>），断开引用，让 GC 能回收 <code>hugeArray</code>。</p>\n</blockquote>\n<hr>\n<p>作用域链是 JS 变量查找的 “底层规则”，理解它不仅能帮你避开 “变量找不到”“变量值不对” 的坑，还能让你更清晰地理解闭包、模块模式等高级特性。<br>记住核心：<strong>作用域链是静态的，定义时确定；查找时从内到外，找到即停</strong> —— 掌握这个规则，就能轻松驾驭 JS 的变量访问逻辑！</p>\n",
            "tags": [
                "JavaScript",
                "性能优化"
            ]
        }
    ]
}