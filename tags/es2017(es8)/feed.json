{
    "version": "https://jsonfeed.org/version/1",
    "title": "Touko • All posts by \"es2017(es8)\" tag",
    "description": "这是一个博客网站，记录我的学习和生活点滴。",
    "home_page_url": "http://toukoxu.github.io",
    "items": [
        {
            "id": "http://toukoxu.github.io/archives/async+await/",
            "url": "http://toukoxu.github.io/archives/async+await/",
            "title": "Async / Await：用同步的方式写异步，真香！",
            "date_published": "2024-07-13T12:46:25.000Z",
            "content_html": "<blockquote>\n<p>async/await 是 ES2017 引入的强大特性，使得处理异步操作变得更加简单和直观。使用 async 声明的函数总是返回一个 Promise，而 await 关键字则像是它的指挥棒，允许你暂停函数的执行，直到 Promise 被解决或拒绝。这种方式让异步代码看起来更像同步代码，从而提高了可读性和可维护性。尤其在处理链式异步操作和错误捕获时，async/await 显示出其独特的优势。</p>\n</blockquote>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>如果对生成器函数和 yield 不太熟悉，可以先看看下面这篇，了解基础后再看 Async / Await 会更顺～</p>\n<div calss=\"anzhiyu-tag-link\"><a class=\"tag-Link\" target=\"_blank\" href=\"/2024/07/11/generator\">\n    <div class=\"tag-link-tips\">站内地址</div>\n    <div class=\"tag-link-bottom\">\n        <div class=\"tag-link-left\" style=\"background-image: url(/img/512.png)\">\n          <i class=\"anzhiyufont anzhiyu-icon-link\" style=\"display: none\"></i>\n        </div>\n        <div class=\"tag-link-right\">\n            <div class=\"tag-link-title\">生成器函数与 yield</div>\n            <div class=\"tag-link-sitename\"> Touko</div>\n        </div>\n        <i class=\"anzhiyufont anzhiyu-icon-angle-right\"></i>\n    </div>\n    </a></div>\n\n<h2 id=\"一、Async-Await-的本质：老熟人的默契配合\"><a href=\"#一、Async-Await-的本质：老熟人的默契配合\" class=\"headerlink\" title=\"一、Async/Await 的本质：老熟人的默契配合\"></a>一、Async / Await 的本质：老熟人的默契配合</h2><p>你可能觉得 Async / Await 是 JavaScript 里的 “新黑科技”，但其实它的底层是三个老熟人在搭班子干活。说穿了，就是把咱们早就眼熟的技术组合得更顺手了。</p>\n<h3 id=\"1-1-三大核心组件\"><a href=\"#1-1-三大核心组件\" class=\"headerlink\" title=\"1.1 三大核心组件\"></a>1.1 三大核心组件</h3><ul>\n<li><strong>Generator（生成器）</strong>：提供<strong>暂停 - 恢复</strong>的能力，就像给函数装了个暂停键</li>\n<li><strong>Promise</strong>：处理<strong>异步操作</strong>的 “标准接口”，负责管理异步结果</li>\n<li><strong>自动执行器</strong>：默默工作的<strong>调度员</strong>，悄悄驱动生成器跑完全程</li>\n</ul>\n<h3 id=\"1-2-从代码看转换逻辑\"><a href=\"#1-2-从代码看转换逻辑\" class=\"headerlink\" title=\"1.2 从代码看转换逻辑\"></a>1.2 从代码看转换逻辑</h3><p>咱们写的 Async 函数，其实会被引擎偷偷转换成类似生成器的结构。比如这样一段代码：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 咱们写的优雅代码</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> api.<span class=\"title function_\">get</span>(<span class=\"string\">'/data'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">process</span>(data);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>引擎背地里会把它转成差不多这样（简化版）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引擎实际处理的样子</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// spawn就是那个自动执行器，负责驱动生成器</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">spawn</span>(<span class=\"keyword\">function</span>* () {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">yield</span> api.<span class=\"title function_\">get</span>(<span class=\"string\">'/data'</span>); <span class=\"comment\">// 用yield代替await</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">process</span>(data);</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<div class=\"note info flat\"><p><strong>这里有个小细节：</strong> 每个 Async 函数都被转换成一个生成器函数，由<mark>自动执行器</mark>接管执行！</p>咱们不用手动调用<code>next()</code>，全是执行器在后台搞定，这也是<code>Async/Await</code>比直接用<code>Generator</code>方便的地方～</div>\n\n<h2 id=\"二、自动执行器：幕后的引擎\"><a href=\"#二、自动执行器：幕后的引擎\" class=\"headerlink\" title=\"二、自动执行器：幕后的引擎\"></a>二、自动执行器：幕后的引擎</h2><p>自动执行器是 Async / Await 能自动跑起来的关键，我试着简化了它的核心代码，大概长这样：</p>\n<h3 id=\"2-1-核心逻辑（简化版）\"><a href=\"#2-1-核心逻辑（简化版）\" class=\"headerlink\" title=\"2.1 核心逻辑（简化版）\"></a>2.1 核心逻辑（简化版）</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">spawn</span>(<span class=\"params\">generatorFunc</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个Promise，这也是async函数总返回Promise的原因</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> generator = <span class=\"title function_\">generatorFunc</span>(); <span class=\"comment\">// 创建生成器实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 步进函数：驱动生成器一步步执行</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">step</span>(<span class=\"params\">nextFn</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">try</span> {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> { value, done } = <span class=\"title function_\">nextFn</span>(); <span class=\"comment\">// 执行到下一个yield</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (done) {</span><br><span class=\"line\">          <span class=\"comment\">// 生成器跑完了，把结果传给Promise</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把yield后的结果包装成Promise（不管是不是Promise）</span></span><br><span class=\"line\">        <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(value).<span class=\"title function_\">then</span>(</span><br><span class=\"line\">          <span class=\"comment\">// 成功了就把结果传给下一次next()，继续执行</span></span><br><span class=\"line\">          <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"title function_\">next</span>(v)),</span><br><span class=\"line\">          <span class=\"comment\">// 失败了就把错误抛回生成器，让try/catch接住</span></span><br><span class=\"line\">          <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"keyword\">throw</span>(e))</span><br><span class=\"line\">        );</span><br><span class=\"line\">      } <span class=\"keyword\">catch</span> (e) {</span><br><span class=\"line\">        <span class=\"comment\">// 捕获生成器内部的错误</span></span><br><span class=\"line\">        <span class=\"title function_\">reject</span>(e);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 启动生成器</span></span><br><span class=\"line\">    <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"title function_\">next</span>());</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"2-2-执行过程图解\"><a href=\"#2-2-执行过程图解\" class=\"headerlink\" title=\"2.2 执行过程图解\"></a>2.2 执行过程图解</h3><p>我画了个流程图帮大家理解，其实就是执行器在中间当 “裁判”，协调生成器和异步操作：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  sequenceDiagram\nparticipant 调用者\nparticipant Async 函数\nparticipant 执行器\nparticipant 生成器\n\n    调用者-&gt;&gt;Async函数: 调用 asyncFunc()\n    Async函数-&gt;&gt;执行器: “麻烦帮我跑一下这个生成器”\n    执行器-&gt;&gt;生成器: “开始执行咯（调用next()）”\n    生成器--&gt;&gt;执行器: “遇到await了，先停在这”（返回yield的值）\n    执行器-&gt;&gt;Promise: “等你结果出来喊我”\n    Promise--&gt;&gt;执行器: “搞定，结果在这”\n    执行器-&gt;&gt;生成器:  “继续跑吧，这是刚才的结果”（调用next(结果)）\n    生成器--&gt;&gt;执行器: “跑完了，这是最终结果”\n    执行器-&gt;&gt;调用者: “任务完成，给你结果”（Promise resolved）\n\n  </pre></div>\n\n<p>简单说就是：执行器启动生成器后，每次遇到 yield（也就是咱们写的 await）就停下来等异步结果，拿到结果再叫醒生成器继续跑，直到结束。全程不用手动干预，比直接用 Generator 省太多事了～</p>\n<h2 id=\"三、await-到底做了什么？四步看懂它的“小动作”\"><a href=\"#三、await-到底做了什么？四步看懂它的“小动作”\" class=\"headerlink\" title=\"三、await 到底做了什么？四步看懂它的“小动作”\"></a>三、await 到底做了什么？四步看懂它的 “小动作”</h2><p>每次写<code>await</code>的时候，引擎其实在背后干了四件事，我拆开来给大家说说：</p>\n<ol>\n<li><strong>暂停当前函数</strong>：就像按了暂停键，当前的变量、执行位置都被 “冻” 起来</li>\n<li><strong>包装异步结果</strong>：不管 await 后面是 Promise 还是普通值（比如 await 42），都会被转成 Promise。普通值会被 Promise.resolve() 包一层，确保统一用 Promise 处理</li>\n<li><strong>注册回调</strong>：把 await 后面的代码（比如拿到 data 后处理的逻辑）打包成一个微任务，注册到事件循环里</li>\n<li><strong>让出主线程</strong>：当前函数暂停后，主线程会去执行其他任务（比如渲染、处理其他事件），等 Promise 有结果了，再回头执行刚才打包的微任务</li>\n</ol>\n<div class=\"note info flat\"><p><strong>这里有个性能小细节：</strong> <code>await</code>不会阻塞主线程！它只是把后续代码挂起（包装成<mark>微任务</mark>），让主线程先忙别的。这也是为什么用<code>await</code>的时候，页面不会卡 —— 因为它会主动 “让道”。</p>\n</div>\n\n<h2 id=\"四、错误处理：try-catch-居然能管到异步操作？\"><a href=\"#四、错误处理：try-catch-居然能管到异步操作？\" class=\"headerlink\" title=\"四、错误处理：try/catch 居然能管到异步操作？\"></a>四、错误处理：try / catch 居然能管到异步操作？</h2><p>这是我觉得 Async/Await 最方便的一点：用同步代码里的 try/catch 就能搞定异步错误，不用像回调那样嵌套多层 error 处理。</p>\n<h3 id=\"4-1-同步式的错误处理\"><a href=\"#4-1-同步式的错误处理\" class=\"headerlink\" title=\"4.1 同步式的错误处理\"></a>4.1 同步式的错误处理</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchUser</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">'/user'</span>); <span class=\"comment\">// 可能失败</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> posts = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">`/posts/<span class=\"subst\">${user.id}</span>`</span>); <span class=\"comment\">// 依赖上一步结果，也可能失败</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> { user, posts };</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">    <span class=\"comment\">// 不管哪一步失败，都会跑到这里</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">'请求失败:'</span>, error);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> { <span class=\"attr\">user</span>: <span class=\"literal\">null</span>, <span class=\"attr\">posts</span>: [] };</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-2-背后的错误传递\"><a href=\"#4-2-背后的错误传递\" class=\"headerlink\" title=\"4.2 背后的错误传递\"></a>4.2 背后的错误传递</h3><p>为什么 try / catch 能抓到异步错误？秘密在自动执行器的这段代码里：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自动执行器处理Promise的部分</span></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(value).<span class=\"title function_\">then</span>(</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"title function_\">next</span>(v)), <span class=\"comment\">// 成功就传结果继续执行</span></span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"keyword\">throw</span>(e)) <span class=\"comment\">// 失败就把错误抛回生成器！</span></span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>当 await 后面的 Promise 失败时，执行器会调用<code>generator.throw(e)</code>，把错误 “扔回” 生成器函数内部。这时候生成器里的 try / catch 就会像捕获同步错误一样，把这个异步错误接住。</p>\n<blockquote>\n<p>之前用回调的时候，每次异步操作都要单独写 error 处理，现在一个 try / catch 全搞定，代码清爽多了～</p>\n</blockquote>\n<h2 id=\"五、性能优化：我在项目里掉过的性能坑\"><a href=\"#五、性能优化：我在项目里掉过的性能坑\" class=\"headerlink\" title=\"五、性能优化：我在项目里掉过的性能坑\"></a>五、性能优化：我在项目里掉过的性能坑</h2><p>分享几个我实际开发中遇到的问题，都是关于 Async / Await 性能的，新手很容易踩坑：</p>\n<h3 id=\"5-1-坑一：没必要的顺序执行\"><a href=\"#5-1-坑一：没必要的顺序执行\" class=\"headerlink\" title=\"5.1 坑一：没必要的顺序执行\"></a>5.1 坑一：没必要的顺序执行</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反面例子：两个请求本来可以同时跑，却写成了顺序执行</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">slowFetch</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"keyword\">await</span> <span class=\"title function_\">fetchA</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = <span class=\"keyword\">await</span> <span class=\"title function_\">fetchB</span>(); <span class=\"comment\">// 等A完了才开始B</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> [a, b];</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这两个请求如果没依赖关系（比如 A 不影响 B 的参数），完全可以同时启动，我后来改成这样：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 优化后：同时启动两个请求，总耗时是最慢那个的时间</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fastFetch</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 先同时发起请求，拿到两个Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> promiseA = <span class=\"title function_\">fetchA</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promiseB = <span class=\"title function_\">fetchB</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 再等它们结果</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"keyword\">await</span> promiseA;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = <span class=\"keyword\">await</span> promiseB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> [a, b];</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-2-坑二：多余的-await-包装\"><a href=\"#5-2-坑二：多余的-await-包装\" class=\"headerlink\" title=\"5.2 坑二：多余的 await 包装\"></a>5.2 坑二：多余的 await 包装</h3><p>有时候会下意识地在 return 前面加 await，但其实没必要：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 多余的await</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getData</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"title function_\">fetchData</span>(); <span class=\"comment\">// fetchData本身已经返回Promise</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>因为 Async 函数会自动把返回值包成 Promise，这里的 await 纯属多此一举，直接 return 就行：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更简洁高效</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getData</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">fetchData</span>(); <span class=\"comment\">// 等价于上面的写法，但少一层Promise包装</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-3-多个异步操作：用-Promise-all-处理并行\"><a href=\"#5-3-多个异步操作：用-Promise-all-处理并行\" class=\"headerlink\" title=\"5.3 多个异步操作：用 Promise.all()处理并行\"></a>5.3 多个异步操作：用 Promise.all() 处理并行</h3><p>如果需要等多个异步操作都完成，<code>Promise.all()</code>配合 await 是绝配，下面的写法在实际项目中会经常用到哦~</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchAll</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 同时启动，等所有请求完成</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [user, posts] = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([<span class=\"title function_\">fetch</span>(<span class=\"string\">'/user'</span>), <span class=\"title function_\">fetch</span>(<span class=\"string\">'/posts'</span>)]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> { user, posts };</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<div class=\"note warning flat\"><p><strong>不过要注意：</strong> <code>Promise.all()</code>是 “一损俱损”，只要有一个请求失败，整个就会报错，这时候可以用<code>Promise.allSettled()</code>处理需要全部结果的场景（哪怕部分失败）。</p>\n</div>\n\n<h3 id=\"5-4-高级技巧：模块里的顶级-await\"><a href=\"#5-4-高级技巧：模块里的顶级-await\" class=\"headerlink\" title=\"5.4 高级技巧：模块里的顶级 await\"></a>5.4 高级技巧：模块里的顶级 await</h3><p>现在很多打包工具（比如 Webpack、Vite）已经支持模块顶层的 await 了，不用再包在 Async 函数里：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接在模块顶层用await</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = <span class=\"keyword\">await</span> <span class=\"title function_\">loadConfig</span>(); <span class=\"comment\">// 加载配置</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> settings = <span class=\"title function_\">process</span>(config);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其实引擎会把模块转成类似这样</span></span><br><span class=\"line\"><span class=\"title function_\">loadConfig</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">config</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">const</span> settings = <span class=\"title function_\">process</span>(config);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在做一个工具库的时候用过这个，用来加载动态配置，比以前用 IIFE（立即执行函数）清爽多了。</p>\n<h2 id=\"六、Async-Await-实战场景：这些地方用起来超顺手\"><a href=\"#六、Async-Await-实战场景：这些地方用起来超顺手\" class=\"headerlink\" title=\"六、Async/Await 实战场景：这些地方用起来超顺手\"></a>六、Async / Await 实战场景：这些地方用起来超顺手</h2><h3 id=\"6-1-异步初始化（比如数据库连接）\"><a href=\"#6-1-异步初始化（比如数据库连接）\" class=\"headerlink\" title=\"6.1 异步初始化（比如数据库连接）\"></a>6.1 异步初始化（比如数据库连接）</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Database</span> {</span><br><span class=\"line\">  <span class=\"comment\">// 静态方法做异步初始化</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">init</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> connection = <span class=\"keyword\">await</span> <span class=\"title function_\">createConnection</span>(); <span class=\"comment\">// 建立连接（异步）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Database</span>(connection);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用的时候直接await</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> db = <span class=\"keyword\">await</span> <span class=\"title class_\">Database</span>.<span class=\"title function_\">init</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这种场景如果用回调，很容易写成嵌套的 init 回调，用 Async / Await 就清晰多了。</p>\n<h3 id=\"6-2-有依赖关系的顺序请求\"><a href=\"#6-2-有依赖关系的顺序请求\" class=\"headerlink\" title=\"6.2 有依赖关系的顺序请求\"></a>6.2 有依赖关系的顺序请求</h3><p>比如先拿用户 ID，再用 ID 查订单：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">purchase</span>(<span class=\"params\">itemId</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> <span class=\"title function_\">getUser</span>(); <span class=\"comment\">// 先查用户</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> item = <span class=\"keyword\">await</span> <span class=\"title function_\">getItem</span>(itemId); <span class=\"comment\">// 再查商品</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">validatePurchase</span>(user, item); <span class=\"comment\">// 验证能否购买（异步）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> receipt = <span class=\"keyword\">await</span> <span class=\"title function_\">createReceipt</span>(user, item); <span class=\"comment\">// 生成订单</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> receipt;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>步骤再复杂，用顺序 await 写出来也像同步代码一样好懂。</p>\n<h3 id=\"6-3-带重试的请求\"><a href=\"#6-3-带重试的请求\" class=\"headerlink\" title=\"6.3 带重试的请求\"></a>6.3 带重试的请求</h3><p>处理可能偶尔失败的接口时，用 Async / Await 写重试逻辑很直观：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchWithRetry</span>(<span class=\"params\">url, retries = <span class=\"number\">3</span></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retries &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> error; <span class=\"comment\">// 重试次数用完</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">delay</span>(<span class=\"number\">1000</span>); <span class=\"comment\">// 等1秒再重试</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">fetchWithRetry</span>(url, retries - <span class=\"number\">1</span>); <span class=\"comment\">// 递归重试</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在对接一个不稳定的第三方接口时，就用这个逻辑做了重试，成功率提高了不少。</p>\n<h3 id=\"6-4-超时控制（防止请求卡太久）\"><a href=\"#6-4-超时控制（防止请求卡太久）\" class=\"headerlink\" title=\"6.4 超时控制（防止请求卡太久）\"></a>6.4 超时控制（防止请求卡太久）</h3><p>结合<code>Promise.race()</code>实现超时控制：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchWithTimeout</span>(<span class=\"params\">url, timeout = <span class=\"number\">5000</span></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchPromise = <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">  <span class=\"comment\">// 超时Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> timeoutPromise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">_, reject</span>) =&gt;</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">reject</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">'请求超时'</span>)), timeout)</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 谁先完成就用谁的结果</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">race</span>([fetchPromise, timeoutPromise]);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这个在做支付回调的时候特别有用，防止因为网络问题让用户一直等。</p>\n<h2 id=\"七、踩过的坑：这些细节要注意\"><a href=\"#七、踩过的坑：这些细节要注意\" class=\"headerlink\" title=\"七、踩过的坑：这些细节要注意\"></a>七、踩过的坑：这些细节要注意</h2><h3 id=\"7-1-箭头函数的-this-陷阱\"><a href=\"#7-1-箭头函数的-this-陷阱\" class=\"headerlink\" title=\"7.1 箭头函数的 this 陷阱\"></a>7.1 箭头函数的 this 陷阱</h3><p>用 Async 箭头函数当对象方法时，<code>this</code>会丢：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有问题：this指向不对</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">  <span class=\"attr\">print</span>: <span class=\"title function_\">async</span> () =&gt; {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>); <span class=\"comment\">// undefined! 因为箭头函数的this是定义时的上下文</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确写法：用传统函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"title function_\">print</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>); <span class=\"comment\">// 42，this指向obj</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在写一个类的方法时犯过这个错，调试了半天才发现是箭头函数的锅。</p>\n<h3 id=\"7-2-控制并发数量\"><a href=\"#7-2-控制并发数量\" class=\"headerlink\" title=\"7.2 控制并发数量\"></a>7.2 控制并发数量</h3><p>如果并行请求太多（比如一次发 20 个接口），可能会触发浏览器的并发限制，这时候需要控制并发数：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">processBatch</span>(<span class=\"params\">items</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = items.<span class=\"title function_\">map</span>(processItem); <span class=\"comment\">// 所有任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 控制最多同时跑5个</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> results = <span class=\"keyword\">await</span> <span class=\"title function_\">throttlePromises</span>(promises, <span class=\"number\">5</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这里的<code>throttlePromises</code>是一个工具函数，原理是把任务分成多批，一批批执行（每批 5 个），避免一次性发起太多请求。</p>\n<h3 id=\"7-3-可取消的异步任务（结合-AbortSignal）\"><a href=\"#7-3-可取消的异步任务（结合-AbortSignal）\" class=\"headerlink\" title=\"7.3 可取消的异步任务（结合 AbortSignal）\"></a>7.3 可取消的异步任务（结合 AbortSignal）</h3><p>有时候需要中途取消异步操作（比如用户离开页面），可以用<code>AbortSignal</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">longRunningTask</span>(<span class=\"params\">abortSignal</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!abortSignal.<span class=\"property\">aborted</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">doWork</span>();<span class=\"comment\">// 每次做一点工作</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每次循环检查退出信号</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (abortSignal.<span class=\"property\">aborted</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"title function_\">cleanup</span>(); <span class=\"comment\">// 做清理工作</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> controller = <span class=\"keyword\">new</span> <span class=\"title class_\">AbortController</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> signal = controller.<span class=\"property\">signal</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动长时间运行的任务</span></span><br><span class=\"line\"><span class=\"title function_\">longRunningTask</span>(signal);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> cancelTask {</span><br><span class=\"line\">  controller.<span class=\"title function_\">abort</span>(); <span class=\"comment\">// 中止任务</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置一个定时器，以便在 3 秒后中止任务</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  <span class=\"title function_\">cancelTask</span>();</span><br><span class=\"line\">}, <span class=\"number\">3000</span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在做一个文件上传组件时用过这个，用户点取消按钮时，就通过<code>AbortSignal</code>终止上传。</p>\n<h2 id=\"八、常见问题解答（我当初学的时候也纠结过）\"><a href=\"#八、常见问题解答（我当初学的时候也纠结过）\" class=\"headerlink\" title=\"八、常见问题解答（我当初学的时候也纠结过）\"></a>八、常见问题解答（我当初学的时候也纠结过）</h2><h3 id=\"Q1-Async-函数会阻塞主线程吗？\"><a href=\"#Q1-Async-函数会阻塞主线程吗？\" class=\"headerlink\" title=\"Q1: Async 函数会阻塞主线程吗？\"></a>Q1: Async 函数会阻塞主线程吗？</h3><p><strong>不会！</strong> Async 函数遇到 await 时会<strong>暂停并释放主线程</strong>，JavaScript 的单线程模型通过事件循环实现异步执行。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'开始'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">delay</span>(<span class=\"number\">1000</span>); <span class=\"comment\">// 假设delay是个等待1秒的Promise</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'结束'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行到 await 时，函数会暂停，主线程可以去处理其他任务（比如点击事件、渲染），等 1 秒后才回头执行 console.log(‘结束’)，所以不会卡页面。</p>\n<h3 id=\"Q2-可以-await-一个非-Promise-值吗？\"><a href=\"#Q2-可以-await-一个非-Promise-值吗？\" class=\"headerlink\" title=\"Q2: 可以 await 一个非 Promise 值吗？\"></a>Q2: 可以 await 一个非 Promise 值吗？</h3><p><strong>可以！</strong> 引擎会自动用 <code>Promise.resolve()</code> 包装非 Promise 值：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getNumber</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> num = <span class=\"keyword\">await</span> <span class=\"number\">42</span>; <span class=\"comment\">// 合法！等价于 await Promise.resolve(42)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>不过实际开发中很少这么用，一般 await 后面都是异步操作返回的 Promise。</p>\n<h3 id=\"Q3-为什么-Async-函数不管-return-什么，最后都返回-Promise？\"><a href=\"#Q3-为什么-Async-函数不管-return-什么，最后都返回-Promise？\" class=\"headerlink\" title=\"Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？\"></a>Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？</h3><p>因为它本质是异步操作的包装器。哪怕你 return 一个原始值，引擎也会用 Promise.resolve() 包一层：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">answer</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">42</span>; <span class=\"comment\">// 等价于 return Promise.resolve(42)</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>所以调用 Async 函数时，必须用<code>await</code>或者<code>.then()</code>才能拿到结果。</p>\n<h3 id=\"Q4-用-Promise-all-的时候，如果有一个请求失败怎么办？\"><a href=\"#Q4-用-Promise-all-的时候，如果有一个请求失败怎么办？\" class=\"headerlink\" title=\"Q4: 用 Promise.all()的时候，如果有一个请求失败怎么办？\"></a>Q4: 用 Promise.all() 的时候，如果有一个请求失败怎么办？</h3><p>之前已经提到过了，Promise.all() 会 “快速失败”—— 只要有一个 Promise 被拒绝，整个 Promise.all() 就会立刻失败，进入 catch。如果需要等所有请求完成（不管成功失败），可以用<code>Promise.allSettled()</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchAll</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> results = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">allSettled</span>([<span class=\"title function_\">fetchA</span>(), <span class=\"title function_\">fetchB</span>()]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 过滤出成功的结果</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> successData = results.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> r.<span class=\"property\">status</span> === <span class=\"string\">'fulfilled'</span>).<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> r.<span class=\"property\">value</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Q5-为什么说-Async-Await-比回调好？\"><a href=\"#Q5-为什么说-Async-Await-比回调好？\" class=\"headerlink\" title=\"Q5: 为什么说 Async/Await 比回调好？\"></a>Q5: 为什么说 Async / Await 比回调好？</h3><p>我总结了几个实际开发中的感受：</p>\n<ul>\n<li>代码不嵌套，扁平结构更易读（告别 “回调地狱”）</li>\n<li>错误处理统一用 try / catch，不用每层回调都写 error 处理</li>\n<li>逻辑顺序和代码执行顺序一致，不用跳来跳去看代码</li>\n<li>调试更方便，错误堆栈更完整（回调的堆栈经常被异步操作打断）</li>\n</ul>\n<hr>\n<p>其实 Async/Await 不算什么高深的技术，就是把 Generator、Promise 这些老东西包装得更好用了。但正是这种 “语法糖”，让我们写异步代码时能少掉很多头发～ 如果你也有过用 Async/Await 踩坑的经历，欢迎在评论区分享呀！</p>\n",
            "tags": [
                "JavaScript",
                "ES2017(ES8)",
                "性能优化"
            ]
        }
    ]
}