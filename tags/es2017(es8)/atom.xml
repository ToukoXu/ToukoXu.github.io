<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://toukoxu.github.io</id>
    <title>Touko • Posts by &#34;es2017(es8)&#34; tag</title>
    <link href="http://toukoxu.github.io" />
    <updated>2024-07-13T12:46:25.000Z</updated>
    <category term="JavaScript" />
    <category term="ES2017(ES8)" />
    <category term="性能优化" />
    <category term="ES6" />
    <entry>
        <id>http://toukoxu.github.io/archives/async+await/</id>
        <title>Async / Await：用同步的方式写异步，真香！</title>
        <link rel="alternate" href="http://toukoxu.github.io/archives/async+await/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;async/await 是 ES2017 引入的强大特性，使得处理异步操作变得更加简单和直观。使用 async 声明的函数总是返回一个 Promise，而 await 关键字则像是它的指挥棒，允许你暂停函数的执行，直到 Promise 被解决或拒绝。这种方式让异步代码看起来更像同步代码，从而提高了可读性和可维护性。尤其在处理链式异步操作和错误捕获时，async/await 显示出其独特的优势。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;前置知识&#34;&gt;&lt;a href=&#34;#前置知识&#34; class=&#34;headerlink&#34; title=&#34;前置知识&#34;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;p&gt;如果对生成器函数和 yield 不太熟悉，可以先看看下面这篇，了解基础后再看 Async / Await 会更顺～&lt;/p&gt;
&lt;div&gt;&lt;a class=&#34;tag-Link&#34; target=&#34;_blank&#34; href=&#34;/archives/generator&#34;&gt;
    &lt;div class=&#34;tag-link-bottom&#34;&gt;
        &lt;div class=&#34;tag-link-left&#34; style=&#34;background-image: url(/img/512.png)&#34;&gt;
          &lt;i class=&#34;anzhiyufont anzhiyu-icon-link&#34; style=&#34;display: none&#34;&gt;&lt;/i&gt;
        &lt;/div&gt;
        &lt;div class=&#34;tag-link-right&#34;&gt;
            &lt;div class=&#34;tag-link-title&#34;&gt;生成器函数与 yield&lt;/div&gt;
            &lt;div class=&#34;tag-link-sitename&#34;&gt; Touko&lt;/div&gt;
        &lt;/div&gt;
        &lt;i class=&#34;anzhiyufont anzhiyu-icon-angle-right&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;/a&gt;&lt;/div&gt;

&lt;h2 id=&#34;一、Async-Await-的本质：老熟人的默契配合&#34;&gt;&lt;a href=&#34;#一、Async-Await-的本质：老熟人的默契配合&#34; class=&#34;headerlink&#34; title=&#34;一、Async/Await 的本质：老熟人的默契配合&#34;&gt;&lt;/a&gt;一、Async / Await 的本质：老熟人的默契配合&lt;/h2&gt;&lt;p&gt;你可能觉得 Async / Await 是 JavaScript 里的 “新黑科技”，但其实它的底层是三个老熟人在搭班子干活。说穿了，就是把咱们早就眼熟的技术组合得更顺手了。&lt;/p&gt;
&lt;h3 id=&#34;1-1-三大核心组件&#34;&gt;&lt;a href=&#34;#1-1-三大核心组件&#34; class=&#34;headerlink&#34; title=&#34;1.1 三大核心组件&#34;&gt;&lt;/a&gt;1.1 三大核心组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Generator（生成器）&lt;/strong&gt;：提供&lt;strong&gt;暂停 - 恢复&lt;/strong&gt;的能力，就像给函数装了个暂停键&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Promise&lt;/strong&gt;：处理&lt;strong&gt;异步操作&lt;/strong&gt;的 “标准接口”，负责管理异步结果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动执行器&lt;/strong&gt;：默默工作的&lt;strong&gt;调度员&lt;/strong&gt;，悄悄驱动生成器跑完全程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-从代码看转换逻辑&#34;&gt;&lt;a href=&#34;#1-2-从代码看转换逻辑&#34; class=&#34;headerlink&#34; title=&#34;1.2 从代码看转换逻辑&#34;&gt;&lt;/a&gt;1.2 从代码看转换逻辑&lt;/h3&gt;&lt;p&gt;咱们写的 Async 函数，其实会被引擎偷偷转换成类似生成器的结构。比如这样一段代码：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 咱们写的优雅代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchData&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; data = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; api.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;/data&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;process&lt;/span&gt;(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;引擎背地里会把它转成差不多这样（简化版）：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 引擎实际处理的样子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchData&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// spawn就是那个自动执行器，负责驱动生成器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;spawn&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt;* () {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; data = &lt;span class=&#34;keyword&#34;&gt;yield&lt;/span&gt; api.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;/data&#39;&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 用yield代替await&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;process&lt;/span&gt;(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;div class=&#34;note info flat&#34;&gt;&lt;p&gt;&lt;strong&gt;这里有个小细节：&lt;/strong&gt; 每个 Async 函数都被转换成一个生成器函数，由&lt;mark&gt;自动执行器&lt;/mark&gt;接管执行！&lt;/p&gt;咱们不用手动调用&lt;code&gt;next()&lt;/code&gt;，全是执行器在后台搞定，这也是&lt;code&gt;Async/Await&lt;/code&gt;比直接用&lt;code&gt;Generator&lt;/code&gt;方便的地方～&lt;/div&gt;

&lt;h2 id=&#34;二、自动执行器：幕后的引擎&#34;&gt;&lt;a href=&#34;#二、自动执行器：幕后的引擎&#34; class=&#34;headerlink&#34; title=&#34;二、自动执行器：幕后的引擎&#34;&gt;&lt;/a&gt;二、自动执行器：幕后的引擎&lt;/h2&gt;&lt;p&gt;自动执行器是 Async / Await 能自动跑起来的关键，我试着简化了它的核心代码，大概长这样：&lt;/p&gt;
&lt;h3 id=&#34;2-1-核心逻辑（简化版）&#34;&gt;&lt;a href=&#34;#2-1-核心逻辑（简化版）&#34; class=&#34;headerlink&#34; title=&#34;2.1 核心逻辑（简化版）&#34;&gt;&lt;/a&gt;2.1 核心逻辑（简化版）&lt;/h3&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;spawn&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;generatorFunc&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 返回一个Promise，这也是async函数总返回Promise的原因&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; generator = &lt;span class=&#34;title function_&#34;&gt;generatorFunc&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 创建生成器实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 步进函数：驱动生成器一步步执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;step&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;nextFn&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; { value, done } = &lt;span class=&#34;title function_&#34;&gt;nextFn&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 执行到下一个yield&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (done) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;comment&#34;&gt;// 生成器跑完了，把结果传给Promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;resolve&lt;/span&gt;(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 把yield后的结果包装成Promise（不管是不是Promise）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;resolve&lt;/span&gt;(value).&lt;span class=&#34;title function_&#34;&gt;then&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;comment&#34;&gt;// 成功了就把结果传给下一次next()，继续执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;v&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;step&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; generator.&lt;span class=&#34;title function_&#34;&gt;next&lt;/span&gt;(v)),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;comment&#34;&gt;// 失败了就把错误抛回生成器，让try/catch接住&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;step&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; generator.&lt;span class=&#34;keyword&#34;&gt;throw&lt;/span&gt;(e))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        );&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      } &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (e) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 捕获生成器内部的错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title function_&#34;&gt;reject&lt;/span&gt;(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 启动生成器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;title function_&#34;&gt;step&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; generator.&lt;span class=&#34;title function_&#34;&gt;next&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;2-2-执行过程图解&#34;&gt;&lt;a href=&#34;#2-2-执行过程图解&#34; class=&#34;headerlink&#34; title=&#34;2.2 执行过程图解&#34;&gt;&lt;/a&gt;2.2 执行过程图解&lt;/h3&gt;&lt;p&gt;我画了个流程图帮大家理解，其实就是执行器在中间当 “裁判”，协调生成器和异步操作：&lt;/p&gt;
&lt;div class=&#34;mermaid-wrap&#34;&gt;&lt;pre class=&#34;mermaid-src&#34; hidden=&#34;&#34;&gt;  sequenceDiagram
participant 调用者
participant Async 函数
participant 执行器
participant 生成器

    调用者-&amp;gt;&amp;gt;Async函数: 调用 asyncFunc()
    Async函数-&amp;gt;&amp;gt;执行器: “麻烦帮我跑一下这个生成器”
    执行器-&amp;gt;&amp;gt;生成器: “开始执行咯（调用next()）”
    生成器--&amp;gt;&amp;gt;执行器: “遇到await了，先停在这”（返回yield的值）
    执行器-&amp;gt;&amp;gt;Promise: “等你结果出来喊我”
    Promise--&amp;gt;&amp;gt;执行器: “搞定，结果在这”
    执行器-&amp;gt;&amp;gt;生成器:  “继续跑吧，这是刚才的结果”（调用next(结果)）
    生成器--&amp;gt;&amp;gt;执行器: “跑完了，这是最终结果”
    执行器-&amp;gt;&amp;gt;调用者: “任务完成，给你结果”（Promise resolved）

  &lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;简单说就是：执行器启动生成器后，每次遇到 yield（也就是咱们写的 await）就停下来等异步结果，拿到结果再叫醒生成器继续跑，直到结束。全程不用手动干预，比直接用 Generator 省太多事了～&lt;/p&gt;
&lt;h2 id=&#34;三、await-到底做了什么？四步看懂它的“小动作”&#34;&gt;&lt;a href=&#34;#三、await-到底做了什么？四步看懂它的“小动作”&#34; class=&#34;headerlink&#34; title=&#34;三、await 到底做了什么？四步看懂它的“小动作”&#34;&gt;&lt;/a&gt;三、await 到底做了什么？四步看懂它的 “小动作”&lt;/h2&gt;&lt;p&gt;每次写&lt;code&gt;await&lt;/code&gt;的时候，引擎其实在背后干了四件事，我拆开来给大家说说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;暂停当前函数&lt;/strong&gt;：就像按了暂停键，当前的变量、执行位置都被 “冻” 起来&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;包装异步结果&lt;/strong&gt;：不管 await 后面是 Promise 还是普通值（比如 await 42），都会被转成 Promise。普通值会被 Promise.resolve() 包一层，确保统一用 Promise 处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注册回调&lt;/strong&gt;：把 await 后面的代码（比如拿到 data 后处理的逻辑）打包成一个微任务，注册到事件循环里&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;让出主线程&lt;/strong&gt;：当前函数暂停后，主线程会去执行其他任务（比如渲染、处理其他事件），等 Promise 有结果了，再回头执行刚才打包的微任务&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;note info flat&#34;&gt;&lt;p&gt;&lt;strong&gt;这里有个性能小细节：&lt;/strong&gt; &lt;code&gt;await&lt;/code&gt;不会阻塞主线程！它只是把后续代码挂起（包装成&lt;mark&gt;微任务&lt;/mark&gt;），让主线程先忙别的。这也是为什么用&lt;code&gt;await&lt;/code&gt;的时候，页面不会卡 —— 因为它会主动 “让道”。&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;四、错误处理：try-catch-居然能管到异步操作？&#34;&gt;&lt;a href=&#34;#四、错误处理：try-catch-居然能管到异步操作？&#34; class=&#34;headerlink&#34; title=&#34;四、错误处理：try/catch 居然能管到异步操作？&#34;&gt;&lt;/a&gt;四、错误处理：try / catch 居然能管到异步操作？&lt;/h2&gt;&lt;p&gt;这是我觉得 Async/Await 最方便的一点：用同步代码里的 try/catch 就能搞定异步错误，不用像回调那样嵌套多层 error 处理。&lt;/p&gt;
&lt;h3 id=&#34;4-1-同步式的错误处理&#34;&gt;&lt;a href=&#34;#4-1-同步式的错误处理&#34; class=&#34;headerlink&#34; title=&#34;4.1 同步式的错误处理&#34;&gt;&lt;/a&gt;4.1 同步式的错误处理&lt;/h3&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchUser&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; user = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;/user&#39;&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 可能失败&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; posts = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`/posts/&lt;span class=&#34;subst&#34;&gt;${user.id}&lt;/span&gt;`&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 依赖上一步结果，也可能失败&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; { user, posts };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  } &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (error) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 不管哪一步失败，都会跑到这里&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;error&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;请求失败:&#39;&lt;/span&gt;, error);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; { &lt;span class=&#34;attr&#34;&gt;user&lt;/span&gt;: &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;posts&lt;/span&gt;: [] };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;4-2-背后的错误传递&#34;&gt;&lt;a href=&#34;#4-2-背后的错误传递&#34; class=&#34;headerlink&#34; title=&#34;4.2 背后的错误传递&#34;&gt;&lt;/a&gt;4.2 背后的错误传递&lt;/h3&gt;&lt;p&gt;为什么 try / catch 能抓到异步错误？秘密在自动执行器的这段代码里：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 自动执行器处理Promise的部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;resolve&lt;/span&gt;(value).&lt;span class=&#34;title function_&#34;&gt;then&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;v&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;step&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; generator.&lt;span class=&#34;title function_&#34;&gt;next&lt;/span&gt;(v)), &lt;span class=&#34;comment&#34;&gt;// 成功就传结果继续执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;step&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; generator.&lt;span class=&#34;keyword&#34;&gt;throw&lt;/span&gt;(e)) &lt;span class=&#34;comment&#34;&gt;// 失败就把错误抛回生成器！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;当 await 后面的 Promise 失败时，执行器会调用&lt;code&gt;generator.throw(e)&lt;/code&gt;，把错误 “扔回” 生成器函数内部。这时候生成器里的 try / catch 就会像捕获同步错误一样，把这个异步错误接住。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;之前用回调的时候，每次异步操作都要单独写 error 处理，现在一个 try / catch 全搞定，代码清爽多了～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;五、性能优化：我在项目里掉过的性能坑&#34;&gt;&lt;a href=&#34;#五、性能优化：我在项目里掉过的性能坑&#34; class=&#34;headerlink&#34; title=&#34;五、性能优化：我在项目里掉过的性能坑&#34;&gt;&lt;/a&gt;五、性能优化：我在项目里掉过的性能坑&lt;/h2&gt;&lt;p&gt;分享几个我实际开发中遇到的问题，都是关于 Async / Await 性能的，新手很容易踩坑：&lt;/p&gt;
&lt;h3 id=&#34;5-1-坑一：没必要的顺序执行&#34;&gt;&lt;a href=&#34;#5-1-坑一：没必要的顺序执行&#34; class=&#34;headerlink&#34; title=&#34;5.1 坑一：没必要的顺序执行&#34;&gt;&lt;/a&gt;5.1 坑一：没必要的顺序执行&lt;/h3&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 反面例子：两个请求本来可以同时跑，却写成了顺序执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;slowFetch&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; a = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchA&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; b = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchB&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 等A完了才开始B&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; [a, b];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这两个请求如果没依赖关系（比如 A 不影响 B 的参数），完全可以同时启动，我后来改成这样：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 优化后：同时启动两个请求，总耗时是最慢那个的时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fastFetch&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 先同时发起请求，拿到两个Promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; promiseA = &lt;span class=&#34;title function_&#34;&gt;fetchA&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; promiseB = &lt;span class=&#34;title function_&#34;&gt;fetchB&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 再等它们结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; a = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; promiseA;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; b = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; promiseB;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; [a, b];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;5-2-坑二：多余的-await-包装&#34;&gt;&lt;a href=&#34;#5-2-坑二：多余的-await-包装&#34; class=&#34;headerlink&#34; title=&#34;5.2 坑二：多余的 await 包装&#34;&gt;&lt;/a&gt;5.2 坑二：多余的 await 包装&lt;/h3&gt;&lt;p&gt;有时候会下意识地在 return 前面加 await，但其实没必要：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 多余的await&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getData&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchData&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// fetchData本身已经返回Promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;因为 Async 函数会自动把返回值包成 Promise，这里的 await 纯属多此一举，直接 return 就行：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 更简洁高效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getData&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchData&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 等价于上面的写法，但少一层Promise包装&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;5-3-多个异步操作：用-Promise-all-处理并行&#34;&gt;&lt;a href=&#34;#5-3-多个异步操作：用-Promise-all-处理并行&#34; class=&#34;headerlink&#34; title=&#34;5.3 多个异步操作：用 Promise.all()处理并行&#34;&gt;&lt;/a&gt;5.3 多个异步操作：用 Promise.all() 处理并行&lt;/h3&gt;&lt;p&gt;如果需要等多个异步操作都完成，&lt;code&gt;Promise.all()&lt;/code&gt;配合 await 是绝配，下面的写法在实际项目中会经常用到哦~&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchAll&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 同时启动，等所有请求完成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; [user, posts] = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;all&lt;/span&gt;([&lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;/user&#39;&lt;/span&gt;), &lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;/posts&#39;&lt;/span&gt;)]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; { user, posts };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;div class=&#34;note warning flat&#34;&gt;&lt;p&gt;&lt;strong&gt;不过要注意：&lt;/strong&gt; &lt;code&gt;Promise.all()&lt;/code&gt;是 “一损俱损”，只要有一个请求失败，整个就会报错，这时候可以用&lt;code&gt;Promise.allSettled()&lt;/code&gt;处理需要全部结果的场景（哪怕部分失败）。&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;5-4-高级技巧：模块里的顶级-await&#34;&gt;&lt;a href=&#34;#5-4-高级技巧：模块里的顶级-await&#34; class=&#34;headerlink&#34; title=&#34;5.4 高级技巧：模块里的顶级 await&#34;&gt;&lt;/a&gt;5.4 高级技巧：模块里的顶级 await&lt;/h3&gt;&lt;p&gt;现在很多打包工具（比如 Webpack、Vite）已经支持模块顶层的 await 了，不用再包在 Async 函数里：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 直接在模块顶层用await&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; config = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;loadConfig&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 加载配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; settings = &lt;span class=&#34;title function_&#34;&gt;process&lt;/span&gt;(config);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 其实引擎会把模块转成类似这样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;loadConfig&lt;/span&gt;().&lt;span class=&#34;title function_&#34;&gt;then&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;config&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; settings = &lt;span class=&#34;title function_&#34;&gt;process&lt;/span&gt;(config);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我在做一个工具库的时候用过这个，用来加载动态配置，比以前用 IIFE（立即执行函数）清爽多了。&lt;/p&gt;
&lt;h2 id=&#34;六、Async-Await-实战场景：这些地方用起来超顺手&#34;&gt;&lt;a href=&#34;#六、Async-Await-实战场景：这些地方用起来超顺手&#34; class=&#34;headerlink&#34; title=&#34;六、Async/Await 实战场景：这些地方用起来超顺手&#34;&gt;&lt;/a&gt;六、Async / Await 实战场景：这些地方用起来超顺手&lt;/h2&gt;&lt;h3 id=&#34;6-1-异步初始化（比如数据库连接）&#34;&gt;&lt;a href=&#34;#6-1-异步初始化（比如数据库连接）&#34; class=&#34;headerlink&#34; title=&#34;6.1 异步初始化（比如数据库连接）&#34;&gt;&lt;/a&gt;6.1 异步初始化（比如数据库连接）&lt;/h3&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Database&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 静态方法做异步初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;init&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; connection = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;createConnection&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 建立连接（异步）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Database&lt;/span&gt;(connection);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 使用的时候直接await&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; db = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Database&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;init&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这种场景如果用回调，很容易写成嵌套的 init 回调，用 Async / Await 就清晰多了。&lt;/p&gt;
&lt;h3 id=&#34;6-2-有依赖关系的顺序请求&#34;&gt;&lt;a href=&#34;#6-2-有依赖关系的顺序请求&#34; class=&#34;headerlink&#34; title=&#34;6.2 有依赖关系的顺序请求&#34;&gt;&lt;/a&gt;6.2 有依赖关系的顺序请求&lt;/h3&gt;&lt;p&gt;比如先拿用户 ID，再用 ID 查订单：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;purchase&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;itemId&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; user = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getUser&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 先查用户&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; item = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getItem&lt;/span&gt;(itemId); &lt;span class=&#34;comment&#34;&gt;// 再查商品&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;validatePurchase&lt;/span&gt;(user, item); &lt;span class=&#34;comment&#34;&gt;// 验证能否购买（异步）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; receipt = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;createReceipt&lt;/span&gt;(user, item); &lt;span class=&#34;comment&#34;&gt;// 生成订单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; receipt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;步骤再复杂，用顺序 await 写出来也像同步代码一样好懂。&lt;/p&gt;
&lt;h3 id=&#34;6-3-带重试的请求&#34;&gt;&lt;a href=&#34;#6-3-带重试的请求&#34; class=&#34;headerlink&#34; title=&#34;6.3 带重试的请求&#34;&gt;&lt;/a&gt;6.3 带重试的请求&lt;/h3&gt;&lt;p&gt;处理可能偶尔失败的接口时，用 Async / Await 写重试逻辑很直观：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchWithRetry&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;url, retries = &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(url);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  } &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (error) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (retries &amp;lt;= &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;throw&lt;/span&gt; error; &lt;span class=&#34;comment&#34;&gt;// 重试次数用完&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;delay&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1000&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 等1秒再重试&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchWithRetry&lt;/span&gt;(url, retries - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 递归重试&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我在对接一个不稳定的第三方接口时，就用这个逻辑做了重试，成功率提高了不少。&lt;/p&gt;
&lt;h3 id=&#34;6-4-超时控制（防止请求卡太久）&#34;&gt;&lt;a href=&#34;#6-4-超时控制（防止请求卡太久）&#34; class=&#34;headerlink&#34; title=&#34;6.4 超时控制（防止请求卡太久）&#34;&gt;&lt;/a&gt;6.4 超时控制（防止请求卡太久）&lt;/h3&gt;&lt;p&gt;结合&lt;code&gt;Promise.race()&lt;/code&gt;实现超时控制：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchWithTimeout&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;url, timeout = &lt;span class=&#34;number&#34;&gt;5000&lt;/span&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; fetchPromise = &lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(url);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 超时Promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; timeoutPromise = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;_, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;setTimeout&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;reject&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Error&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;请求超时&#39;&lt;/span&gt;)), timeout)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 谁先完成就用谁的结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;race&lt;/span&gt;([fetchPromise, timeoutPromise]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这个在做支付回调的时候特别有用，防止因为网络问题让用户一直等。&lt;/p&gt;
&lt;h2 id=&#34;七、踩过的坑：这些细节要注意&#34;&gt;&lt;a href=&#34;#七、踩过的坑：这些细节要注意&#34; class=&#34;headerlink&#34; title=&#34;七、踩过的坑：这些细节要注意&#34;&gt;&lt;/a&gt;七、踩过的坑：这些细节要注意&lt;/h2&gt;&lt;h3 id=&#34;7-1-箭头函数的-this-陷阱&#34;&gt;&lt;a href=&#34;#7-1-箭头函数的-this-陷阱&#34; class=&#34;headerlink&#34; title=&#34;7.1 箭头函数的 this 陷阱&#34;&gt;&lt;/a&gt;7.1 箭头函数的 this 陷阱&lt;/h3&gt;&lt;p&gt;用 Async 箭头函数当对象方法时，&lt;code&gt;this&lt;/code&gt;会丢：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 有问题：this指向不对&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; obj = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;value&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;42&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;print&lt;/span&gt;: &lt;span class=&#34;title function_&#34;&gt;async&lt;/span&gt; () =&amp;gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;value&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// undefined! 因为箭头函数的this是定义时的上下文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 正确写法：用传统函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; obj = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;value&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;42&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;print&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;value&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 42，this指向obj&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我在写一个类的方法时犯过这个错，调试了半天才发现是箭头函数的锅。&lt;/p&gt;
&lt;h3 id=&#34;7-2-控制并发数量&#34;&gt;&lt;a href=&#34;#7-2-控制并发数量&#34; class=&#34;headerlink&#34; title=&#34;7.2 控制并发数量&#34;&gt;&lt;/a&gt;7.2 控制并发数量&lt;/h3&gt;&lt;p&gt;如果并行请求太多（比如一次发 20 个接口），可能会触发浏览器的并发限制，这时候需要控制并发数：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;processBatch&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;items&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; promises = items.&lt;span class=&#34;title function_&#34;&gt;map&lt;/span&gt;(processItem); &lt;span class=&#34;comment&#34;&gt;// 所有任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 控制最多同时跑5个&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; results = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;throttlePromises&lt;/span&gt;(promises, &lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; results;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里的&lt;code&gt;throttlePromises&lt;/code&gt;是一个工具函数，原理是把任务分成多批，一批批执行（每批 5 个），避免一次性发起太多请求。&lt;/p&gt;
&lt;h3 id=&#34;7-3-可取消的异步任务（结合-AbortSignal）&#34;&gt;&lt;a href=&#34;#7-3-可取消的异步任务（结合-AbortSignal）&#34; class=&#34;headerlink&#34; title=&#34;7.3 可取消的异步任务（结合 AbortSignal）&#34;&gt;&lt;/a&gt;7.3 可取消的异步任务（结合 AbortSignal）&lt;/h3&gt;&lt;p&gt;有时候需要中途取消异步操作（比如用户离开页面），可以用&lt;code&gt;AbortSignal&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;longRunningTask&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;abortSignal&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (!abortSignal.&lt;span class=&#34;property&#34;&gt;aborted&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;doWork&lt;/span&gt;();&lt;span class=&#34;comment&#34;&gt;// 每次做一点工作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 每次循环检查退出信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (abortSignal.&lt;span class=&#34;property&#34;&gt;aborted&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;cleanup&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 做清理工作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; controller = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;AbortController&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; signal = controller.&lt;span class=&#34;property&#34;&gt;signal&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 启动长时间运行的任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;longRunningTask&lt;/span&gt;(signal);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; cancelTask {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  controller.&lt;span class=&#34;title function_&#34;&gt;abort&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 中止任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 设置一个定时器，以便在 3 秒后中止任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;setTimeout&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;cancelTask&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}, &lt;span class=&#34;number&#34;&gt;3000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我在做一个文件上传组件时用过这个，用户点取消按钮时，就通过&lt;code&gt;AbortSignal&lt;/code&gt;终止上传。&lt;/p&gt;
&lt;h2 id=&#34;八、常见问题解答（我当初学的时候也纠结过）&#34;&gt;&lt;a href=&#34;#八、常见问题解答（我当初学的时候也纠结过）&#34; class=&#34;headerlink&#34; title=&#34;八、常见问题解答（我当初学的时候也纠结过）&#34;&gt;&lt;/a&gt;八、常见问题解答（我当初学的时候也纠结过）&lt;/h2&gt;&lt;h3 id=&#34;Q1-Async-函数会阻塞主线程吗？&#34;&gt;&lt;a href=&#34;#Q1-Async-函数会阻塞主线程吗？&#34; class=&#34;headerlink&#34; title=&#34;Q1: Async 函数会阻塞主线程吗？&#34;&gt;&lt;/a&gt;Q1: Async 函数会阻塞主线程吗？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;不会！&lt;/strong&gt; Async 函数遇到 await 时会&lt;strong&gt;暂停并释放主线程&lt;/strong&gt;，JavaScript 的单线程模型通过事件循环实现异步执行。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;test&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;开始&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;delay&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1000&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 假设delay是个等待1秒的Promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;结束&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;执行到 await 时，函数会暂停，主线程可以去处理其他任务（比如点击事件、渲染），等 1 秒后才回头执行 console.log(‘结束’)，所以不会卡页面。&lt;/p&gt;
&lt;h3 id=&#34;Q2-可以-await-一个非-Promise-值吗？&#34;&gt;&lt;a href=&#34;#Q2-可以-await-一个非-Promise-值吗？&#34; class=&#34;headerlink&#34; title=&#34;Q2: 可以 await 一个非 Promise 值吗？&#34;&gt;&lt;/a&gt;Q2: 可以 await 一个非 Promise 值吗？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;可以！&lt;/strong&gt; 引擎会自动用 &lt;code&gt;Promise.resolve()&lt;/code&gt; 包装非 Promise 值：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getNumber&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; num = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;42&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 合法！等价于 await Promise.resolve(42)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;不过实际开发中很少这么用，一般 await 后面都是异步操作返回的 Promise。&lt;/p&gt;
&lt;h3 id=&#34;Q3-为什么-Async-函数不管-return-什么，最后都返回-Promise？&#34;&gt;&lt;a href=&#34;#Q3-为什么-Async-函数不管-return-什么，最后都返回-Promise？&#34; class=&#34;headerlink&#34; title=&#34;Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？&#34;&gt;&lt;/a&gt;Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？&lt;/h3&gt;&lt;p&gt;因为它本质是异步操作的包装器。哪怕你 return 一个原始值，引擎也会用 Promise.resolve() 包一层：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;answer&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;42&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 等价于 return Promise.resolve(42)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;所以调用 Async 函数时，必须用&lt;code&gt;await&lt;/code&gt;或者&lt;code&gt;.then()&lt;/code&gt;才能拿到结果。&lt;/p&gt;
&lt;h3 id=&#34;Q4-用-Promise-all-的时候，如果有一个请求失败怎么办？&#34;&gt;&lt;a href=&#34;#Q4-用-Promise-all-的时候，如果有一个请求失败怎么办？&#34; class=&#34;headerlink&#34; title=&#34;Q4: 用 Promise.all()的时候，如果有一个请求失败怎么办？&#34;&gt;&lt;/a&gt;Q4: 用 Promise.all() 的时候，如果有一个请求失败怎么办？&lt;/h3&gt;&lt;p&gt;之前已经提到过了，Promise.all() 会 “快速失败”—— 只要有一个 Promise 被拒绝，整个 Promise.all() 就会立刻失败，进入 catch。如果需要等所有请求完成（不管成功失败），可以用&lt;code&gt;Promise.allSettled()&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchAll&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; results = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;allSettled&lt;/span&gt;([&lt;span class=&#34;title function_&#34;&gt;fetchA&lt;/span&gt;(), &lt;span class=&#34;title function_&#34;&gt;fetchB&lt;/span&gt;()]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 过滤出成功的结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; successData = results.&lt;span class=&#34;title function_&#34;&gt;filter&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;r&lt;/span&gt;) =&amp;gt;&lt;/span&gt; r.&lt;span class=&#34;property&#34;&gt;status&lt;/span&gt; === &lt;span class=&#34;string&#34;&gt;&#39;fulfilled&#39;&lt;/span&gt;).&lt;span class=&#34;title function_&#34;&gt;map&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;r&lt;/span&gt;) =&amp;gt;&lt;/span&gt; r.&lt;span class=&#34;property&#34;&gt;value&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;Q5-为什么说-Async-Await-比回调好？&#34;&gt;&lt;a href=&#34;#Q5-为什么说-Async-Await-比回调好？&#34; class=&#34;headerlink&#34; title=&#34;Q5: 为什么说 Async/Await 比回调好？&#34;&gt;&lt;/a&gt;Q5: 为什么说 Async / Await 比回调好？&lt;/h3&gt;&lt;p&gt;我总结了几个实际开发中的感受：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码不嵌套，扁平结构更易读（告别 “回调地狱”）&lt;/li&gt;
&lt;li&gt;错误处理统一用 try / catch，不用每层回调都写 error 处理&lt;/li&gt;
&lt;li&gt;逻辑顺序和代码执行顺序一致，不用跳来跳去看代码&lt;/li&gt;
&lt;li&gt;调试更方便，错误堆栈更完整（回调的堆栈经常被异步操作打断）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;其实 Async/Await 不算什么高深的技术，就是把 Generator、Promise 这些老东西包装得更好用了。但正是这种 “语法糖”，让我们写异步代码时能少掉很多头发～ 如果你也有过用 Async/Await 踩坑的经历，欢迎在评论区分享呀！&lt;/p&gt;
</content>
        <category term="JavaScript" />
        <category term="ES2017(ES8)" />
        <category term="性能优化" />
        <updated>2024-07-13T12:46:25.000Z</updated>
    </entry>
</feed>
