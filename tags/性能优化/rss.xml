<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Touko • Posts by &#34;性能优化&#34; tag</title>
        <link>http://toukoxu.github.io</link>
        <description>这是一个博客网站，记录我的学习和生活点滴。</description>
        <language>zh</language>
        <pubDate>Thu, 15 Aug 2024 20:46:25 +0800</pubDate>
        <lastBuildDate>Thu, 15 Aug 2024 20:46:25 +0800</lastBuildDate>
        <category>JavaScript</category>
        <category>ES2017(ES8)</category>
        <category>性能优化</category>
        <category>ES6</category>
        <item>
            <guid isPermalink="true">http://toukoxu.github.io/archives/proxy/</guid>
            <title>代理（Proxy）：ES6 元编程的 “对象拦截器”</title>
            <link>http://toukoxu.github.io/archives/proxy/</link>
            <category>JavaScript</category>
            <category>性能优化</category>
            <category>ES6</category>
            <pubDate>Thu, 15 Aug 2024 20:46:25 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Proxy&lt;/strong&gt; 是 ES6 引入的元编程特性，简单说就是给对象 “装一层拦截器”—— 所有对对象的操作（比如读属性、改属性、删属性），都会先经过这层拦截器，我们可以在拦截器里自定义操作逻辑。它的灵活性极高，是 Vue3 响应式、数据验证、API 拦截等场景的核心技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关联知识&#34;&gt;&lt;a href=&#34;#关联知识&#34; class=&#34;headerlink&#34; title=&#34;关联知识&#34;&gt;&lt;/a&gt;关联知识&lt;/h2&gt;&lt;p&gt;可以将 Proxy 和 Reflect 合并在一起学习～&lt;/p&gt;
&lt;div&gt;&lt;a class=&#34;tag-Link&#34; target=&#34;_blank&#34; href=&#34;/archives/reflect&#34;&gt;
    &lt;div class=&#34;tag-link-bottom&#34;&gt;
        &lt;div class=&#34;tag-link-left&#34; style=&#34;background-image: url(/img/512.png)&#34;&gt;
          &lt;i class=&#34;anzhiyufont anzhiyu-icon-link&#34; style=&#34;display: none&#34;&gt;&lt;/i&gt;
        &lt;/div&gt;
        &lt;div class=&#34;tag-link-right&#34;&gt;
            &lt;div class=&#34;tag-link-title&#34;&gt;Reflect：ES6 标准化对象操作的 “工具库”&lt;/div&gt;
            &lt;div class=&#34;tag-link-sitename&#34;&gt; Touko&lt;/div&gt;
        &lt;/div&gt;
        &lt;i class=&#34;anzhiyufont anzhiyu-icon-angle-right&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;/a&gt;&lt;/div&gt;

&lt;h2 id=&#34;一、Proxy-的核心：三要素与基础用法&#34;&gt;&lt;a href=&#34;#一、Proxy-的核心：三要素与基础用法&#34; class=&#34;headerlink&#34; title=&#34;一、Proxy 的核心：三要素与基础用法&#34;&gt;&lt;/a&gt;一、Proxy 的核心：三要素与基础用法&lt;/h2&gt;&lt;p&gt;Proxy 的使用很直观，核心是 &lt;code&gt;new Proxy(target, handler)&lt;/code&gt; 这个构造函数，需要传入两个关键参数：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 基本语法：创建一个代理对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; proxy = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Proxy&lt;/span&gt;(target, handler);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;target&lt;/strong&gt;：被代理的 “目标对象”（可以是普通对象、数组、函数，甚至另一个代理）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;handler&lt;/strong&gt;：“拦截器配置对象”，里面定义了各种 “拦截方法”（比如 &lt;code&gt;get&lt;/code&gt; 拦截读操作，&lt;code&gt;set&lt;/code&gt; 拦截写操作）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;proxy&lt;/strong&gt;：生成的 “代理对象”—— 后续操作都要通过这个代理对象，才能触发拦截逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个最简单的例子：给普通对象加一层拦截，监控属性的读写：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 目标对象：一个普通用户对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; user = { &lt;span class=&#34;attr&#34;&gt;name&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;Alice&#39;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;age&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;28&lt;/span&gt; };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 拦截器配置：定义要拦截的操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; userHandler = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 拦截“读属性”操作（比如 proxy.name）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`正在读取属性：&lt;span class=&#34;subst&#34;&gt;${propKey}&lt;/span&gt;`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 用 Reflect.get 保持默认读逻辑（避免破坏原对象行为）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Reflect&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(target, propKey);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 拦截“写属性”操作（比如 proxy.age = 29）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey, value&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`正在修改属性 &lt;span class=&#34;subst&#34;&gt;${propKey}&lt;/span&gt;：从 &lt;span class=&#34;subst&#34;&gt;${target[propKey]}&lt;/span&gt; 改成 &lt;span class=&#34;subst&#34;&gt;${value}&lt;/span&gt;`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 用 Reflect.set 保持默认写逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Reflect&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(target, propKey, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 创建代理对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; proxyUser = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Proxy&lt;/span&gt;(user, userHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 测试拦截效果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(proxyUser.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 触发 get：输出“正在读取属性：name”，再输出“Alice”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;proxyUser.&lt;span class=&#34;property&#34;&gt;age&lt;/span&gt; = &lt;span class=&#34;number&#34;&gt;29&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 触发 set：输出“正在修改属性 age：从 28 改成 29”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;二、13-种核心拦截方法：覆盖所有对象操作&#34;&gt;&lt;a href=&#34;#二、13-种核心拦截方法：覆盖所有对象操作&#34; class=&#34;headerlink&#34; title=&#34;二、13 种核心拦截方法：覆盖所有对象操作&#34;&gt;&lt;/a&gt;二、13 种核心拦截方法：覆盖所有对象操作&lt;/h2&gt;&lt;p&gt;Proxy 提供了 13 种拦截方法，覆盖了对象的几乎所有基础操作。我整理了日常开发中最常用的几种，按使用频率排序：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;拦截器方法&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;核心作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;get(target, propKey, receiver)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;读取对象属性时&lt;/td&gt;
&lt;td&gt;&lt;code&gt;proxy.name&lt;/code&gt;、&lt;code&gt;proxy[0]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;监控属性读取、返回自定义值（比如默认值）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;set(target, propKey, value, receiver)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置对象属性时&lt;/td&gt;
&lt;td&gt;&lt;code&gt;proxy.age = 30&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;验证属性值、监控属性修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;has(target, propKey)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;in&lt;/code&gt; 操作符时&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&#39;name&#39; in proxy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;自定义 “属性是否存在” 的判断逻辑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;deleteProperty(target, propKey)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;delete&lt;/code&gt; 操作时&lt;/td&gt;
&lt;td&gt;&lt;code&gt;delete proxy.age&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;监控属性删除、阻止敏感属性删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;apply(target, thisArg, args)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代理的目标是函数，且函数被调用时&lt;/td&gt;
&lt;td&gt;&lt;code&gt;proxy(1, 2)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;拦截函数调用、修改参数或返回值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;construct(target, args)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;代理的目标是构造函数，且用 &lt;code&gt;new&lt;/code&gt; 创建实例时&lt;/td&gt;
&lt;td&gt;&lt;code&gt;new proxy(1, 2)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;拦截实例创建、修改实例属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ownKeys(target)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;遍历对象属性时（如 &lt;code&gt;Object.keys(proxy)&lt;/code&gt;、&lt;code&gt;for...in&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Object.keys(proxy)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;自定义遍历返回的属性列表（比如隐藏敏感属性）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;其他拦截方法多用于底层元编程，日常开发中较少直接使用，了解即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getOwnPropertyDescriptor(target, propKey)&lt;/li&gt;
&lt;li&gt;defineProperty(target, propKey, propDesc)&lt;/li&gt;
&lt;li&gt;preventExtensions(target)&lt;/li&gt;
&lt;li&gt;getPrototypeOf(target)&lt;/li&gt;
&lt;li&gt;isExtensible(target)&lt;/li&gt;
&lt;li&gt;setPrototypeOf(target, proto)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三、Proxy-的实战场景：这些地方用它最香&#34;&gt;&lt;a href=&#34;#三、Proxy-的实战场景：这些地方用它最香&#34; class=&#34;headerlink&#34; title=&#34;三、Proxy 的实战场景：这些地方用它最香&#34;&gt;&lt;/a&gt;三、Proxy 的实战场景：这些地方用它最香&lt;/h2&gt;&lt;h3 id=&#34;3-1-响应式数据（Vue3-核心原理）&#34;&gt;&lt;a href=&#34;#3-1-响应式数据（Vue3-核心原理）&#34; class=&#34;headerlink&#34; title=&#34;3.1 响应式数据（Vue3 核心原理）&#34;&gt;&lt;/a&gt;3.1 响应式数据（Vue3 核心原理）&lt;/h3&gt;&lt;p&gt;Vue3 的响应式系统就是基于 Proxy 实现的 —— 通过拦截对象的 &lt;code&gt;get&lt;/code&gt;（收集依赖）和 &lt;code&gt;set&lt;/code&gt;（触发更新），实现 “数据变，视图自动变”。&lt;/p&gt;
&lt;p&gt;简化版实现如下：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;59&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 存储依赖：key 是目标对象，value 是该对象各属性的依赖列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; reactiveMap = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;WeakMap&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 收集依赖：记录“哪个函数在用这个属性”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;track&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 这里简化处理，实际 Vue 中会关联组件渲染函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!reactiveMap.&lt;span class=&#34;title function_&#34;&gt;has&lt;/span&gt;(target)) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    reactiveMap.&lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(target, &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Map&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; propMap = reactiveMap.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(target);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!propMap.&lt;span class=&#34;title function_&#34;&gt;has&lt;/span&gt;(propKey)) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    propMap.&lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(propKey, &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Set&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 假设当前依赖是一个“更新函数”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;updateFn&lt;/span&gt; = (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) =&amp;gt; &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`属性 &lt;span class=&#34;subst&#34;&gt;${propKey}&lt;/span&gt; 变了，更新视图！`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  propMap.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(propKey).&lt;span class=&#34;title function_&#34;&gt;add&lt;/span&gt;(updateFn);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 触发更新：通知所有依赖该属性的函数执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;trigger&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!reactiveMap.&lt;span class=&#34;title function_&#34;&gt;has&lt;/span&gt;(target)) &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; propMap = reactiveMap.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(target);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (propMap.&lt;span class=&#34;title function_&#34;&gt;has&lt;/span&gt;(propKey)) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    propMap.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(propKey).&lt;span class=&#34;title function_&#34;&gt;forEach&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;fn&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fn&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 生成响应式对象的核心函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;reactive&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 避免重复代理（同一对象只代理一次）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (reactiveMap.&lt;span class=&#34;title function_&#34;&gt;has&lt;/span&gt;(target)) &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; reactiveMap.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(target);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; proxy = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Proxy&lt;/span&gt;(target, {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey, receiver&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 读取属性时，收集依赖&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;title function_&#34;&gt;track&lt;/span&gt;(target, propKey);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; value = &lt;span class=&#34;title class_&#34;&gt;Reflect&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(target, propKey, receiver);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 嵌套对象递归代理（比如 user.address.city 也能响应）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;typeof&lt;/span&gt; value === &lt;span class=&#34;string&#34;&gt;&#39;object&#39;&lt;/span&gt; &amp;amp;&amp;amp; value !== &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt; ? &lt;span class=&#34;title function_&#34;&gt;reactive&lt;/span&gt;(value) : value;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey, value, receiver&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; oldValue = &lt;span class=&#34;title class_&#34;&gt;Reflect&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(target, propKey, receiver);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; success = &lt;span class=&#34;title class_&#34;&gt;Reflect&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(target, propKey, value, receiver);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 只有值真的变了，才触发更新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (oldValue !== value) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title function_&#34;&gt;trigger&lt;/span&gt;(target, propKey);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; success;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  reactiveMap.&lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(target, proxy);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; proxy;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 测试响应式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; user = &lt;span class=&#34;title function_&#34;&gt;reactive&lt;/span&gt;({ &lt;span class=&#34;attr&#34;&gt;name&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;Bob&#39;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;address&lt;/span&gt;: { &lt;span class=&#34;attr&#34;&gt;city&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;Beijing&#39;&lt;/span&gt; } });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;user.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt; = &lt;span class=&#34;string&#34;&gt;&#39;Charlie&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 触发 set → 输出“属性 name 变了，更新视图！”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;user.&lt;span class=&#34;property&#34;&gt;address&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;city&lt;/span&gt; = &lt;span class=&#34;string&#34;&gt;&#39;Shanghai&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 嵌套对象也触发 → 输出“属性 city 变了，更新视图！”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;3-2-数据验证：确保属性值符合规则&#34;&gt;&lt;a href=&#34;#3-2-数据验证：确保属性值符合规则&#34; class=&#34;headerlink&#34; title=&#34;3.2 数据验证：确保属性值符合规则&#34;&gt;&lt;/a&gt;3.2 数据验证：确保属性值符合规则&lt;/h3&gt;&lt;p&gt;比如要求 &lt;code&gt;age&lt;/code&gt; 必须是正整数，&lt;code&gt;name&lt;/code&gt; 不能是空字符串 —— 通过 &lt;code&gt;set&lt;/code&gt; 拦截器就能实现：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 定义验证规则的拦截器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; validatorHandler = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey, value&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;switch&lt;/span&gt; (propKey) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&#39;age&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 验证 age 必须是正整数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!&lt;span class=&#34;title class_&#34;&gt;Number&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;isInteger&lt;/span&gt;(value) || value &amp;lt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;TypeError&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`年龄 &lt;span class=&#34;subst&#34;&gt;${value}&lt;/span&gt; 无效！必须是正整数`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&#39;name&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 验证 name 不能是空字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;typeof&lt;/span&gt; value !== &lt;span class=&#34;string&#34;&gt;&#39;string&#39;&lt;/span&gt; || value.&lt;span class=&#34;title function_&#34;&gt;trim&lt;/span&gt;() === &lt;span class=&#34;string&#34;&gt;&#39;&#39;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;keyword&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;TypeError&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;姓名不能为空！&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 验证通过，执行默认的赋值逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Reflect&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(target, propKey, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 创建带验证的代理对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; person = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Proxy&lt;/span&gt;({}, validatorHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 测试验证逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;person.&lt;span class=&#34;property&#34;&gt;age&lt;/span&gt; = &lt;span class=&#34;number&#34;&gt;30&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 验证通过&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;person.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt; = &lt;span class=&#34;string&#34;&gt;&#39;David&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 验证通过&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;person.&lt;span class=&#34;property&#34;&gt;age&lt;/span&gt; = &lt;span class=&#34;string&#34;&gt;&#39;thirty&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 报错：TypeError: 年龄 thirty 无效！必须是正整数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;person.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt; = &lt;span class=&#34;string&#34;&gt;&#39;&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 报错：TypeError: 姓名不能为空！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;3-3-API-请求拦截：统一管理接口调用&#34;&gt;&lt;a href=&#34;#3-3-API-请求拦截：统一管理接口调用&#34; class=&#34;headerlink&#34; title=&#34;3.3 API 请求拦截：统一管理接口调用&#34;&gt;&lt;/a&gt;3.3 API 请求拦截：统一管理接口调用&lt;/h3&gt;&lt;p&gt;比如给所有 API 调用加 “请求日志” 和 “基础 URL 拼接”，不用每次调用都写重复逻辑：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 目标对象：存储 API 基础配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; apiConfig = { &lt;span class=&#34;attr&#34;&gt;baseURL&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;https://api.example.com&#39;&lt;/span&gt; };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// API 拦截器：拦截属性访问，返回封装后的请求函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; apiHandler = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, endpoint&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 比如访问 api.users，返回一个请求 /users 接口的函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;async&lt;/span&gt; (params) =&amp;gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 统一加请求日志&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`调用 API：&lt;span class=&#34;subst&#34;&gt;${endpoint}&lt;/span&gt;，参数：`&lt;/span&gt;, params);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 统一拼接基础 URL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; url = &lt;span class=&#34;string&#34;&gt;`&lt;span class=&#34;subst&#34;&gt;${target.baseURL}&lt;/span&gt;/&lt;span class=&#34;subst&#34;&gt;${endpoint}&lt;/span&gt;`&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 发送请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; response = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(url, {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;attr&#34;&gt;method&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;POST&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;attr&#34;&gt;headers&lt;/span&gt;: { &lt;span class=&#34;string&#34;&gt;&#39;Content-Type&#39;&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;application/json&#39;&lt;/span&gt; },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;attr&#34;&gt;body&lt;/span&gt;: &lt;span class=&#34;title class_&#34;&gt;JSON&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;stringify&lt;/span&gt;(params),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; response.&lt;span class=&#34;title function_&#34;&gt;json&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 创建 API 代理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; api = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Proxy&lt;/span&gt;(apiConfig, apiHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 调用 API：简洁且统一&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; userData = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; api.&lt;span class=&#34;title function_&#34;&gt;users&lt;/span&gt;({ &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;123&lt;/span&gt; }); &lt;span class=&#34;comment&#34;&gt;// 调用 https://api.example.com/users&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; orderData = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; api.&lt;span class=&#34;title function_&#34;&gt;orders&lt;/span&gt;({ &lt;span class=&#34;attr&#34;&gt;userId&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;123&lt;/span&gt; }); &lt;span class=&#34;comment&#34;&gt;// 调用 https://api.example.com/orders&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;3-4-自动持久化：修改数据自动存到本地存储&#34;&gt;&lt;a href=&#34;#3-4-自动持久化：修改数据自动存到本地存储&#34; class=&#34;headerlink&#34; title=&#34;3.4 自动持久化：修改数据自动存到本地存储&#34;&gt;&lt;/a&gt;3.4 自动持久化：修改数据自动存到本地存储&lt;/h3&gt;&lt;p&gt;比如让配置数据修改后自动保存到 &lt;code&gt;localStorage&lt;/code&gt;，刷新页面也不会丢：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 创建“自动持久化”的代理函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;createPersistentState&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;storageKey, initialState&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 从 localStorage 读取已有数据（没有则用初始值）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; storedData = &lt;span class=&#34;variable language_&#34;&gt;localStorage&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getItem&lt;/span&gt;(storageKey);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; state = storedData ? &lt;span class=&#34;title class_&#34;&gt;JSON&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;parse&lt;/span&gt;(storedData) : initialState;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 拦截 set 操作：修改后自动保存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; handler = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey, value&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; success = &lt;span class=&#34;title class_&#34;&gt;Reflect&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(target, propKey, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 自动同步到 localStorage&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;variable language_&#34;&gt;localStorage&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;setItem&lt;/span&gt;(storageKey, &lt;span class=&#34;title class_&#34;&gt;JSON&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;stringify&lt;/span&gt;(target));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; success;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Proxy&lt;/span&gt;(state, handler);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 创建自动持久化的配置对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; appSettings = &lt;span class=&#34;title function_&#34;&gt;createPersistentState&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;app-settings&#39;&lt;/span&gt;, {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;theme&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;light&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;fontSize&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;16&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 测试：修改后自动保存到 localStorage&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;appSettings.&lt;span class=&#34;property&#34;&gt;theme&lt;/span&gt; = &lt;span class=&#34;string&#34;&gt;&#39;dark&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// localStorage 里的 app-settings 会自动更新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;appSettings.&lt;span class=&#34;property&#34;&gt;fontSize&lt;/span&gt; = &lt;span class=&#34;number&#34;&gt;18&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 同样自动保存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;3-5-数组变化监听：完美支持数组方法&#34;&gt;&lt;a href=&#34;#3-5-数组变化监听：完美支持数组方法&#34; class=&#34;headerlink&#34; title=&#34;3.5 数组变化监听：完美支持数组方法&#34;&gt;&lt;/a&gt;3.5 数组变化监听：完美支持数组方法&lt;/h3&gt;&lt;p&gt;Proxy 能原生拦截数组的 &lt;code&gt;push&lt;/code&gt;、&lt;code&gt;pop&lt;/code&gt;、&lt;code&gt;splice&lt;/code&gt; 等方法，不用像 &lt;code&gt;Object.defineProperty&lt;/code&gt; 那样做特殊 hack：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 数组拦截器：监控数组操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; arrayHandler = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 拦截数组的变异方法（push、pop 等）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; mutationMethods = [&lt;span class=&#34;string&#34;&gt;&#39;push&#39;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&#39;pop&#39;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&#39;shift&#39;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&#39;unshift&#39;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&#39;splice&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (mutationMethods.&lt;span class=&#34;title function_&#34;&gt;includes&lt;/span&gt;(propKey)) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 返回包装后的方法，保留原逻辑并加监控&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;...args&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`数组执行 &lt;span class=&#34;subst&#34;&gt;${propKey}&lt;/span&gt;，参数：`&lt;/span&gt;, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 调用数组原生方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Array&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;[propKey].&lt;span class=&#34;title function_&#34;&gt;apply&lt;/span&gt;(target, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 非数组方法，走默认逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Reflect&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(target, propKey);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 测试数组代理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; list = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Proxy&lt;/span&gt;([&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;], arrayHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;list.&lt;span class=&#34;title function_&#34;&gt;push&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;4&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 触发拦截：输出“数组执行 push，参数：[4]”，数组变成 [1,2,3,4]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;list.&lt;span class=&#34;title function_&#34;&gt;splice&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 触发拦截：输出“数组执行 splice，参数：[0,1]”，数组变成 [2,3,4]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;四、Proxy-实战注意事项与优化&#34;&gt;&lt;a href=&#34;#四、Proxy-实战注意事项与优化&#34; class=&#34;headerlink&#34; title=&#34;四、Proxy 实战注意事项与优化&#34;&gt;&lt;/a&gt;四、Proxy 实战注意事项与优化&lt;/h2&gt;&lt;h3 id=&#34;4-1-必须用-Reflect-保持默认行为&#34;&gt;&lt;a href=&#34;#4-1-必须用-Reflect-保持默认行为&#34; class=&#34;headerlink&#34; title=&#34;4.1 必须用 Reflect 保持默认行为&#34;&gt;&lt;/a&gt;4.1 必须用 Reflect 保持默认行为&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Reflect&lt;/code&gt; 是 ES6 配合 Proxy 推出的 API，它的方法和 Proxy 的拦截器一一对应（比如 &lt;code&gt;Reflect.get&lt;/code&gt; 对应 &lt;code&gt;get&lt;/code&gt; 拦截器）。在拦截器里用 &lt;code&gt;Reflect&lt;/code&gt; 而不是直接操作 &lt;code&gt;target&lt;/code&gt;，能确保：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持对象的默认行为（比如 &lt;code&gt;this&lt;/code&gt; 指向正确）；&lt;/li&gt;
&lt;li&gt;正确处理复杂场景（比如继承属性、不可写属性）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反例（不推荐）：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; badHandler = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; target[propKey]; &lt;span class=&#34;comment&#34;&gt;// 直接操作 target，可能破坏继承等默认行为&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;正例（推荐）：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; goodHandler = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey, receiver&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Reflect&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(target, propKey, receiver); &lt;span class=&#34;comment&#34;&gt;// 用 Reflect 保持默认行为&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;4-2-避免过度代理：减少性能开销&#34;&gt;&lt;a href=&#34;#4-2-避免过度代理：减少性能开销&#34; class=&#34;headerlink&#34; title=&#34;4.2 避免过度代理：减少性能开销&#34;&gt;&lt;/a&gt;4.2 避免过度代理：减少性能开销&lt;/h3&gt;&lt;p&gt;Proxy 虽然灵活，但创建和递归代理会有性能开销，尤其是处理大型对象或频繁操作时。优化技巧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;避免重复代理&lt;/strong&gt;：用 &lt;code&gt;WeakMap&lt;/code&gt; 缓存已代理的对象，同一对象只代理一次（参考 3.1 响应式的 &lt;code&gt;reactiveMap&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;浅层代理优先&lt;/strong&gt;：如果只需要监控顶层属性，不用递归代理嵌套对象；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能关键场景不用 Proxy&lt;/strong&gt;：比如高频更新的列表、大型数据计算，用普通对象更高效。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-3-嵌套对象代理：需要递归处理&#34;&gt;&lt;a href=&#34;#4-3-嵌套对象代理：需要递归处理&#34; class=&#34;headerlink&#34; title=&#34;4.3 嵌套对象代理：需要递归处理&#34;&gt;&lt;/a&gt;4.3 嵌套对象代理：需要递归处理&lt;/h3&gt;&lt;p&gt;Proxy 只能拦截 “直接操作的属性”，如果目标对象有嵌套对象（比如 &lt;code&gt;user.address.city&lt;/code&gt;），直接代理顶层对象无法拦截嵌套属性的操作 —— 需要在 &lt;code&gt;get&lt;/code&gt; 拦截器里递归代理嵌套对象：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; nestedHandler = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey, receiver&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; value = &lt;span class=&#34;title class_&#34;&gt;Reflect&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(target, propKey, receiver);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 如果值是对象且非 null，递归代理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;typeof&lt;/span&gt; value === &lt;span class=&#34;string&#34;&gt;&#39;object&#39;&lt;/span&gt; &amp;amp;&amp;amp; value !== &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Proxy&lt;/span&gt;(value, nestedHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, propKey, value&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`修改 &lt;span class=&#34;subst&#34;&gt;${propKey}&lt;/span&gt;：&lt;span class=&#34;subst&#34;&gt;${value}&lt;/span&gt;`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Reflect&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(target, propKey, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 测试嵌套代理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; user = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Proxy&lt;/span&gt;({ &lt;span class=&#34;attr&#34;&gt;address&lt;/span&gt;: { &lt;span class=&#34;attr&#34;&gt;city&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;Beijing&#39;&lt;/span&gt; } }, nestedHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;user.&lt;span class=&#34;property&#34;&gt;address&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;city&lt;/span&gt; = &lt;span class=&#34;string&#34;&gt;&#39;Shanghai&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 触发 set：输出“修改 city：Shanghai”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;4-4-浏览器兼容性：旧环境回退&#34;&gt;&lt;a href=&#34;#4-4-浏览器兼容性：旧环境回退&#34; class=&#34;headerlink&#34; title=&#34;4.4 浏览器兼容性：旧环境回退&#34;&gt;&lt;/a&gt;4.4 浏览器兼容性：旧环境回退&lt;/h3&gt;&lt;p&gt;Proxy 不支持 IE 浏览器，如果需要兼容旧环境，可以用 &lt;code&gt;Object.defineProperty&lt;/code&gt; 做回退（类似 Vue2 的响应式方案）：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;createCompatProxy&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;target, handler&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 现代浏览器：用 Proxy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;typeof&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Proxy&lt;/span&gt; !== &lt;span class=&#34;string&#34;&gt;&#39;undefined&#39;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Proxy&lt;/span&gt;(target, handler);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 旧浏览器：用 Object.defineProperty 模拟（仅支持 get/set）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;title class_&#34;&gt;Array&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;isArray&lt;/span&gt;(target)) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 数组回退：拦截索引和长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    target.&lt;span class=&#34;title function_&#34;&gt;forEach&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;_, index&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;defineProperty&lt;/span&gt;(target, index, {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; handler.&lt;span class=&#34;property&#34;&gt;get&lt;/span&gt;?.(target, index);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;value&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          handler.&lt;span class=&#34;property&#34;&gt;set&lt;/span&gt;?.(target, index, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  } &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 对象回退：拦截属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;keys&lt;/span&gt;(target).&lt;span class=&#34;title function_&#34;&gt;forEach&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;key&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;defineProperty&lt;/span&gt;(target, key, {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; handler.&lt;span class=&#34;property&#34;&gt;get&lt;/span&gt;?.(target, key);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title function_&#34;&gt;set&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;value&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          handler.&lt;span class=&#34;property&#34;&gt;set&lt;/span&gt;?.(target, key, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; target;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;五、Proxy-vs-Object-defineProperty：核心差异&#34;&gt;&lt;a href=&#34;#五、Proxy-vs-Object-defineProperty：核心差异&#34; class=&#34;headerlink&#34; title=&#34;五、Proxy vs Object.defineProperty：核心差异&#34;&gt;&lt;/a&gt;五、Proxy vs Object.defineProperty：核心差异&lt;/h2&gt;&lt;p&gt;很多人会把 Proxy 和 ES5 的 &lt;code&gt;Object.defineProperty&lt;/code&gt; 对比，两者都是 “对象拦截” 方案，但 Proxy 更强大、更灵活：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;Proxy（ES6）&lt;/th&gt;
&lt;th&gt;Object.defineProperty（ES5）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;嵌套对象监听&lt;/td&gt;
&lt;td&gt;✅ 支持（需递归代理）&lt;/td&gt;
&lt;td&gt;❌ 不支持，需手动递归实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数组监听&lt;/td&gt;
&lt;td&gt;✅ 原生支持（push、splice 等方法）&lt;/td&gt;
&lt;td&gt;❌ 需 hack 数组原型，不完美&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;新增属性监听&lt;/td&gt;
&lt;td&gt;✅ 自动支持（比如 &lt;code&gt;proxy.newKey = 1&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;❌ 不支持，需手动调用 &lt;code&gt;defineProperty&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除属性监听&lt;/td&gt;
&lt;td&gt;✅ 支持（&lt;code&gt;delete proxy.key&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;❌ 不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;拦截操作数量&lt;/td&gt;
&lt;td&gt;13 种（覆盖所有对象操作）&lt;/td&gt;
&lt;td&gt;仅 2 种（get / set）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能&lt;/td&gt;
&lt;td&gt;现代浏览器优化良好，一般场景足够用&lt;/td&gt;
&lt;td&gt;稍快，但功能有限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;浏览器支持&lt;/td&gt;
&lt;td&gt;现代浏览器（Chrome、Firefox、Edge），不支持 IE&lt;/td&gt;
&lt;td&gt;支持到 IE9&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;简单说：如果不需要兼容 IE，优先用 Proxy；如果需要兼容旧环境，才考虑 &lt;code&gt;Object.defineProperty&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;六、Proxy-的局限性&#34;&gt;&lt;a href=&#34;#六、Proxy-的局限性&#34; class=&#34;headerlink&#34; title=&#34;六、Proxy 的局限性&#34;&gt;&lt;/a&gt;六、Proxy 的局限性&lt;/h2&gt;&lt;p&gt;Proxy 虽强，但也有一些无法突破的限制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;无法拦截全等比较&lt;/strong&gt;：&lt;code&gt;proxy === target&lt;/code&gt; 永远是 &lt;code&gt;false&lt;/code&gt;（代理和原对象是两个不同的引用）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无法拦截某些内部方法&lt;/strong&gt;：比如 &lt;code&gt;Object.prototype.toString.call(proxy)&lt;/code&gt;，返回的是代理对象的类型，无法自定义；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;序列化问题&lt;/strong&gt;：代理对象不能直接用 &lt;code&gt;JSON.stringify&lt;/code&gt; 序列化（会序列化原对象的属性，但拦截逻辑不生效）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存消耗&lt;/strong&gt;：深度代理大型对象（比如嵌套多层的数组 / 对象），会占用较多内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;Proxy 是 ES6 中最强大的特性之一，它的核心价值在于 “不修改原对象，却能自定义对象的行为”—— 这种 “非侵入式” 的拦截能力，让它在框架开发、工具库、数据处理等场景中大放异彩。掌握 Proxy，不仅能看懂 Vue3 等框架的底层逻辑，还能写出更灵活、更优雅的代码～&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://toukoxu.github.io/archives/async+await/</guid>
            <title>Async / Await：用同步的方式写异步，真香！</title>
            <link>http://toukoxu.github.io/archives/async+await/</link>
            <category>JavaScript</category>
            <category>ES2017(ES8)</category>
            <category>性能优化</category>
            <pubDate>Sat, 13 Jul 2024 20:46:25 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;async/await 是 ES2017 引入的强大特性，使得处理异步操作变得更加简单和直观。使用 async 声明的函数总是返回一个 Promise，而 await 关键字则像是它的指挥棒，允许你暂停函数的执行，直到 Promise 被解决或拒绝。这种方式让异步代码看起来更像同步代码，从而提高了可读性和可维护性。尤其在处理链式异步操作和错误捕获时，async/await 显示出其独特的优势。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;前置知识&#34;&gt;&lt;a href=&#34;#前置知识&#34; class=&#34;headerlink&#34; title=&#34;前置知识&#34;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;p&gt;如果对生成器函数和 yield 不太熟悉，可以先看看下面这篇，了解基础后再看 Async / Await 会更顺～&lt;/p&gt;
&lt;div&gt;&lt;a class=&#34;tag-Link&#34; target=&#34;_blank&#34; href=&#34;/archives/generator&#34;&gt;
    &lt;div class=&#34;tag-link-bottom&#34;&gt;
        &lt;div class=&#34;tag-link-left&#34; style=&#34;background-image: url(/img/512.png)&#34;&gt;
          &lt;i class=&#34;anzhiyufont anzhiyu-icon-link&#34; style=&#34;display: none&#34;&gt;&lt;/i&gt;
        &lt;/div&gt;
        &lt;div class=&#34;tag-link-right&#34;&gt;
            &lt;div class=&#34;tag-link-title&#34;&gt;生成器函数与 yield&lt;/div&gt;
            &lt;div class=&#34;tag-link-sitename&#34;&gt; Touko&lt;/div&gt;
        &lt;/div&gt;
        &lt;i class=&#34;anzhiyufont anzhiyu-icon-angle-right&#34;&gt;&lt;/i&gt;
    &lt;/div&gt;
    &lt;/a&gt;&lt;/div&gt;

&lt;h2 id=&#34;一、Async-Await-的本质：老熟人的默契配合&#34;&gt;&lt;a href=&#34;#一、Async-Await-的本质：老熟人的默契配合&#34; class=&#34;headerlink&#34; title=&#34;一、Async/Await 的本质：老熟人的默契配合&#34;&gt;&lt;/a&gt;一、Async / Await 的本质：老熟人的默契配合&lt;/h2&gt;&lt;p&gt;你可能觉得 Async / Await 是 JavaScript 里的 “新黑科技”，但其实它的底层是三个老熟人在搭班子干活。说穿了，就是把咱们早就眼熟的技术组合得更顺手了。&lt;/p&gt;
&lt;h3 id=&#34;1-1-三大核心组件&#34;&gt;&lt;a href=&#34;#1-1-三大核心组件&#34; class=&#34;headerlink&#34; title=&#34;1.1 三大核心组件&#34;&gt;&lt;/a&gt;1.1 三大核心组件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Generator（生成器）&lt;/strong&gt;：提供&lt;strong&gt;暂停 - 恢复&lt;/strong&gt;的能力，就像给函数装了个暂停键&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Promise&lt;/strong&gt;：处理&lt;strong&gt;异步操作&lt;/strong&gt;的 “标准接口”，负责管理异步结果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动执行器&lt;/strong&gt;：默默工作的&lt;strong&gt;调度员&lt;/strong&gt;，悄悄驱动生成器跑完全程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-从代码看转换逻辑&#34;&gt;&lt;a href=&#34;#1-2-从代码看转换逻辑&#34; class=&#34;headerlink&#34; title=&#34;1.2 从代码看转换逻辑&#34;&gt;&lt;/a&gt;1.2 从代码看转换逻辑&lt;/h3&gt;&lt;p&gt;咱们写的 Async 函数，其实会被引擎偷偷转换成类似生成器的结构。比如这样一段代码：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 咱们写的优雅代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchData&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; data = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; api.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;/data&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;process&lt;/span&gt;(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;引擎背地里会把它转成差不多这样（简化版）：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 引擎实际处理的样子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchData&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// spawn就是那个自动执行器，负责驱动生成器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;spawn&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt;* () {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; data = &lt;span class=&#34;keyword&#34;&gt;yield&lt;/span&gt; api.&lt;span class=&#34;title function_&#34;&gt;get&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;/data&#39;&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 用yield代替await&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;process&lt;/span&gt;(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;div class=&#34;note info flat&#34;&gt;&lt;p&gt;&lt;strong&gt;这里有个小细节：&lt;/strong&gt; 每个 Async 函数都被转换成一个生成器函数，由&lt;mark&gt;自动执行器&lt;/mark&gt;接管执行！&lt;/p&gt;咱们不用手动调用&lt;code&gt;next()&lt;/code&gt;，全是执行器在后台搞定，这也是&lt;code&gt;Async/Await&lt;/code&gt;比直接用&lt;code&gt;Generator&lt;/code&gt;方便的地方～&lt;/div&gt;

&lt;h2 id=&#34;二、自动执行器：幕后的引擎&#34;&gt;&lt;a href=&#34;#二、自动执行器：幕后的引擎&#34; class=&#34;headerlink&#34; title=&#34;二、自动执行器：幕后的引擎&#34;&gt;&lt;/a&gt;二、自动执行器：幕后的引擎&lt;/h2&gt;&lt;p&gt;自动执行器是 Async / Await 能自动跑起来的关键，我试着简化了它的核心代码，大概长这样：&lt;/p&gt;
&lt;h3 id=&#34;2-1-核心逻辑（简化版）&#34;&gt;&lt;a href=&#34;#2-1-核心逻辑（简化版）&#34; class=&#34;headerlink&#34; title=&#34;2.1 核心逻辑（简化版）&#34;&gt;&lt;/a&gt;2.1 核心逻辑（简化版）&lt;/h3&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;spawn&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;generatorFunc&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 返回一个Promise，这也是async函数总返回Promise的原因&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; generator = &lt;span class=&#34;title function_&#34;&gt;generatorFunc&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 创建生成器实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 步进函数：驱动生成器一步步执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;step&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;nextFn&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; { value, done } = &lt;span class=&#34;title function_&#34;&gt;nextFn&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 执行到下一个yield&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (done) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;comment&#34;&gt;// 生成器跑完了，把结果传给Promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;resolve&lt;/span&gt;(value);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 把yield后的结果包装成Promise（不管是不是Promise）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;resolve&lt;/span&gt;(value).&lt;span class=&#34;title function_&#34;&gt;then&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;comment&#34;&gt;// 成功了就把结果传给下一次next()，继续执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;v&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;step&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; generator.&lt;span class=&#34;title function_&#34;&gt;next&lt;/span&gt;(v)),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;comment&#34;&gt;// 失败了就把错误抛回生成器，让try/catch接住&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;step&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; generator.&lt;span class=&#34;keyword&#34;&gt;throw&lt;/span&gt;(e)),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        );&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      } &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (e) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 捕获生成器内部的错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title function_&#34;&gt;reject&lt;/span&gt;(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 启动生成器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;title function_&#34;&gt;step&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; generator.&lt;span class=&#34;title function_&#34;&gt;next&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;2-2-执行过程图解&#34;&gt;&lt;a href=&#34;#2-2-执行过程图解&#34; class=&#34;headerlink&#34; title=&#34;2.2 执行过程图解&#34;&gt;&lt;/a&gt;2.2 执行过程图解&lt;/h3&gt;&lt;p&gt;我画了个流程图帮大家理解，其实就是执行器在中间当 “裁判”，协调生成器和异步操作：&lt;/p&gt;
&lt;div class=&#34;mermaid-wrap&#34;&gt;&lt;pre class=&#34;mermaid-src&#34; hidden=&#34;&#34;&gt;  sequenceDiagram
participant 调用者
participant Async 函数
participant 执行器
participant 生成器

    调用者-&amp;gt;&amp;gt;Async函数: 调用 asyncFunc()
    Async函数-&amp;gt;&amp;gt;执行器: “麻烦帮我跑一下这个生成器”
    执行器-&amp;gt;&amp;gt;生成器: “开始执行咯（调用next()）”
    生成器--&amp;gt;&amp;gt;执行器: “遇到await了，先停在这”（返回yield的值）
    执行器-&amp;gt;&amp;gt;Promise: “等你结果出来喊我”
    Promise--&amp;gt;&amp;gt;执行器: “搞定，结果在这”
    执行器-&amp;gt;&amp;gt;生成器:  “继续跑吧，这是刚才的结果”（调用next(结果)）
    生成器--&amp;gt;&amp;gt;执行器: “跑完了，这是最终结果”
    执行器-&amp;gt;&amp;gt;调用者: “任务完成，给你结果”（Promise resolved）

  &lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;简单说就是：执行器启动生成器后，每次遇到 yield（也就是咱们写的 await）就停下来等异步结果，拿到结果再叫醒生成器继续跑，直到结束。全程不用手动干预，比直接用 Generator 省太多事了～&lt;/p&gt;
&lt;h2 id=&#34;三、await-到底做了什么？四步看懂它的“小动作”&#34;&gt;&lt;a href=&#34;#三、await-到底做了什么？四步看懂它的“小动作”&#34; class=&#34;headerlink&#34; title=&#34;三、await 到底做了什么？四步看懂它的“小动作”&#34;&gt;&lt;/a&gt;三、await 到底做了什么？四步看懂它的 “小动作”&lt;/h2&gt;&lt;p&gt;每次写&lt;code&gt;await&lt;/code&gt;的时候，引擎其实在背后干了四件事，我拆开来给大家说说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;暂停当前函数&lt;/strong&gt;：就像按了暂停键，当前的变量、执行位置都被 “冻” 起来&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;包装异步结果&lt;/strong&gt;：不管 await 后面是 Promise 还是普通值（比如 await 42），都会被转成 Promise。普通值会被 Promise.resolve() 包一层，确保统一用 Promise 处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注册回调&lt;/strong&gt;：把 await 后面的代码（比如拿到 data 后处理的逻辑）打包成一个微任务，注册到事件循环里&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;让出主线程&lt;/strong&gt;：当前函数暂停后，主线程会去执行其他任务（比如渲染、处理其他事件），等 Promise 有结果了，再回头执行刚才打包的微任务&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;note info flat&#34;&gt;&lt;p&gt;&lt;strong&gt;这里有个性能小细节：&lt;/strong&gt; &lt;code&gt;await&lt;/code&gt;不会阻塞主线程！它只是把后续代码挂起（包装成&lt;mark&gt;微任务&lt;/mark&gt;），让主线程先忙别的。这也是为什么用&lt;code&gt;await&lt;/code&gt;的时候，页面不会卡 —— 因为它会主动 “让道”。&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;四、错误处理：try-catch-居然能管到异步操作？&#34;&gt;&lt;a href=&#34;#四、错误处理：try-catch-居然能管到异步操作？&#34; class=&#34;headerlink&#34; title=&#34;四、错误处理：try/catch 居然能管到异步操作？&#34;&gt;&lt;/a&gt;四、错误处理：try / catch 居然能管到异步操作？&lt;/h2&gt;&lt;p&gt;这是我觉得 Async/Await 最方便的一点：用同步代码里的 try/catch 就能搞定异步错误，不用像回调那样嵌套多层 error 处理。&lt;/p&gt;
&lt;h3 id=&#34;4-1-同步式的错误处理&#34;&gt;&lt;a href=&#34;#4-1-同步式的错误处理&#34; class=&#34;headerlink&#34; title=&#34;4.1 同步式的错误处理&#34;&gt;&lt;/a&gt;4.1 同步式的错误处理&lt;/h3&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchUser&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; user = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;/user&#39;&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 可能失败&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; posts = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`/posts/&lt;span class=&#34;subst&#34;&gt;${user.id}&lt;/span&gt;`&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 依赖上一步结果，也可能失败&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; { user, posts };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  } &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (error) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 不管哪一步失败，都会跑到这里&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;error&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;请求失败:&#39;&lt;/span&gt;, error);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; { &lt;span class=&#34;attr&#34;&gt;user&lt;/span&gt;: &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;posts&lt;/span&gt;: [] };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;4-2-背后的错误传递&#34;&gt;&lt;a href=&#34;#4-2-背后的错误传递&#34; class=&#34;headerlink&#34; title=&#34;4.2 背后的错误传递&#34;&gt;&lt;/a&gt;4.2 背后的错误传递&lt;/h3&gt;&lt;p&gt;为什么 try / catch 能抓到异步错误？秘密在自动执行器的这段代码里：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 自动执行器处理Promise的部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;resolve&lt;/span&gt;(value).&lt;span class=&#34;title function_&#34;&gt;then&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;v&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;step&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; generator.&lt;span class=&#34;title function_&#34;&gt;next&lt;/span&gt;(v)), &lt;span class=&#34;comment&#34;&gt;// 成功就传结果继续执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;step&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; generator.&lt;span class=&#34;keyword&#34;&gt;throw&lt;/span&gt;(e)), &lt;span class=&#34;comment&#34;&gt;// 失败就把错误抛回生成器！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;当 await 后面的 Promise 失败时，执行器会调用&lt;code&gt;generator.throw(e)&lt;/code&gt;，把错误 “扔回” 生成器函数内部。这时候生成器里的 try / catch 就会像捕获同步错误一样，把这个异步错误接住。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;之前用回调的时候，每次异步操作都要单独写 error 处理，现在一个 try / catch 全搞定，代码清爽多了～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;五、性能优化：我在项目里掉过的性能坑&#34;&gt;&lt;a href=&#34;#五、性能优化：我在项目里掉过的性能坑&#34; class=&#34;headerlink&#34; title=&#34;五、性能优化：我在项目里掉过的性能坑&#34;&gt;&lt;/a&gt;五、性能优化：我在项目里掉过的性能坑&lt;/h2&gt;&lt;p&gt;分享几个我实际开发中遇到的问题，都是关于 Async / Await 性能的，新手很容易踩坑：&lt;/p&gt;
&lt;h3 id=&#34;5-1-坑一：没必要的顺序执行&#34;&gt;&lt;a href=&#34;#5-1-坑一：没必要的顺序执行&#34; class=&#34;headerlink&#34; title=&#34;5.1 坑一：没必要的顺序执行&#34;&gt;&lt;/a&gt;5.1 坑一：没必要的顺序执行&lt;/h3&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 反面例子：两个请求本来可以同时跑，却写成了顺序执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;slowFetch&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; a = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchA&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; b = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchB&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 等A完了才开始B&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; [a, b];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这两个请求如果没依赖关系（比如 A 不影响 B 的参数），完全可以同时启动，我后来改成这样：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 优化后：同时启动两个请求，总耗时是最慢那个的时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fastFetch&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 先同时发起请求，拿到两个Promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; promiseA = &lt;span class=&#34;title function_&#34;&gt;fetchA&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; promiseB = &lt;span class=&#34;title function_&#34;&gt;fetchB&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 再等它们结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; a = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; promiseA;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; b = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; promiseB;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; [a, b];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;5-2-坑二：多余的-await-包装&#34;&gt;&lt;a href=&#34;#5-2-坑二：多余的-await-包装&#34; class=&#34;headerlink&#34; title=&#34;5.2 坑二：多余的 await 包装&#34;&gt;&lt;/a&gt;5.2 坑二：多余的 await 包装&lt;/h3&gt;&lt;p&gt;有时候会下意识地在 return 前面加 await，但其实没必要：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 多余的await&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getData&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchData&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// fetchData本身已经返回Promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;因为 Async 函数会自动把返回值包成 Promise，这里的 await 纯属多此一举，直接 return 就行：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 更简洁高效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getData&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchData&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 等价于上面的写法，但少一层Promise包装&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;5-3-多个异步操作：用-Promise-all-处理并行&#34;&gt;&lt;a href=&#34;#5-3-多个异步操作：用-Promise-all-处理并行&#34; class=&#34;headerlink&#34; title=&#34;5.3 多个异步操作：用 Promise.all()处理并行&#34;&gt;&lt;/a&gt;5.3 多个异步操作：用 Promise.all() 处理并行&lt;/h3&gt;&lt;p&gt;如果需要等多个异步操作都完成，&lt;code&gt;Promise.all()&lt;/code&gt;配合 await 是绝配，下面的写法在实际项目中会经常用到哦~&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchAll&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 同时启动，等所有请求完成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; [user, posts] = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;all&lt;/span&gt;([&lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;/user&#39;&lt;/span&gt;), &lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;/posts&#39;&lt;/span&gt;)]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; { user, posts };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;div class=&#34;note warning flat&#34;&gt;&lt;p&gt;&lt;strong&gt;不过要注意：&lt;/strong&gt; &lt;code&gt;Promise.all()&lt;/code&gt;是 “一损俱损”，只要有一个请求失败，整个就会报错，这时候可以用&lt;code&gt;Promise.allSettled()&lt;/code&gt;处理需要全部结果的场景（哪怕部分失败）。&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;5-4-高级技巧：模块里的顶级-await&#34;&gt;&lt;a href=&#34;#5-4-高级技巧：模块里的顶级-await&#34; class=&#34;headerlink&#34; title=&#34;5.4 高级技巧：模块里的顶级 await&#34;&gt;&lt;/a&gt;5.4 高级技巧：模块里的顶级 await&lt;/h3&gt;&lt;p&gt;现在很多打包工具（比如 Webpack、Vite）已经支持模块顶层的 await 了，不用再包在 Async 函数里：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 直接在模块顶层用await&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; config = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;loadConfig&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 加载配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; settings = &lt;span class=&#34;title function_&#34;&gt;process&lt;/span&gt;(config);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 其实引擎会把模块转成类似这样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;loadConfig&lt;/span&gt;().&lt;span class=&#34;title function_&#34;&gt;then&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;config&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; settings = &lt;span class=&#34;title function_&#34;&gt;process&lt;/span&gt;(config);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我在做一个工具库的时候用过这个，用来加载动态配置，比以前用 IIFE（立即执行函数）清爽多了。&lt;/p&gt;
&lt;h2 id=&#34;六、Async-Await-实战场景：这些地方用起来超顺手&#34;&gt;&lt;a href=&#34;#六、Async-Await-实战场景：这些地方用起来超顺手&#34; class=&#34;headerlink&#34; title=&#34;六、Async/Await 实战场景：这些地方用起来超顺手&#34;&gt;&lt;/a&gt;六、Async / Await 实战场景：这些地方用起来超顺手&lt;/h2&gt;&lt;h3 id=&#34;6-1-异步初始化（比如数据库连接）&#34;&gt;&lt;a href=&#34;#6-1-异步初始化（比如数据库连接）&#34; class=&#34;headerlink&#34; title=&#34;6.1 异步初始化（比如数据库连接）&#34;&gt;&lt;/a&gt;6.1 异步初始化（比如数据库连接）&lt;/h3&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Database&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 静态方法做异步初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;init&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; connection = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;createConnection&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 建立连接（异步）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Database&lt;/span&gt;(connection);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 使用的时候直接await&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; db = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Database&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;init&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这种场景如果用回调，很容易写成嵌套的 init 回调，用 Async / Await 就清晰多了。&lt;/p&gt;
&lt;h3 id=&#34;6-2-有依赖关系的顺序请求&#34;&gt;&lt;a href=&#34;#6-2-有依赖关系的顺序请求&#34; class=&#34;headerlink&#34; title=&#34;6.2 有依赖关系的顺序请求&#34;&gt;&lt;/a&gt;6.2 有依赖关系的顺序请求&lt;/h3&gt;&lt;p&gt;比如先拿用户 ID，再用 ID 查订单：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;purchase&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;itemId&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; user = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getUser&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 先查用户&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; item = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getItem&lt;/span&gt;(itemId); &lt;span class=&#34;comment&#34;&gt;// 再查商品&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;validatePurchase&lt;/span&gt;(user, item); &lt;span class=&#34;comment&#34;&gt;// 验证能否购买（异步）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; receipt = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;createReceipt&lt;/span&gt;(user, item); &lt;span class=&#34;comment&#34;&gt;// 生成订单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; receipt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;步骤再复杂，用顺序 await 写出来也像同步代码一样好懂。&lt;/p&gt;
&lt;h3 id=&#34;6-3-带重试的请求&#34;&gt;&lt;a href=&#34;#6-3-带重试的请求&#34; class=&#34;headerlink&#34; title=&#34;6.3 带重试的请求&#34;&gt;&lt;/a&gt;6.3 带重试的请求&lt;/h3&gt;&lt;p&gt;处理可能偶尔失败的接口时，用 Async / Await 写重试逻辑很直观：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchWithRetry&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;url, retries = &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(url);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  } &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (error) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (retries &amp;lt;= &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;) &lt;span class=&#34;keyword&#34;&gt;throw&lt;/span&gt; error; &lt;span class=&#34;comment&#34;&gt;// 重试次数用完&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;delay&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1000&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 等1秒再重试&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchWithRetry&lt;/span&gt;(url, retries - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 递归重试&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我在对接一个不稳定的第三方接口时，就用这个逻辑做了重试，成功率提高了不少。&lt;/p&gt;
&lt;h3 id=&#34;6-4-超时控制（防止请求卡太久）&#34;&gt;&lt;a href=&#34;#6-4-超时控制（防止请求卡太久）&#34; class=&#34;headerlink&#34; title=&#34;6.4 超时控制（防止请求卡太久）&#34;&gt;&lt;/a&gt;6.4 超时控制（防止请求卡太久）&lt;/h3&gt;&lt;p&gt;结合&lt;code&gt;Promise.race()&lt;/code&gt;实现超时控制：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchWithTimeout&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;url, timeout = &lt;span class=&#34;number&#34;&gt;5000&lt;/span&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; fetchPromise = &lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(url);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 超时Promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; timeoutPromise = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;_, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;setTimeout&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;reject&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Error&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;请求超时&#39;&lt;/span&gt;)), timeout),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 谁先完成就用谁的结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;race&lt;/span&gt;([fetchPromise, timeoutPromise]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这个在做支付回调的时候特别有用，防止因为网络问题让用户一直等。&lt;/p&gt;
&lt;h2 id=&#34;七、踩过的坑：这些细节要注意&#34;&gt;&lt;a href=&#34;#七、踩过的坑：这些细节要注意&#34; class=&#34;headerlink&#34; title=&#34;七、踩过的坑：这些细节要注意&#34;&gt;&lt;/a&gt;七、踩过的坑：这些细节要注意&lt;/h2&gt;&lt;h3 id=&#34;7-1-箭头函数的-this-陷阱&#34;&gt;&lt;a href=&#34;#7-1-箭头函数的-this-陷阱&#34; class=&#34;headerlink&#34; title=&#34;7.1 箭头函数的 this 陷阱&#34;&gt;&lt;/a&gt;7.1 箭头函数的 this 陷阱&lt;/h3&gt;&lt;p&gt;用 Async 箭头函数当对象方法时，&lt;code&gt;this&lt;/code&gt;会丢：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 有问题：this指向不对&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; obj = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;value&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;42&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;print&lt;/span&gt;: &lt;span class=&#34;title function_&#34;&gt;async&lt;/span&gt; () =&amp;gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;value&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// undefined! 因为箭头函数的this是定义时的上下文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 正确写法：用传统函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; obj = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;value&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;42&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;print&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;value&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 42，this指向obj&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我在写一个类的方法时犯过这个错，调试了半天才发现是箭头函数的锅。&lt;/p&gt;
&lt;h3 id=&#34;7-2-控制并发数量&#34;&gt;&lt;a href=&#34;#7-2-控制并发数量&#34; class=&#34;headerlink&#34; title=&#34;7.2 控制并发数量&#34;&gt;&lt;/a&gt;7.2 控制并发数量&lt;/h3&gt;&lt;p&gt;如果并行请求太多（比如一次发 20 个接口），可能会触发浏览器的并发限制，这时候需要控制并发数：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;processBatch&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;items&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; promises = items.&lt;span class=&#34;title function_&#34;&gt;map&lt;/span&gt;(processItem); &lt;span class=&#34;comment&#34;&gt;// 所有任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 控制最多同时跑5个&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; results = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;throttlePromises&lt;/span&gt;(promises, &lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; results;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里的&lt;code&gt;throttlePromises&lt;/code&gt;是一个工具函数，原理是把任务分成多批，一批批执行（每批 5 个），避免一次性发起太多请求。&lt;/p&gt;
&lt;h3 id=&#34;7-3-可取消的异步任务（结合-AbortSignal）&#34;&gt;&lt;a href=&#34;#7-3-可取消的异步任务（结合-AbortSignal）&#34; class=&#34;headerlink&#34; title=&#34;7.3 可取消的异步任务（结合 AbortSignal）&#34;&gt;&lt;/a&gt;7.3 可取消的异步任务（结合 AbortSignal）&lt;/h3&gt;&lt;p&gt;有时候需要中途取消异步操作（比如用户离开页面），可以用&lt;code&gt;AbortSignal&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;longRunningTask&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;abortSignal&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (!abortSignal.&lt;span class=&#34;property&#34;&gt;aborted&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;doWork&lt;/span&gt;();&lt;span class=&#34;comment&#34;&gt;// 每次做一点工作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 每次循环检查退出信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (abortSignal.&lt;span class=&#34;property&#34;&gt;aborted&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;cleanup&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 做清理工作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; controller = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;AbortController&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; signal = controller.&lt;span class=&#34;property&#34;&gt;signal&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 启动长时间运行的任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;longRunningTask&lt;/span&gt;(signal);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; cancelTask {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  controller.&lt;span class=&#34;title function_&#34;&gt;abort&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 中止任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 设置一个定时器，以便在 3 秒后中止任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;setTimeout&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;cancelTask&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}, &lt;span class=&#34;number&#34;&gt;3000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我在做一个文件上传组件时用过这个，用户点取消按钮时，就通过&lt;code&gt;AbortSignal&lt;/code&gt;终止上传。&lt;/p&gt;
&lt;h2 id=&#34;八、常见问题解答（我当初学的时候也纠结过）&#34;&gt;&lt;a href=&#34;#八、常见问题解答（我当初学的时候也纠结过）&#34; class=&#34;headerlink&#34; title=&#34;八、常见问题解答（我当初学的时候也纠结过）&#34;&gt;&lt;/a&gt;八、常见问题解答（我当初学的时候也纠结过）&lt;/h2&gt;&lt;h3 id=&#34;Q1-Async-函数会阻塞主线程吗？&#34;&gt;&lt;a href=&#34;#Q1-Async-函数会阻塞主线程吗？&#34; class=&#34;headerlink&#34; title=&#34;Q1: Async 函数会阻塞主线程吗？&#34;&gt;&lt;/a&gt;Q1: Async 函数会阻塞主线程吗？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;不会！&lt;/strong&gt; Async 函数遇到 await 时会&lt;strong&gt;暂停并释放主线程&lt;/strong&gt;，JavaScript 的单线程模型通过事件循环实现异步执行。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;test&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;开始&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;delay&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1000&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 假设delay是个等待1秒的Promise&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;结束&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;执行到 await 时，函数会暂停，主线程可以去处理其他任务（比如点击事件、渲染），等 1 秒后才回头执行 console.log(‘结束’)，所以不会卡页面。&lt;/p&gt;
&lt;h3 id=&#34;Q2-可以-await-一个非-Promise-值吗？&#34;&gt;&lt;a href=&#34;#Q2-可以-await-一个非-Promise-值吗？&#34; class=&#34;headerlink&#34; title=&#34;Q2: 可以 await 一个非 Promise 值吗？&#34;&gt;&lt;/a&gt;Q2: 可以 await 一个非 Promise 值吗？&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;可以！&lt;/strong&gt; 引擎会自动用 &lt;code&gt;Promise.resolve()&lt;/code&gt; 包装非 Promise 值：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;getNumber&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; num = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;42&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 合法！等价于 await Promise.resolve(42)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;不过实际开发中很少这么用，一般 await 后面都是异步操作返回的 Promise。&lt;/p&gt;
&lt;h3 id=&#34;Q3-为什么-Async-函数不管-return-什么，最后都返回-Promise？&#34;&gt;&lt;a href=&#34;#Q3-为什么-Async-函数不管-return-什么，最后都返回-Promise？&#34; class=&#34;headerlink&#34; title=&#34;Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？&#34;&gt;&lt;/a&gt;Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？&lt;/h3&gt;&lt;p&gt;因为它本质是异步操作的包装器。哪怕你 return 一个原始值，引擎也会用 Promise.resolve() 包一层：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;answer&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;42&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 等价于 return Promise.resolve(42)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;所以调用 Async 函数时，必须用&lt;code&gt;await&lt;/code&gt;或者&lt;code&gt;.then()&lt;/code&gt;才能拿到结果。&lt;/p&gt;
&lt;h3 id=&#34;Q4-用-Promise-all-的时候，如果有一个请求失败怎么办？&#34;&gt;&lt;a href=&#34;#Q4-用-Promise-all-的时候，如果有一个请求失败怎么办？&#34; class=&#34;headerlink&#34; title=&#34;Q4: 用 Promise.all()的时候，如果有一个请求失败怎么办？&#34;&gt;&lt;/a&gt;Q4: 用 Promise.all() 的时候，如果有一个请求失败怎么办？&lt;/h3&gt;&lt;p&gt;之前已经提到过了，Promise.all() 会 “快速失败”—— 只要有一个 Promise 被拒绝，整个 Promise.all() 就会立刻失败，进入 catch。如果需要等所有请求完成（不管成功失败），可以用&lt;code&gt;Promise.allSettled()&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetchAll&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; results = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Promise&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;allSettled&lt;/span&gt;([&lt;span class=&#34;title function_&#34;&gt;fetchA&lt;/span&gt;(), &lt;span class=&#34;title function_&#34;&gt;fetchB&lt;/span&gt;()]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 过滤出成功的结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; successData = results.&lt;span class=&#34;title function_&#34;&gt;filter&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;r&lt;/span&gt;) =&amp;gt;&lt;/span&gt; r.&lt;span class=&#34;property&#34;&gt;status&lt;/span&gt; === &lt;span class=&#34;string&#34;&gt;&#39;fulfilled&#39;&lt;/span&gt;).&lt;span class=&#34;title function_&#34;&gt;map&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;r&lt;/span&gt;) =&amp;gt;&lt;/span&gt; r.&lt;span class=&#34;property&#34;&gt;value&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;Q5-为什么说-Async-Await-比回调好？&#34;&gt;&lt;a href=&#34;#Q5-为什么说-Async-Await-比回调好？&#34; class=&#34;headerlink&#34; title=&#34;Q5: 为什么说 Async/Await 比回调好？&#34;&gt;&lt;/a&gt;Q5: 为什么说 Async / Await 比回调好？&lt;/h3&gt;&lt;p&gt;我总结了几个实际开发中的感受：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码不嵌套，扁平结构更易读（告别 “回调地狱”）&lt;/li&gt;
&lt;li&gt;错误处理统一用 try / catch，不用每层回调都写 error 处理&lt;/li&gt;
&lt;li&gt;逻辑顺序和代码执行顺序一致，不用跳来跳去看代码&lt;/li&gt;
&lt;li&gt;调试更方便，错误堆栈更完整（回调的堆栈经常被异步操作打断）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;其实 Async/Await 不算什么高深的技术，就是把 Generator、Promise 这些老东西包装得更好用了。但正是这种 “语法糖”，让我们写异步代码时能少掉很多头发～ 如果你也有过用 Async/Await 踩坑的经历，欢迎在评论区分享呀！&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://toukoxu.github.io/archives/message-channel/</guid>
            <title>MessageChannel 详解：浏览器中的 “点对点双向通信管道”</title>
            <link>http://toukoxu.github.io/archives/message-channel/</link>
            <category>JavaScript</category>
            <category>性能优化</category>
            <pubDate>Sun, 23 Jun 2024 20:46:25 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;MessageChannel&lt;/code&gt; 是浏览器提供的&lt;strong&gt;点对点双向通信 API&lt;/strong&gt;，核心是创建一对关联的 “通信端口”（&lt;code&gt;port1&lt;/code&gt; 和 &lt;code&gt;port2&lt;/code&gt;），让不同上下文（比如主线程与 Worker、父页面与 iframe）能安全、高效地传递消息。它不像全局事件那样容易污染，也比普通 &lt;code&gt;postMessage&lt;/code&gt; 更专注于 “一对一” 通信场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一、核心概念：从创建到通信的基本流程&#34;&gt;&lt;a href=&#34;#一、核心概念：从创建到通信的基本流程&#34; class=&#34;headerlink&#34; title=&#34;一、核心概念：从创建到通信的基本流程&#34;&gt;&lt;/a&gt;一、核心概念：从创建到通信的基本流程&lt;/h2&gt;&lt;p&gt;&lt;code&gt;MessageChannel&lt;/code&gt; 的用法很直观：先创建通道，拿到两个端口，再通过端口的 &lt;code&gt;postMessage&lt;/code&gt; 发消息、&lt;code&gt;onmessage&lt;/code&gt; 收消息，形成双向通信链路。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 1. 创建一个 MessageChannel 实例（相当于建立一条通信管道）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; channel = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MessageChannel&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 2. 从管道中获取两个相互关联的端口（port1 和 port2 是“一对”）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; port1 = channel.&lt;span class=&#34;property&#34;&gt;port1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; port2 = channel.&lt;span class=&#34;property&#34;&gt;port2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 3. 端口1 发送消息（可传字符串、对象等结构化数据）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;port1.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;你好，我是 port1！&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 4. 端口2 监听并接收消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;port2.&lt;span class=&#34;property&#34;&gt;onmessage&lt;/span&gt; = &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;port2 收到消息：&#39;&lt;/span&gt;, event.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 输出“你好，我是 port1！”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 5. 端口2 也能回复消息（双向通信）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  port2.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;收到啦，port1！&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 6. 端口1 接收端口2 的回复&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;port1.&lt;span class=&#34;property&#34;&gt;onmessage&lt;/span&gt; = &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;port1 收到回复：&#39;&lt;/span&gt;, event.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 输出“收到啦，port1！”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里有个关键逻辑：&lt;code&gt;port1&lt;/code&gt; 发的消息只有 &lt;code&gt;port2&lt;/code&gt; 能收，&lt;code&gt;port2&lt;/code&gt; 发的消息也只有 &lt;code&gt;port1&lt;/code&gt; 能收 —— 它们是 “点对点绑定” 的，不会被其他上下文干扰。&lt;/p&gt;
&lt;h2 id=&#34;二、MessageChannel-的核心特性&#34;&gt;&lt;a href=&#34;#二、MessageChannel-的核心特性&#34; class=&#34;headerlink&#34; title=&#34;二、MessageChannel 的核心特性&#34;&gt;&lt;/a&gt;二、MessageChannel 的核心特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;双向平等通信&lt;/strong&gt;：&lt;code&gt;port1&lt;/code&gt; 和 &lt;code&gt;port2&lt;/code&gt; 没有 “主从” 之分，双方都能主动发消息、收消息，通信是双向的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;独立消息队列&lt;/strong&gt;：每个端口都有自己的消息队列，消息按发送顺序处理，不会出现 “插队” 或混乱。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同源安全限制&lt;/strong&gt;：和 &lt;code&gt;postMessage&lt;/code&gt; 一样，默认遵循同源策略（协议、域名、端口一致），跨域通信需要额外配置（如 &lt;code&gt;postMessage&lt;/code&gt; 的目标 Origin）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持 “可转移对象”&lt;/strong&gt;：能传递 &lt;code&gt;ArrayBuffer&lt;/code&gt;、&lt;code&gt;MessagePort&lt;/code&gt; 这类特殊对象，转移后原上下文会失去对对象的控制权（避免数据拷贝，提升性能）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;低延迟任务调度&lt;/strong&gt;：比 &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; 更高效 ——&lt;code&gt;MessageChannel&lt;/code&gt; 的消息回调会进入 “微任务队列”，执行时机更早，延迟更低。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;三、实战场景：这些地方用-MessageChannel-更合适&#34;&gt;&lt;a href=&#34;#三、实战场景：这些地方用-MessageChannel-更合适&#34; class=&#34;headerlink&#34; title=&#34;三、实战场景：这些地方用 MessageChannel 更合适&#34;&gt;&lt;/a&gt;三、实战场景：这些地方用 MessageChannel 更合适&lt;/h2&gt;&lt;h3 id=&#34;3-1-主线程与-Web-Worker-的“专用通信”&#34;&gt;&lt;a href=&#34;#3-1-主线程与-Web-Worker-的“专用通信”&#34; class=&#34;headerlink&#34; title=&#34;3.1 主线程与 Web Worker 的“专用通信”&#34;&gt;&lt;/a&gt;3.1 主线程与 Web Worker 的 “专用通信”&lt;/h3&gt;&lt;p&gt;Web Worker 是主线程之外的独立线程，两者通信常用 &lt;code&gt;postMessage&lt;/code&gt;，但如果需要 “长期、专用” 的通信链路（比如频繁传递大数据），&lt;code&gt;MessageChannel&lt;/code&gt; 更合适 —— 避免和其他消息混在一起。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 主线程代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; worker = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Worker&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;worker.js&#39;&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 新建 Worker&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; channel = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MessageChannel&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 创建通信管道&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 把 port2 传给 Worker（通过 postMessage 的“转移列表”，确保端口唯一）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;worker.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;初始化通信端口&#39;&lt;/span&gt;, [channel.&lt;span class=&#34;property&#34;&gt;port2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 主线程通过 port1 与 Worker 通信&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;channel.&lt;span class=&#34;property&#34;&gt;port1&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;onmessage&lt;/span&gt; = &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;主线程收到 Worker 消息：&#39;&lt;/span&gt;, event.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 主线程给 Worker 发消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;channel.&lt;span class=&#34;property&#34;&gt;port1&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;({ &lt;span class=&#34;attr&#34;&gt;type&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;FETCH_DATA&#39;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;url&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;/api/data&#39;&lt;/span&gt; });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// ------------------------------&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// worker.js（Worker 线程代码）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;self.&lt;span class=&#34;property&#34;&gt;onmessage&lt;/span&gt; = &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 接收主线程传来的 port2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (event.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt; === &lt;span class=&#34;string&#34;&gt;&#39;初始化通信端口&#39;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; port = event.&lt;span class=&#34;property&#34;&gt;ports&lt;/span&gt;[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;]; &lt;span class=&#34;comment&#34;&gt;// 拿到 port2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// Worker 通过 port 接收主线程消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    port.&lt;span class=&#34;property&#34;&gt;onmessage&lt;/span&gt; = &lt;span class=&#34;title function_&#34;&gt;async&lt;/span&gt; (e) =&amp;gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (e.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;type&lt;/span&gt; === &lt;span class=&#34;string&#34;&gt;&#39;FETCH_DATA&#39;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 模拟请求数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; res = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(e.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;url&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; data = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; res.&lt;span class=&#34;title function_&#34;&gt;json&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 把数据发回主线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        port.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;({ &lt;span class=&#34;attr&#34;&gt;type&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;DATA_SUCCESS&#39;&lt;/span&gt;, data });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这种方式的好处是：主线程与 Worker 的通信被 “隔离” 在这对端口中，不会和其他 &lt;code&gt;worker.postMessage&lt;/code&gt; 消息混淆。&lt;/p&gt;
&lt;h3 id=&#34;3-2-父页面与-iframe-的跨上下文通信&#34;&gt;&lt;a href=&#34;#3-2-父页面与-iframe-的跨上下文通信&#34; class=&#34;headerlink&#34; title=&#34;3.2 父页面与 iframe 的跨上下文通信&#34;&gt;&lt;/a&gt;3.2 父页面与 iframe 的跨上下文通信&lt;/h3&gt;&lt;p&gt;如果页面里有 iframe，且需要和 iframe 进行 “一对一” 通信（比如父子页面传递表单数据），&lt;code&gt;MessageChannel&lt;/code&gt; 比直接用 &lt;code&gt;iframe.contentWindow.postMessage&lt;/code&gt; 更安全（避免消息被其他 iframe 监听）。&lt;/p&gt;
&lt;figure class=&#34;highlight html&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;&amp;lt;!-- 父页面代码 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;iframe&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;id&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;childIframe&#34;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;src&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;child.html&#34;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;iframe&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;language-javascript&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; iframe = &lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getElementById&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;childIframe&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; channel = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MessageChannel&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 等 iframe 加载完成后，传递 port2 给子页面&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  iframe.&lt;span class=&#34;property&#34;&gt;onload&lt;/span&gt; = &lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 第三个参数是“转移列表”，把 port2 的控制权转给 iframe&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;    iframe.&lt;span class=&#34;property&#34;&gt;contentWindow&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;绑定通信端口&#39;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&#39;*&#39;&lt;/span&gt;, [channel.&lt;span class=&#34;property&#34;&gt;port2&lt;/span&gt;]);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  };&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 父页面通过 port1 接收 iframe 消息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  channel.&lt;span class=&#34;property&#34;&gt;port1&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;onmessage&lt;/span&gt; = &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;父页面收到 iframe 消息：&#39;&lt;/span&gt;, event.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 比如收到 iframe 传来的表单数据，做后续处理&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  };&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 父页面给 iframe 发消息（比如传递配置）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  channel.&lt;span class=&#34;property&#34;&gt;port1&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;({ &lt;span class=&#34;attr&#34;&gt;theme&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;dark&#39;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;userId&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;123&lt;/span&gt; });&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;&amp;lt;!-- child.html（iframe 子页面代码） --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;language-javascript&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 监听父页面传来的“绑定端口”消息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;window&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;message&#39;&lt;/span&gt;, &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (event.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt; === &lt;span class=&#34;string&#34;&gt;&#39;绑定通信端口&#39;&lt;/span&gt;) {&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; port = event.&lt;span class=&#34;property&#34;&gt;ports&lt;/span&gt;[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;]; &lt;span class=&#34;comment&#34;&gt;// 拿到父页面传来的 port2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 子页面给父页面发消息（比如传递表单数据）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;      port.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;({&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;        &lt;span class=&#34;attr&#34;&gt;formData&lt;/span&gt;: { &lt;span class=&#34;attr&#34;&gt;username&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;test&#39;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;email&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;test@xxx.com&#39;&lt;/span&gt; },&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;      });&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 子页面接收父页面的消息（比如配置）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;      port.&lt;span class=&#34;property&#34;&gt;onmessage&lt;/span&gt; = &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;        &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;iframe 收到父页面配置：&#39;&lt;/span&gt;, e.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 根据配置设置页面主题等&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;      };&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;    }&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  });&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;3-3-非父子组件通信（以-React-为例）&#34;&gt;&lt;a href=&#34;#3-3-非父子组件通信（以-React-为例）&#34; class=&#34;headerlink&#34; title=&#34;3.3 非父子组件通信（以 React 为例）&#34;&gt;&lt;/a&gt;3.3 非父子组件通信（以 React 为例）&lt;/h3&gt;&lt;p&gt;在 React、Vue 等框架中，如果两个组件没有直接的父子关系（比如兄弟组件、跨层级组件），用 &lt;code&gt;MessageChannel&lt;/code&gt; 可以实现 “无侵入” 的通信，不用依赖全局状态（如 Redux）或事件总线。&lt;/p&gt;
&lt;figure class=&#34;highlight jsx&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 1. 先创建一个全局的 MessageChannel（可放在单独的工具文件中）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; componentChannel = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MessageChannel&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 2. 组件 A（发送消息的一方）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;ComponentA&lt;/span&gt; = (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) =&amp;gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 点击按钮时给 ComponentB 发消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;sendMessage&lt;/span&gt; = (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) =&amp;gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    componentChannel.&lt;span class=&#34;property&#34;&gt;port2&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;({&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;attr&#34;&gt;type&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;UPDATE_COUNT&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;attr&#34;&gt;count&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;language-xml&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;button&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;onClick&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;{sendMessage}&lt;/span&gt;&amp;gt;&lt;/span&gt;给 ComponentB 发消息&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 3. 组件 B（接收消息的一方）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;ComponentB&lt;/span&gt; = (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) =&amp;gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; [count, setCount] = &lt;span class=&#34;title class_&#34;&gt;React&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;useState&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 组件挂载时，监听 port1 的消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title class_&#34;&gt;React&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;useEffect&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;handleMessage&lt;/span&gt; = (&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (event.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;type&lt;/span&gt; === &lt;span class=&#34;string&#34;&gt;&#39;UPDATE_COUNT&#39;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title function_&#34;&gt;setCount&lt;/span&gt;(event.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;count&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 更新组件状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 绑定消息监听&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    componentChannel.&lt;span class=&#34;property&#34;&gt;port1&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;onmessage&lt;/span&gt; = handleMessage;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 组件卸载时，关闭端口（避免内存泄漏）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      componentChannel.&lt;span class=&#34;property&#34;&gt;port1&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;close&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }, []);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;language-xml&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;从 ComponentA 收到的 count：{count}&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这种方式的好处是：组件间通信不依赖框架 API，逻辑更独立，也不会污染全局事件。&lt;/p&gt;
&lt;h3 id=&#34;3-4-性能优化：替代-setTimeout-的“微任务调度”&#34;&gt;&lt;a href=&#34;#3-4-性能优化：替代-setTimeout-的“微任务调度”&#34; class=&#34;headerlink&#34; title=&#34;3.4 性能优化：替代 setTimeout 的“微任务调度”&#34;&gt;&lt;/a&gt;3.4 性能优化：替代 setTimeout 的 “微任务调度”&lt;/h3&gt;&lt;p&gt;&lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; 会把任务推到 “宏任务队列”，延迟较高（通常 4ms 以上）；而 &lt;code&gt;MessageChannel&lt;/code&gt; 的消息回调会进入 “微任务队列”，执行时机更早，适合需要 “尽快执行但不阻塞当前同步代码” 的场景（比如 DOM 更新后执行回调）。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 用 MessageChannel 实现“微任务调度”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;scheduleMicroTask&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;task&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; { port1, port2 } = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MessageChannel&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// port1 收到消息后执行任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  port1.&lt;span class=&#34;property&#34;&gt;onmessage&lt;/span&gt; = &lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;title function_&#34;&gt;task&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    port1.&lt;span class=&#34;title function_&#34;&gt;close&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 执行完关闭端口，避免内存泄漏&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 发送一条空消息，触发 port1 的回调&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  port2.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;run&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  port2.&lt;span class=&#34;title function_&#34;&gt;close&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 使用示例：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;同步代码开始&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;scheduleMicroTask&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;微任务执行（MessageChannel）&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;setTimeout&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;宏任务执行（setTimeout）&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}, &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;同步代码结束&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 执行顺序：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 1. 同步代码开始&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 2. 同步代码结束&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 3. 微任务执行（MessageChannel）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 4. 宏任务执行（setTimeout）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;3-5-主线程与-Service-Worker-的双向通信&#34;&gt;&lt;a href=&#34;#3-5-主线程与-Service-Worker-的双向通信&#34; class=&#34;headerlink&#34; title=&#34;3.5 主线程与 Service Worker 的双向通信&#34;&gt;&lt;/a&gt;3.5 主线程与 Service Worker 的双向通信&lt;/h3&gt;&lt;p&gt;Service Worker 负责离线缓存、后台同步等功能，主线程与它通信时，&lt;code&gt;MessageChannel&lt;/code&gt; 可以建立 “长期专用链路”，避免消息混淆（比如同时处理缓存更新和推送通知）。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 主线程代码（页面中）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;string&#34;&gt;&#39;serviceWorker&#39;&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; navigator) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  navigator.&lt;span class=&#34;property&#34;&gt;serviceWorker&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;register&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;/sw.js&#39;&lt;/span&gt;).&lt;span class=&#34;title function_&#34;&gt;then&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;registration&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 注册成功后，创建 MessageChannel&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; channel = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;MessageChannel&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 把 port2 传给 Service Worker&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    registration.&lt;span class=&#34;property&#34;&gt;active&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;绑定 SW 通信端口&#39;&lt;/span&gt;, [channel.&lt;span class=&#34;property&#34;&gt;port2&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 主线程通过 port1 接收 SW 消息（比如缓存更新结果）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    channel.&lt;span class=&#34;property&#34;&gt;port1&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;onmessage&lt;/span&gt; = &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;主线程收到 SW 消息：&#39;&lt;/span&gt;, event.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (event.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;type&lt;/span&gt; === &lt;span class=&#34;string&#34;&gt;&#39;CACHE_UPDATED&#39;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;title function_&#34;&gt;alert&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;缓存已更新，下次访问更快速！&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 主线程给 SW 发消息（比如触发缓存更新）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    channel.&lt;span class=&#34;property&#34;&gt;port1&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;({&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;attr&#34;&gt;type&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;UPDATE_CACHE&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;attr&#34;&gt;urls&lt;/span&gt;: [&lt;span class=&#34;string&#34;&gt;&#39;/index.html&#39;&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&#39;/style.css&#39;&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// ------------------------------&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// sw.js（Service Worker 代码）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;self.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;message&#39;&lt;/span&gt;, &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (event.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt; === &lt;span class=&#34;string&#34;&gt;&#39;绑定 SW 通信端口&#39;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; port = event.&lt;span class=&#34;property&#34;&gt;ports&lt;/span&gt;[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;]; &lt;span class=&#34;comment&#34;&gt;// 拿到主线程传来的 port2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// SW 接收主线程消息（比如处理缓存更新）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    port.&lt;span class=&#34;property&#34;&gt;onmessage&lt;/span&gt; = &lt;span class=&#34;title function_&#34;&gt;async&lt;/span&gt; (e) =&amp;gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (e.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;type&lt;/span&gt; === &lt;span class=&#34;string&#34;&gt;&#39;UPDATE_CACHE&#39;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;comment&#34;&gt;// 模拟更新缓存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; cache = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; caches.&lt;span class=&#34;title function_&#34;&gt;open&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;v2&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; cache.&lt;span class=&#34;title function_&#34;&gt;addAll&lt;/span&gt;(e.&lt;span class=&#34;property&#34;&gt;data&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;urls&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          &lt;span class=&#34;comment&#34;&gt;// 给主线程回复“缓存更新成功”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          port.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;({ &lt;span class=&#34;attr&#34;&gt;type&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;CACHE_UPDATED&#39;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;success&lt;/span&gt;: &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt; });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        } &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (err) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;          port.&lt;span class=&#34;title function_&#34;&gt;postMessage&lt;/span&gt;({ &lt;span class=&#34;attr&#34;&gt;type&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;CACHE_ERROR&#39;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;error&lt;/span&gt;: err.&lt;span class=&#34;property&#34;&gt;message&lt;/span&gt; });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;四、关键注意事项：避坑指南&#34;&gt;&lt;a href=&#34;#四、关键注意事项：避坑指南&#34; class=&#34;headerlink&#34; title=&#34;四、关键注意事项：避坑指南&#34;&gt;&lt;/a&gt;四、关键注意事项：避坑指南&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用后必须关闭端口，避免内存泄漏&lt;/strong&gt;&lt;br&gt;端口如果不手动关闭，会一直占用内存（尤其是在组件卸载、Worker 终止时）。关闭端口用 &lt;code&gt;port.close()&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 组件卸载或通信结束时关闭端口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;port1.&lt;span class=&#34;title function_&#34;&gt;close&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;port2.&lt;span class=&#34;title function_&#34;&gt;close&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;消息传递遵循 “结构化克隆算法”&lt;/strong&gt;&lt;br&gt;能传递的对象包括：字符串、数字、数组、普通对象、&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;、&lt;code&gt;ArrayBuffer&lt;/code&gt;、&lt;code&gt;Blob&lt;/code&gt; 等，但&lt;strong&gt;不能传递函数、DOM 元素、循环引用对象&lt;/strong&gt;。如果传递不支持的类型，会触发 &lt;code&gt;onmessageerror&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;必须监听错误事件（onmessageerror）&lt;/strong&gt;&lt;br&gt;当消息无法解析（比如传递了不支持的类型）时，会触发 &lt;code&gt;onmessageerror&lt;/code&gt;，不监听会导致控制台报错：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;port1.&lt;span class=&#34;property&#34;&gt;onmessageerror&lt;/span&gt; = &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;error&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;消息解析失败：&#39;&lt;/span&gt;, event.&lt;span class=&#34;property&#34;&gt;error&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;端口只能 “转移”，不能 “复制”&lt;/strong&gt;&lt;br&gt;把端口通过 &lt;code&gt;postMessage&lt;/code&gt; 传递给其他上下文时，必须放在 “转移列表”（第三个参数）中 —— 转移后，原上下文的端口会失效，只能在目标上下文使用（确保端口唯一，避免通信混乱）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;五、对比其他通信方式：该选哪一个？&#34;&gt;&lt;a href=&#34;#五、对比其他通信方式：该选哪一个？&#34; class=&#34;headerlink&#34; title=&#34;五、对比其他通信方式：该选哪一个？&#34;&gt;&lt;/a&gt;五、对比其他通信方式：该选哪一个？&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;通信方式&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;th&gt;核心特点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MessageChannel&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;点对点精确通信（如主线程 - Worker、父 - iframe）&lt;/td&gt;
&lt;td&gt;双向、低延迟、专用链路、可转移对象&lt;/td&gt;
&lt;td&gt;只支持 “一对一”，不适合广播&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;普通 &lt;code&gt;postMessage&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;简单的跨窗口通信（如父 - iframe 单次消息）&lt;/td&gt;
&lt;td&gt;无需创建通道，用法简单&lt;/td&gt;
&lt;td&gt;需持有目标上下文引用，易混淆&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;BroadcastChannel&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同源所有上下文广播（如多标签页同步状态）&lt;/td&gt;
&lt;td&gt;一对多、无需目标引用&lt;/td&gt;
&lt;td&gt;不支持可转移对象，跨域受限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;多标签页共享数据 / 计算（如共享缓存）&lt;/td&gt;
&lt;td&gt;持久化连接，多上下文共享&lt;/td&gt;
&lt;td&gt;实现复杂，浏览器兼容性稍差&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CustomEvent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同文档内组件通信（如父子组件）&lt;/td&gt;
&lt;td&gt;同步执行，易集成&lt;/td&gt;
&lt;td&gt;受事件冒泡影响，无法跨上下文&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;简单总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若需要 “一对一、低延迟、长期通信” → 选 &lt;code&gt;MessageChannel&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若需要 “一对多广播” → 选 &lt;code&gt;BroadcastChannel&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若只是 “同文档内简单通信” → 选 &lt;code&gt;CustomEvent&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若需要 “多标签页共享计算” → 选 &lt;code&gt;SharedWorker&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;MessageChannel&lt;/code&gt; 虽然不是日常开发中 “天天用” 的 API，但在处理 “跨上下文专用通信” 和 “高性能任务调度” 时，它是比其他方案更优雅、更高效的选择。掌握它，能让你在面对复杂通信场景时多一种可靠的解决方案～&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://toukoxu.github.io/archives/event/</guid>
            <title>JS 事件系统完全指南与性能优化</title>
            <link>http://toukoxu.github.io/archives/event/</link>
            <category>JavaScript</category>
            <category>性能优化</category>
            <pubDate>Tue, 01 Feb 2022 20:46:25 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;在 JavaScript 的世界里，事件就像网页的 “交互信号”—— 用户点击按钮、滚动页面、输入文字，都是通过事件让网页做出反应。今天我们从基础到进阶，把浏览器事件机制拆解开，再聊聊怎么用得更高效，避免常见的性能坑！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一、事件系统：网页的“交互逻辑骨架”&#34;&gt;&lt;a href=&#34;#一、事件系统：网页的“交互逻辑骨架”&#34; class=&#34;headerlink&#34; title=&#34;一、事件系统：网页的“交互逻辑骨架”&#34;&gt;&lt;/a&gt;一、事件系统：网页的 “交互逻辑骨架”&lt;/h2&gt;&lt;h3 id=&#34;1-1-事件流三阶段：从顶层到目标，再回到顶层&#34;&gt;&lt;a href=&#34;#1-1-事件流三阶段：从顶层到目标，再回到顶层&#34; class=&#34;headerlink&#34; title=&#34;1.1 事件流三阶段：从顶层到目标，再回到顶层&#34;&gt;&lt;/a&gt;1.1 事件流三阶段：从顶层到目标，再回到顶层&lt;/h3&gt;&lt;p&gt;事件触发后，不是直接定位到目标元素，而是会经历 “捕获 → 目标 → 冒泡” 三个阶段，就像水流先向下流到目标，再向上回流：&lt;/p&gt;
&lt;div class=&#34;mermaid-wrap&#34;&gt;&lt;pre class=&#34;mermaid-src&#34; hidden=&#34;&#34;&gt;  graph LR
A[捕获阶段] --&amp;gt; B[目标阶段] --&amp;gt; C[冒泡阶段]
style A fill:#4CAF50,stroke:#388E3C
style B fill:#2196F3,stroke:#1976D2
style C fill:#FF9800,stroke:#F57C00
  &lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;捕获阶段 (Capture Phase)&lt;/strong&gt;：事件从 &lt;code&gt;window&lt;/code&gt; 开始，顺着 DOM 树向下传递，直到目标元素的父级（比如点击按钮时，先经过 &lt;code&gt;body&lt;/code&gt;、&lt;code&gt;div&lt;/code&gt;，再到按钮的父元素）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标阶段 (Target Phase)&lt;/strong&gt;：事件终于到达触发的目标元素（比如刚才的按钮）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冒泡阶段 (Bubble Phase)&lt;/strong&gt;：事件从目标元素开始，顺着 DOM 树向上 “回流”，回到 &lt;code&gt;window&lt;/code&gt;（按钮 → 父 &lt;code&gt;div&lt;/code&gt;→&lt;code&gt;body&lt;/code&gt;→&lt;code&gt;window&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-2-三种事件监听方式：哪种最实用？&#34;&gt;&lt;a href=&#34;#1-2-三种事件监听方式：哪种最实用？&#34; class=&#34;headerlink&#34; title=&#34;1.2 三种事件监听方式：哪种最实用？&#34;&gt;&lt;/a&gt;1.2 三种事件监听方式：哪种最实用？&lt;/h3&gt;&lt;p&gt;日常开发中，绑定事件主要有三种方式，各有优劣，我整理成了表格：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方式&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;👍 优点&lt;/th&gt;
&lt;th&gt;👎 缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;HTML 属性绑定&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;button onclick=&#34;handleClick()&#34;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;写起来快，适合简单 demo&lt;/td&gt;
&lt;td&gt;HTML 和 JS 混在一起，代码难维护；无法绑定多个处理函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;DOM 属性绑定&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;btn.onclick = handleClick&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;比 HTML 属性清晰，不用混写&lt;/td&gt;
&lt;td&gt;一个事件只能绑一个函数，后面的会覆盖前面的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;addEventListener&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;btn.addEventListener(&#39;click&#39;, handleClick)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;🏆 推荐！支持绑多个函数；能控制事件阶段；可手动移除&lt;/td&gt;
&lt;td&gt;需要手动解绑，否则可能内存泄漏&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;实际开发里，我几乎只用 &lt;code&gt;addEventListener&lt;/code&gt;—— 它的灵活性和控制力是另外两种方式比不了的，尤其是复杂项目里，多监听器、阶段控制这些功能很关键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-3-addEventListener详解：参数怎么用？&#34;&gt;&lt;a href=&#34;#1-3-addEventListener详解：参数怎么用？&#34; class=&#34;headerlink&#34; title=&#34;1.3 addEventListener详解：参数怎么用？&#34;&gt;&lt;/a&gt;1.3 &lt;code&gt;addEventListener&lt;/code&gt;详解：参数怎么用？&lt;/h3&gt;&lt;h4 id=&#34;基本语法&#34;&gt;&lt;a href=&#34;#基本语法&#34; class=&#34;headerlink&#34; title=&#34;基本语法&#34;&gt;&lt;/a&gt;基本语法&lt;/h4&gt;&lt;p&gt;它有三种调用形式，核心是控制事件的触发规则：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 1. 基础版：事件类型 + 处理函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(type, listener);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 2. 旧版阶段控制：加个布尔值控制捕获/冒泡&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(type, listener, useCapture);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 3. 新版选项控制：更灵活的配置（推荐）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(type, listener, options);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&#34;关键参数说明&#34;&gt;&lt;a href=&#34;#关键参数说明&#34; class=&#34;headerlink&#34; title=&#34;关键参数说明&#34;&gt;&lt;/a&gt;关键参数说明&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;useCapture&lt;/code&gt;（布尔值，旧版）&lt;/strong&gt;：&lt;br&gt;控制事件在哪个阶段触发。&lt;code&gt;true&lt;/code&gt; 是捕获阶段，&lt;code&gt;false&lt;/code&gt;（默认）是冒泡阶段，和新版 &lt;code&gt;options.capture&lt;/code&gt; 功能完全一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;options&lt;/code&gt;（对象，新版）&lt;/strong&gt;：&lt;br&gt;能精细控制事件行为，常用选项如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;capture&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;决定事件在哪个阶段触发：&lt;code&gt;false&lt;/code&gt;（冒泡阶段）、&lt;code&gt;true&lt;/code&gt;（捕获阶段）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;once&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt; 时，函数只执行一次，执行完自动解绑（比如 “点击后失效” 的按钮）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;passive&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt; 时，告诉浏览器 “这个函数不会调用 &lt;code&gt;preventDefault()&lt;/code&gt;”，能提升滚动、触摸等高频事件的性能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;AbortSignal&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;配合 &lt;code&gt;AbortController&lt;/code&gt; 使用，调用 &lt;code&gt;abort()&lt;/code&gt; 就能批量解绑事件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二、常用事件类型：按场景分类整理&#34;&gt;&lt;a href=&#34;#二、常用事件类型：按场景分类整理&#34; class=&#34;headerlink&#34; title=&#34;二、常用事件类型：按场景分类整理&#34;&gt;&lt;/a&gt;二、常用事件类型：按场景分类整理&lt;/h2&gt;&lt;p&gt;浏览器事件类型非常多，我附上关键属性和用法，不用死记，需要时查就行。&lt;/p&gt;
&lt;h3 id=&#34;先看事件的继承关系&#34;&gt;&lt;a href=&#34;#先看事件的继承关系&#34; class=&#34;headerlink&#34; title=&#34;先看事件的继承关系&#34;&gt;&lt;/a&gt;先看事件的继承关系&lt;/h3&gt;&lt;p&gt;所有事件都基于 &lt;code&gt;Event&lt;/code&gt; 这个 “基类”，再衍生出不同场景的事件，比如鼠标事件、键盘事件等，关系如下：&lt;/p&gt;
&lt;div class=&#34;mermaid-wrap&#34;&gt;&lt;pre class=&#34;mermaid-src&#34; hidden=&#34;&#34;&gt;  classDiagram
class Event {
&amp;lt;&amp;lt;interface&amp;gt;&amp;gt;
+type: string
+bubbles: boolean
+cancelable: boolean
+target: EventTarget
+currentTarget: EventTarget
+eventPhase: number
+timeStamp: DOMHighResTimeStamp
+isTrusted: boolean
+defaultPrevented: boolean
+composed: boolean
+preventDefault() void
+stopPropagation() void
+stopImmediatePropagation() void
+composedPath() EventTarget[]
}

Event &amp;lt;|-- UIEvent
Event &amp;lt;|-- AnimationEvent
Event &amp;lt;|-- TransitionEvent
Event &amp;lt;|-- ClipboardEvent
Event &amp;lt;|-- CustomEvent
Event &amp;lt;|-- ProgressEvent
Event &amp;lt;|-- StorageEvent
Event &amp;lt;|-- MessageEvent
Event &amp;lt;|-- ToggleEvent
Event &amp;lt;|-- SubmitEvent

class UIEvent {
+view: WindowProxy
+detail: number
+sourceCapabilities: InputDeviceCapabilities
}

UIEvent &amp;lt;|-- MouseEvent
UIEvent &amp;lt;|-- KeyboardEvent
UIEvent &amp;lt;|-- FocusEvent
UIEvent &amp;lt;|-- TouchEvent
UIEvent &amp;lt;|-- InputEvent

class MouseEvent {
+screenX: number
+screenY: number
+clientX: number
+clientY: number
+pageX: number
+pageY: number
+offsetX: number
+offsetY: number
+button: number
+buttons: number
+relatedTarget: EventTarget
+altKey: boolean
+ctrlKey: boolean
+shiftKey: boolean
+metaKey: boolean
+getModifierState(key: string) boolean
}

MouseEvent &amp;lt;|-- PointerEvent
MouseEvent &amp;lt;|-- DragEvent
MouseEvent &amp;lt;|-- WheelEvent

class PointerEvent {
+pointerId: number
+width: number
+height: number
+pressure: number
+tangentialPressure: number
+tiltX: number
+tiltY: number
+twist: number
+pointerType: string
+isPrimary: boolean
}

class WheelEvent {
+deltaX: number
+deltaY: number
+deltaZ: number
+deltaMode: number
}

class KeyboardEvent {
+key: string
+code: string
+location: number
+repeat: boolean
+isComposing: boolean
+getModifierState(key: string) boolean
}

class FocusEvent {
+relatedTarget: EventTarget
}

class TouchEvent {
+touches: TouchList
+targetTouches: TouchList
+changedTouches: TouchList
+altKey: boolean
+ctrlKey: boolean
+shiftKey: boolean
+metaKey: boolean
}

class AnimationEvent {
+animationName: string
+elapsedTime: number
+pseudoElement: string
}

class TransitionEvent {
+propertyName: string
+elapsedTime: number
+pseudoElement: string
}

class CustomEvent {
+detail: any
+initCustomEvent() void
}

class InputEvent {
+data: string
+isComposing: boolean
+inputType: string
}

class ClipboardEvent {
+clipboardData: DataTransfer
}

class ProgressEvent {
+lengthComputable: boolean
+loaded: number
+total: number
}

class StorageEvent {
+key: string
+oldValue: any
+newValue: any
+url: string
+storageArea: Storage
}

class MessageEvent {
+data: any
+origin: string
+lastEventId: string
+source: WindowProxy
+ports: MessagePort[]
}

class ToggleEvent {
+newState: string
+oldState: string
}

class DragEvent {
+dataTransfer: DataTransfer
}
  &lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&#34;1-Event（基础事件）&#34;&gt;&lt;a href=&#34;#1-Event（基础事件）&#34; class=&#34;headerlink&#34; title=&#34;1. Event（基础事件）&#34;&gt;&lt;/a&gt;1. Event（基础事件）&lt;/h3&gt;&lt;p&gt;所有事件的 “祖宗”，提供最基础的属性和方法，比如判断事件是否冒泡、阻止默认行为等。&lt;/p&gt;
&lt;h4 id=&#34;常用属性&#34;&gt;&lt;a href=&#34;#常用属性&#34; class=&#34;headerlink&#34; title=&#34;常用属性&#34;&gt;&lt;/a&gt;常用属性&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;：事件类型（如 “click”）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target&lt;/code&gt;：实际触发事件的元素（比如点击按钮，&lt;code&gt;target&lt;/code&gt; 就是按钮）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;currentTarget&lt;/code&gt;：始终为绑定事件的元素（比如给父容器绑事件，点击子元素时，&lt;code&gt;currentTarget&lt;/code&gt; 是父容器）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bubbles&lt;/code&gt;：布尔值，判断事件是否会冒泡&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cancelable&lt;/code&gt;：布尔值，判断事件能否用 &lt;code&gt;preventDefault()&lt;/code&gt; 阻止默认行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eventPhase&lt;/code&gt;：事件当前阶段（0 = NONE, 1 = CAPTURING, 2 = AT_TARGET, 3 = BUBBLING）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timeStamp&lt;/code&gt;：事件发生的时间戳&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isTrusted&lt;/code&gt;：事件是否由用户触发（true）还是脚本创建（false）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defaultPrevented&lt;/code&gt;：是否已阻止默认行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;常用方法&#34;&gt;&lt;a href=&#34;#常用方法&#34; class=&#34;headerlink&#34; title=&#34;常用方法&#34;&gt;&lt;/a&gt;常用方法&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;preventDefault()&lt;/code&gt;：阻止默认行为（比如阻止表单提交、链接跳转），可以使用&lt;code&gt;Event.cancelable&lt;/code&gt;来检查该事件是否支持取消&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stopPropagation()&lt;/code&gt;：阻止事件继续冒泡或捕获（比如点击子元素后，父元素的事件不触发）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stopImmediatePropagation()&lt;/code&gt;：阻止其他监听器执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;高频基础事件&#34;&gt;&lt;a href=&#34;#高频基础事件&#34; class=&#34;headerlink&#34; title=&#34;高频基础事件&#34;&gt;&lt;/a&gt;高频基础事件&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;th&gt;常用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DOMContentLoaded&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;DOM 解析完成（不用等图片、CSS 加载）&lt;/td&gt;
&lt;td&gt;页面初始化逻辑（比如绑定事件、渲染列表）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;load&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;整个页面（图片、CSS 等）加载完成&lt;/td&gt;
&lt;td&gt;处理图片相关逻辑（比如获取图片尺寸）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;scroll&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素或页面滚动时&lt;/td&gt;
&lt;td&gt;滚动加载、导航栏吸顶&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;窗口或元素大小改变时&lt;/td&gt;
&lt;td&gt;响应式布局调整（比如窗口缩小后重排内容）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;submit&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表单点击提交按钮或按回车时&lt;/td&gt;
&lt;td&gt;表单验证、阻止默认提交后用 AJAX 提交&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;2-UIEvent（用户界面事件）&#34;&gt;&lt;a href=&#34;#2-UIEvent（用户界面事件）&#34; class=&#34;headerlink&#34; title=&#34;2. UIEvent（用户界面事件）&#34;&gt;&lt;/a&gt;2. UIEvent（用户界面事件）&lt;/h3&gt;&lt;p&gt;继承自&lt;strong&gt; Event&lt;/strong&gt;，处理与浏览器 UI 相关的事件。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;view&lt;/code&gt;：关联的窗口对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;detail&lt;/code&gt;：事件详情（如点击次数）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-1-MouseEvent（鼠标事件）&#34;&gt;&lt;a href=&#34;#2-1-MouseEvent（鼠标事件）&#34; class=&#34;headerlink&#34; title=&#34;2.1 MouseEvent（鼠标事件）&#34;&gt;&lt;/a&gt;2.1 MouseEvent（鼠标事件）&lt;/h4&gt;&lt;p&gt;继承自&lt;strong&gt; UIEvent&lt;/strong&gt;，处理所有鼠标相关事件，比如点击、移动、滚轮操作都属于这类。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;screenX&lt;/code&gt;, &lt;code&gt;screenY&lt;/code&gt;：屏幕坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clientX&lt;/code&gt;, &lt;code&gt;clientY&lt;/code&gt;：视口坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pageX&lt;/code&gt;, &lt;code&gt;pageY&lt;/code&gt;：文档坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;screenX&lt;/code&gt;, &lt;code&gt;screenY&lt;/code&gt;：屏幕坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;offsetX&lt;/code&gt;, &lt;code&gt;offsetY&lt;/code&gt;：目标元素坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;button&lt;/code&gt;：按下的鼠标按钮（0 = 左键, 1 = 中键, 2 = 右键）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buttons&lt;/code&gt;：按下的多个按钮&lt;/li&gt;
&lt;li&gt;&lt;code&gt;relatedTarget&lt;/code&gt;：相关元素（如 mouseover 时的来源元素）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体事件类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件类型&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;th&gt;是否冒泡&lt;/th&gt;
&lt;th&gt;注意点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;click&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;鼠标按下并释放（通常是左键）&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;双击会触发两次 &lt;code&gt;click&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dblclick&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;双击鼠标&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;响应速度比 &lt;code&gt;click&lt;/code&gt; 慢，慎用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mousedown&lt;/code&gt;/&lt;code&gt;mouseup&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;鼠标按下 / 释放&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;区分按下和释放的状态（比如拖拽开始 / 结束）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mousemove&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;鼠标移动&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;触发频率高，需要节流优化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mouseenter&lt;/code&gt;/&lt;code&gt;mouseleave&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;鼠标进入 / 离开元素&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;不冒泡，子元素不会触发（比如鼠标从父元素进子元素，不会触发父元素的 &lt;code&gt;mouseleave&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mouseover&lt;/code&gt;/&lt;code&gt;mouseout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;鼠标进入 / 离开元素或子元素&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;冒泡，子元素会触发（比如鼠标从父元素进子元素，父元素会触发 &lt;code&gt;mouseout&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;contextmenu&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;右键菜单&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h5 id=&#34;2-1-1-WheelEvent（滚轮事件）&#34;&gt;&lt;a href=&#34;#2-1-1-WheelEvent（滚轮事件）&#34; class=&#34;headerlink&#34; title=&#34;2.1.1 WheelEvent（滚轮事件）&#34;&gt;&lt;/a&gt;2.1.1 WheelEvent（滚轮事件）&lt;/h5&gt;&lt;p&gt;继承自&lt;strong&gt; MouseEvent&lt;/strong&gt;，处理滚轮 / 触控板滚动事件。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;deltaX&lt;/code&gt;：水平滚动量（像素）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deltaY&lt;/code&gt;：垂直滚动量（像素）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deltaZ&lt;/code&gt;：Z 轴滚动量（3D 设备）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deltaMode&lt;/code&gt;：滚动单位（0 = 像素, 1 = 行, 2 = 页）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体事件类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件类型&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;th&gt;注意点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;wheel&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;滚轮滚动&lt;/td&gt;
&lt;td&gt;控制滚动方向和速度（替代旧的 &lt;code&gt;mousewheel&lt;/code&gt; 事件）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h5 id=&#34;2-1-2-DragEvent（拖放事件）&#34;&gt;&lt;a href=&#34;#2-1-2-DragEvent（拖放事件）&#34; class=&#34;headerlink&#34; title=&#34;2.1.2 DragEvent（拖放事件）&#34;&gt;&lt;/a&gt;2.1.2 DragEvent（拖放事件）&lt;/h5&gt;&lt;p&gt;继承自&lt;strong&gt; MouseEvent&lt;/strong&gt;，处理拖放事件。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dataTransfer&lt;/code&gt;：在拖放交互期间传输的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体事件类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件类型&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;drag&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;拖动元素（含选择的文本，下同）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dragstart&lt;/code&gt;, &lt;code&gt;dragend&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;开始拖动元素, 拖动操作结束（释放鼠标按钮或按下退出键）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dragover&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素拖动到有效放置目标上（每几百毫秒）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dragenter&lt;/code&gt;, &lt;code&gt;dragleave&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;拖动的元素进入放置目标, 拖动的元素离开放置目标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在放置目标上放置元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h5 id=&#34;2-1-3-PointerEvent（指针事件）&#34;&gt;&lt;a href=&#34;#2-1-3-PointerEvent（指针事件）&#34; class=&#34;headerlink&#34; title=&#34;2.1.3 PointerEvent（指针事件）&#34;&gt;&lt;/a&gt;2.1.3 PointerEvent（指针事件）&lt;/h5&gt;&lt;p&gt;继承自&lt;strong&gt; MouseEvent&lt;/strong&gt;，统一鼠标、触摸、触控笔事件。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pointerId&lt;/code&gt;：唯一指针 ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;：接触区域尺寸&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pressure&lt;/code&gt;：压力值（0-1）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointerType&lt;/code&gt;：设备类型（” mouse”, “pen”, “touch”）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isPrimary&lt;/code&gt;：是否为主指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体事件类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件类型&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pointerdown&lt;/code&gt;, &lt;code&gt;pointerup&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指针按下, 指针释放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pointermove&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指针移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pointerover&lt;/code&gt;, &lt;code&gt;pointerout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指针进入元素, 指针离开元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pointerenter&lt;/code&gt;, &lt;code&gt;pointerleave&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指针进入元素, 指针离开元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pointercancel&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指针中断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gotpointercapture&lt;/code&gt;, &lt;code&gt;lostpointercapture&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素启用捕获后触发, 捕获被释放后触发&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h4 id=&#34;2-2-KeyboardEvent（键盘事件）&#34;&gt;&lt;a href=&#34;#2-2-KeyboardEvent（键盘事件）&#34; class=&#34;headerlink&#34; title=&#34;2.2 KeyboardEvent（键盘事件）&#34;&gt;&lt;/a&gt;2.2 KeyboardEvent（键盘事件）&lt;/h4&gt;&lt;p&gt;继承自&lt;strong&gt; UIEvent&lt;/strong&gt;，处理键盘输入事件，比如快捷键、输入验证等。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;key&lt;/code&gt;：按键的实际内容（比如按 “A” 是 &lt;code&gt;&#34;a&#34;&lt;/code&gt; 或 &lt;code&gt;&#34;A&#34;&lt;/code&gt;，按回车是 &lt;code&gt;&#34;Enter&#34;&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;code&lt;/code&gt;：按键的物理位置（比如按 “A” 是 &lt;code&gt;&#34;KeyA&#34;&lt;/code&gt;，不管是否按 Shift，位置不变）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;location&lt;/code&gt;：按键位置（0 = 标准, 1 = 左侧, 2 = 右侧, 3 = 数字键盘）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repeat&lt;/code&gt;：布尔值，判断是否是长按重复触发&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isComposing&lt;/code&gt;：布尔值，判断是否在输入法输入中（比如中文输入时避免误触发）&lt;/li&gt;
&lt;li&gt;修饰键状态：&lt;code&gt;altKey&lt;/code&gt;, &lt;code&gt;ctrlKey&lt;/code&gt;, &lt;code&gt;shiftKey&lt;/code&gt;, &lt;code&gt;metaKey&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getModifierState(key)&lt;/code&gt;：检查特定修饰键状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体事件类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;th&gt;是否冒泡&lt;/th&gt;
&lt;th&gt;常用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;keydown&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按下任意键（包括功能键）&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;监听快捷键（比如 Ctrl + S 保存）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;keyup&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;释放按键时&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;取消快捷键状态（比如松开 Ctrl 后停止批量操作）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;code&gt;keypress&lt;/code&gt; 事件已过时，尽量用 &lt;code&gt;keydown&lt;/code&gt; 替代，它支持所有按键类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;2-3-FocusEvent（焦点事件）&#34;&gt;&lt;a href=&#34;#2-3-FocusEvent（焦点事件）&#34; class=&#34;headerlink&#34; title=&#34;2.3 FocusEvent（焦点事件）&#34;&gt;&lt;/a&gt;2.3 FocusEvent（焦点事件）&lt;/h4&gt;&lt;p&gt;继承自&lt;strong&gt; UIEvent&lt;/strong&gt;，处理元素焦点变化，比如表单输入时的交互。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;relatedTarget&lt;/code&gt;：相关元素（如失去焦点时获得焦点的元素）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体事件类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件类型&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;th&gt;是否冒泡&lt;/th&gt;
&lt;th&gt;注意点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;focus&lt;/code&gt;/&lt;code&gt;blur&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素获得 / 失去焦点&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;不冒泡，无法用事件委托&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;focusin&lt;/code&gt;/&lt;code&gt;focusout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素获得 / 失去焦点&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;冒泡，推荐用它做事件委托（比如表单所有输入框的焦点处理）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h4 id=&#34;2-4-TouchEvent（触摸事件）&#34;&gt;&lt;a href=&#34;#2-4-TouchEvent（触摸事件）&#34; class=&#34;headerlink&#34; title=&#34;2.4 TouchEvent（触摸事件）&#34;&gt;&lt;/a&gt;2.4 TouchEvent（触摸事件）&lt;/h4&gt;&lt;p&gt;继承自&lt;strong&gt; UIEvent&lt;/strong&gt;，处理触摸屏设备交互。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;touches&lt;/code&gt;：当前所有触摸点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;targetTouches&lt;/code&gt;：当前元素上的触摸点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;changedTouches&lt;/code&gt;：本次事件相关的触摸点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体事件类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件类型&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;touchstart&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;触摸开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;touchmove&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;触摸移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;touchend&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;触摸结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;touchcancel&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;触摸中断&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h4 id=&#34;2-5-InputEvent（输入事件）&#34;&gt;&lt;a href=&#34;#2-5-InputEvent（输入事件）&#34; class=&#34;headerlink&#34; title=&#34;2.5 InputEvent（输入事件）&#34;&gt;&lt;/a&gt;2.5 InputEvent（输入事件）&lt;/h4&gt;&lt;p&gt;继承自&lt;strong&gt; UIEvent&lt;/strong&gt;，处理用户输入事件，比如实时监听输入框、文本域的内容变化，比 &lt;code&gt;change&lt;/code&gt; 事件更灵敏（&lt;code&gt;change&lt;/code&gt; 需要失去焦点才触发）。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt;：插入的字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dataTransfer&lt;/code&gt;：拖放或插入 / 删除的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inputType&lt;/code&gt;：更改的类型（&lt;code&gt;inserting&lt;/code&gt;或&lt;code&gt;deleting&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体事件类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件类型&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;th&gt;常用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;input&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用户输入&lt;/td&gt;
&lt;td&gt;实时搜索提示、输入字数统计&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;3-AnimationEvent（动画事件）&#34;&gt;&lt;a href=&#34;#3-AnimationEvent（动画事件）&#34; class=&#34;headerlink&#34; title=&#34;3. AnimationEvent（动画事件）&#34;&gt;&lt;/a&gt;3. AnimationEvent（动画事件）&lt;/h3&gt;&lt;p&gt;继承自&lt;strong&gt; Event&lt;/strong&gt;，处理 CSS 动画相关事件。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;animationName&lt;/code&gt;：动画名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;elapsedTime&lt;/code&gt;：动画已运行时间（秒）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pseudoElement&lt;/code&gt;：关联的伪元素（如 “::before”）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体事件类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件类型&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;animationstart&lt;/code&gt;, &lt;code&gt;animationend&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;动画开始, 动画结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;animationiteration&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;动画重复播放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;animationcancel&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;动画被取消&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;4-TransitionEvent（过渡事件）&#34;&gt;&lt;a href=&#34;#4-TransitionEvent（过渡事件）&#34; class=&#34;headerlink&#34; title=&#34;4. TransitionEvent（过渡事件）&#34;&gt;&lt;/a&gt;4. TransitionEvent（过渡事件）&lt;/h3&gt;&lt;p&gt;继承自&lt;strong&gt; Event&lt;/strong&gt;，处理 CSS 过渡效果相关事件。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;propertyName&lt;/code&gt;：发生过渡的 CSS 属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;elapsedTime&lt;/code&gt;：过渡已运行时间（秒）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pseudoElement&lt;/code&gt;：关联的伪元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体事件类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件类型&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transitionrun&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;过渡创建时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transitionstart&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;过渡实际开始时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transitionend&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;过渡完成时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transitioncancel&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;过渡被取消时&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;5-ClipboardEvent（剪贴板事件）&#34;&gt;&lt;a href=&#34;#5-ClipboardEvent（剪贴板事件）&#34; class=&#34;headerlink&#34; title=&#34;5. ClipboardEvent（剪贴板事件）&#34;&gt;&lt;/a&gt;5. ClipboardEvent（剪贴板事件）&lt;/h3&gt;&lt;p&gt;继承自&lt;strong&gt; Event&lt;/strong&gt;，用于处理剪切板相关信息的事件。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;clipboardData&lt;/code&gt;：受剪贴板操作影响的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体事件类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件类型&lt;/th&gt;
&lt;th&gt;触发时机&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;复制元素的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cut&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;剪切元素的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;paste&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将内容粘贴到元素中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;6-CustomEvent（自定义事件）&#34;&gt;&lt;a href=&#34;#6-CustomEvent（自定义事件）&#34; class=&#34;headerlink&#34; title=&#34;6. CustomEvent（自定义事件）&#34;&gt;&lt;/a&gt;6. CustomEvent（自定义事件）&lt;/h3&gt;&lt;p&gt;继承自&lt;strong&gt; Event&lt;/strong&gt;，用于创建自定义事件。&lt;/p&gt;
&lt;p&gt;特有属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;detail&lt;/code&gt;：自定义数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;initCustomEvent()&lt;/code&gt;：初始化自定义事件&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;用法示例&#34;&gt;&lt;a href=&#34;#用法示例&#34; class=&#34;headerlink&#34; title=&#34;用法示例&#34;&gt;&lt;/a&gt;用法示例&lt;/h4&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 1. 创建自定义事件：事件名 + 配置（可传自定义数据）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; dataLoadedEvent = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;CustomEvent&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;data-loaded&#39;&lt;/span&gt;, {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;detail&lt;/span&gt;: { &lt;span class=&#34;attr&#34;&gt;list&lt;/span&gt;: [&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;] }, &lt;span class=&#34;comment&#34;&gt;// 自定义数据，通过 event.detail 访问&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;bubbles&lt;/span&gt;: &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;, &lt;span class=&#34;comment&#34;&gt;// 是否冒泡&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;cancelable&lt;/span&gt;: &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;, &lt;span class=&#34;comment&#34;&gt;// 是否可阻止默认行为&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 2. 绑定事件监听&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;data-loaded&#39;&lt;/span&gt;, &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;收到数据：&#39;&lt;/span&gt;, event.&lt;span class=&#34;property&#34;&gt;detail&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;list&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 输出 [1,2,3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 3. 触发事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;dispatchEvent&lt;/span&gt;(dataLoadedEvent);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;三、事件性能优化：避免卡顿、减少浪费&#34;&gt;&lt;a href=&#34;#三、事件性能优化：避免卡顿、减少浪费&#34; class=&#34;headerlink&#34; title=&#34;三、事件性能优化：避免卡顿、减少浪费&#34;&gt;&lt;/a&gt;三、事件性能优化：避免卡顿、减少浪费&lt;/h2&gt;&lt;p&gt;事件处理很容易出性能问题，比如滚动、拖拽这类高频事件，处理不好会让页面卡顿。分享几个我实战中验证过的优化技巧：&lt;/p&gt;
&lt;h3 id=&#34;3-1-高频事件：用防抖（debounce）和节流（throttle）控频率&#34;&gt;&lt;a href=&#34;#3-1-高频事件：用防抖（debounce）和节流（throttle）控频率&#34; class=&#34;headerlink&#34; title=&#34;3.1 高频事件：用防抖（debounce）和节流（throttle）控频率&#34;&gt;&lt;/a&gt;3.1 高频事件：用防抖（debounce）和节流（throttle）控频率&lt;/h3&gt;&lt;p&gt;像 &lt;code&gt;scroll&lt;/code&gt;、&lt;code&gt;mousemove&lt;/code&gt;、&lt;code&gt;resize&lt;/code&gt; 这类事件，触发频率非常高（比如滚动时每秒触发几十次），直接执行处理函数会占用大量主线程，导致页面卡顿。这时候需要用 “防抖” 或 “节流” 控制执行次数。&lt;/p&gt;
&lt;h4 id=&#34;防抖（debounce）：连续触发只执行最后一次&#34;&gt;&lt;a href=&#34;#防抖（debounce）：连续触发只执行最后一次&#34; class=&#34;headerlink&#34; title=&#34;防抖（debounce）：连续触发只执行最后一次&#34;&gt;&lt;/a&gt;防抖（debounce）：连续触发只执行最后一次&lt;/h4&gt;&lt;p&gt;比如窗口 resize 时，用户拖动窗口的过程中不执行，等用户停手后再执行一次，避免频繁计算。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 防抖：最后的胜利者（连续触发只执行最后一次）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;debounce&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;fn, delay&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; timer; &lt;span class=&#34;comment&#34;&gt;// 用闭包保存定时器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;...args&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;clearTimeout&lt;/span&gt;(timer); &lt;span class=&#34;comment&#34;&gt;// 每次触发都清空之前的定时器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 重新计时，等 delay 毫秒后执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    timer = &lt;span class=&#34;built_in&#34;&gt;setTimeout&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; fn.&lt;span class=&#34;title function_&#34;&gt;apply&lt;/span&gt;(&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;, args), delay);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 用法：窗口 resize 时，等 200ms 稳定后再执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;window&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;string&#34;&gt;&#39;resize&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;debounce&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;窗口大小稳定了，执行调整逻辑&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }, &lt;span class=&#34;number&#34;&gt;200&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&#34;节流（throttle）：固定间隔执行一次&#34;&gt;&lt;a href=&#34;#节流（throttle）：固定间隔执行一次&#34; class=&#34;headerlink&#34; title=&#34;节流（throttle）：固定间隔执行一次&#34;&gt;&lt;/a&gt;节流（throttle）：固定间隔执行一次&lt;/h4&gt;&lt;p&gt;比如滚动加载时，不管滚动多快，每隔 100ms 只执行一次，避免请求发送太频繁。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;throttle&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;fn, interval&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; lastTime = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 上次执行时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;...args&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; now = &lt;span class=&#34;title class_&#34;&gt;Date&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;now&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 距离上次执行超过 interval 才执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (now - lastTime &amp;gt;= interval) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      fn.&lt;span class=&#34;title function_&#34;&gt;apply&lt;/span&gt;(&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      lastTime = now; &lt;span class=&#34;comment&#34;&gt;// 更新上次执行时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 用法：滚动时每隔 100ms 执行一次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;string&#34;&gt;&#39;scroll&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;throttle&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;滚动中，按固定间隔执行&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }, &lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;3-2-多元素事件：用事件委托减少监听器&#34;&gt;&lt;a href=&#34;#3-2-多元素事件：用事件委托减少监听器&#34; class=&#34;headerlink&#34; title=&#34;3.2 多元素事件：用事件委托减少监听器&#34;&gt;&lt;/a&gt;3.2 多元素事件：用事件委托减少监听器&lt;/h3&gt;&lt;p&gt;如果有很多相同元素需要绑定事件（比如列表里的删除按钮），一个个绑定会创建大量监听器，浪费内存。这时候用 “事件委托”，把监听器绑在父元素上，通过 &lt;code&gt;event.target&lt;/code&gt; 判断是否点击目标元素。&lt;/p&gt;
&lt;h4 id=&#34;反面示例：逐个绑定（低效）&#34;&gt;&lt;a href=&#34;#反面示例：逐个绑定（低效）&#34; class=&#34;headerlink&#34; title=&#34;反面示例：逐个绑定（低效）&#34;&gt;&lt;/a&gt;反面示例：逐个绑定（低效）&lt;/h4&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 给每个 .remove-btn 绑事件，元素多的时候很卡&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;querySelectorAll&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;.remove-btn&#39;&lt;/span&gt;).&lt;span class=&#34;title function_&#34;&gt;forEach&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;btn&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  btn.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    btn.&lt;span class=&#34;property&#34;&gt;parentElement&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;remove&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&#34;正面示例：事件委托（高效）&#34;&gt;&lt;a href=&#34;#正面示例：事件委托（高效）&#34; class=&#34;headerlink&#34; title=&#34;正面示例：事件委托（高效）&#34;&gt;&lt;/a&gt;正面示例：事件委托（高效）&lt;/h4&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 只给父容器绑一个事件，不管有多少子元素都能处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getElementById&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;list-container&#39;&lt;/span&gt;).&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 判断点击的是不是 .remove-btn&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (event.&lt;span class=&#34;property&#34;&gt;target&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;matches&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;.remove-btn&#39;&lt;/span&gt;)) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    event.&lt;span class=&#34;property&#34;&gt;target&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;parentElement&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;remove&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&#34;额外优势：支持动态元素&#34;&gt;&lt;a href=&#34;#额外优势：支持动态元素&#34; class=&#34;headerlink&#34; title=&#34;额外优势：支持动态元素&#34;&gt;&lt;/a&gt;额外优势：支持动态元素&lt;/h4&gt;&lt;p&gt;如果列表是动态生成的（比如 AJAX 加载后新增的项），逐个绑定的事件会失效，但事件委托能自动处理 —— 因为监听器在父容器上，新元素只要符合选择器，点击就能触发。&lt;/p&gt;
&lt;div class=&#34;note success flat&#34;&gt;&lt;p&gt;&lt;strong&gt;性能秘诀：&lt;/strong&gt; 对&lt;mark&gt;动态内容&lt;/mark&gt;使用&lt;mark&gt;事件委托&lt;/mark&gt;是高性能 Web 应用的关键！&lt;/p&gt;&lt;/div&gt;

&lt;h3 id=&#34;3-3-一次性事件：用-once-true-自动解绑&#34;&gt;&lt;a href=&#34;#3-3-一次性事件：用-once-true-自动解绑&#34; class=&#34;headerlink&#34; title=&#34;3.3 一次性事件：用 once: true 自动解绑&#34;&gt;&lt;/a&gt;3.3 一次性事件：用 &lt;code&gt;once: true&lt;/code&gt; 自动解绑&lt;/h3&gt;&lt;p&gt;有些事件只需要执行一次（比如 “点击后弹出提示，之后再点无效”），不用手动解绑，加个 &lt;code&gt;once: true&lt;/code&gt; 选项，执行完会自动移除监听器。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 可以使用匿名函数，自动在调用后删除，再点不会触发&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;querySelector&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;.tips-btn&#39;&lt;/span&gt;).&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;string&#34;&gt;&#39;click&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;title function_&#34;&gt;alert&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;这是只弹一次的提示&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  { &lt;span class=&#34;attr&#34;&gt;once&lt;/span&gt;: &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt; },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;3-4-滚动-触摸事件：用-passive-true-提升流畅度&#34;&gt;&lt;a href=&#34;#3-4-滚动-触摸事件：用-passive-true-提升流畅度&#34; class=&#34;headerlink&#34; title=&#34;3.4 滚动/触摸事件：用 passive: true 提升流畅度&#34;&gt;&lt;/a&gt;3.4 滚动 / 触摸事件：用 &lt;code&gt;passive: true&lt;/code&gt; 提升流畅度&lt;/h3&gt;&lt;p&gt;浏览器在处理 &lt;code&gt;scroll&lt;/code&gt;、&lt;code&gt;touchmove&lt;/code&gt; 这类事件时，会先检查函数是否调用 &lt;code&gt;preventDefault()&lt;/code&gt;，如果有，会阻塞滚动，导致卡顿。如果你的函数不会阻止默认行为，加 &lt;code&gt;passive: true&lt;/code&gt; 告诉浏览器 “不用等检查了，直接执行”，能显著提升滚动流畅度。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 滚动事件加 passive: true，提升流畅度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;string&#34;&gt;&#39;scroll&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;滚动中，不阻止默认行为&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  { &lt;span class=&#34;attr&#34;&gt;passive&lt;/span&gt;: &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt; },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：如果加了 &lt;code&gt;passive: true&lt;/code&gt;，再调用 &lt;code&gt;preventDefault()&lt;/code&gt; 会报错，因为浏览器已经认定你不会阻止默认行为了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-5-事件顺序控制：用-capture-true-精确控制事件触发顺序（不是常规性能优化的手段）&#34;&gt;&lt;a href=&#34;#3-5-事件顺序控制：用-capture-true-精确控制事件触发顺序（不是常规性能优化的手段）&#34; class=&#34;headerlink&#34; title=&#34;3.5 事件顺序控制：用 capture: true 精确控制事件触发顺序（不是常规性能优化的手段）&#34;&gt;&lt;/a&gt;3.5 事件顺序控制：用 &lt;code&gt;capture: true&lt;/code&gt; 精确控制事件触发顺序（不是常规性能优化的手段）&lt;/h3&gt;&lt;p&gt;在某些特定场景下，捕获阶段可能更早地处理事件，从而能够阻止事件进一步传播。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;string&#34;&gt;&#39;click&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (e.&lt;span class=&#34;property&#34;&gt;target&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;matches&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;.should-block&#39;&lt;/span&gt;)) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      e.&lt;span class=&#34;title function_&#34;&gt;stopPropagation&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 阻止所有后续监听器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      e.&lt;span class=&#34;title function_&#34;&gt;preventDefault&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  { &lt;span class=&#34;attr&#34;&gt;capture&lt;/span&gt;: &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt; }, &lt;span class=&#34;comment&#34;&gt;// 在捕获阶段早期检查&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;3-6-不再需要的事件：用-removeEventListener-及时解绑避免内存泄漏&#34;&gt;&lt;a href=&#34;#3-6-不再需要的事件：用-removeEventListener-及时解绑避免内存泄漏&#34; class=&#34;headerlink&#34; title=&#34;3.6 不再需要的事件：用 removeEventListener 及时解绑避免内存泄漏&#34;&gt;&lt;/a&gt;3.6 不再需要的事件：用 &lt;code&gt;removeEventListener&lt;/code&gt; 及时解绑避免内存泄漏&lt;/h3&gt;&lt;p&gt;如果元素被删除（比如单页应用切换组件），但事件监听器没解绑，浏览器会一直持有这个函数和元素的引用，导致内存泄漏。一定要在合适的时机解绑。&lt;/p&gt;
&lt;h4 id=&#34;正确示例：组件销毁时解绑&#34;&gt;&lt;a href=&#34;#正确示例：组件销毁时解绑&#34; class=&#34;headerlink&#34; title=&#34;正确示例：组件销毁时解绑&#34;&gt;&lt;/a&gt;正确示例：组件销毁时解绑&lt;/h4&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ListComponent&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;constructor&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 绑定this，避免函数内this指向错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;handleClick&lt;/span&gt; = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;handleClick&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;bind&lt;/span&gt;(&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;container&lt;/span&gt; = &lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getElementById&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;list-container&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;container&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;handleClick&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;handleClick&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 处理点击逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 组件销毁时调用，解绑事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;destroy&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;container&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;removeEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;handleClick&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 切换组件时，销毁旧组件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; oldList = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;ListComponent&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;oldList.&lt;span class=&#34;title function_&#34;&gt;destroy&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 解绑事件，避免内存泄漏&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&#34;注意点&#34;&gt;&lt;a href=&#34;#注意点&#34; class=&#34;headerlink&#34; title=&#34;注意点&#34;&gt;&lt;/a&gt;注意点&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;匿名函数无法移除，要使用具名函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解绑时要和绑定的函数、参数完全一致&lt;br&gt;比如绑定的时候用了 &lt;code&gt;capture: true&lt;/code&gt;，解绑时也要加，否则解不掉：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 绑定：加了 capture: true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;element.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;click&#39;&lt;/span&gt;, handleClick, &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 解绑：必须也加 capture: true，否则无效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;element.&lt;span class=&#34;title function_&#34;&gt;removeEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;click&#39;&lt;/span&gt;, handleClick, &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-7-事件选择原则&#34;&gt;&lt;a href=&#34;#3-7-事件选择原则&#34; class=&#34;headerlink&#34; title=&#34;3.7 事件选择原则&#34;&gt;&lt;/a&gt;3.7 事件选择原则&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优先使用不会冒泡的事件&lt;/strong&gt;：如 &lt;code&gt;mouseenter/mouseleave&lt;/code&gt; 替代 &lt;code&gt;mouseover/mouseout&lt;/code&gt;&lt;blockquote&gt;
&lt;p&gt;这样可以减少事件处理函数被意外触发的可能性，同时也能减少事件传播带来的性能开销（尽管在现代浏览器中这种开销通常很小）。但要注意，它们不能用于事件委托（因为不冒泡），所以使用场景是直接绑定到目标元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移动端优先指针事件&lt;/strong&gt;：&lt;code&gt;pointerdown&lt;/code&gt; 替代 &lt;code&gt;mousedown/touchstart&lt;/code&gt;&lt;blockquote&gt;
&lt;p&gt;使用&lt;code&gt;pointerdown&lt;/code&gt;等事件可以同时支持多种输入方式，避免为鼠标和触摸分别写两套事件逻辑。这有助于代码维护和减少重复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;焦点事件使用冒泡版本&lt;/strong&gt;：&lt;code&gt;focusin/focusout&lt;/code&gt; 替代 &lt;code&gt;focus/blur&lt;/code&gt;&lt;blockquote&gt;
&lt;p&gt;因为&lt;code&gt;focus&lt;/code&gt;和&lt;code&gt;blur&lt;/code&gt;事件不冒泡，所以当我们需要在祖先元素上监听焦点变化（例如做表单验证）时，使用冒泡版本的&lt;code&gt;focusin&lt;/code&gt;和&lt;code&gt;focusout&lt;/code&gt;可以方便地实现事件委托（仅需将事件绑定在表单上），而不必在每个可聚焦元素上单独绑定事件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四、实战问题：常见坑与解决方案&#34;&gt;&lt;a href=&#34;#四、实战问题：常见坑与解决方案&#34; class=&#34;headerlink&#34; title=&#34;四、实战问题：常见坑与解决方案&#34;&gt;&lt;/a&gt;四、实战问题：常见坑与解决方案&lt;/h2&gt;&lt;h3 id=&#34;4-1-滚动事件触发太频繁，页面卡顿&#34;&gt;&lt;a href=&#34;#4-1-滚动事件触发太频繁，页面卡顿&#34; class=&#34;headerlink&#34; title=&#34;4.1 滚动事件触发太频繁，页面卡顿&#34;&gt;&lt;/a&gt;4.1 滚动事件触发太频繁，页面卡顿&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;code&gt;scroll&lt;/code&gt; 事件每秒触发几十次，处理函数里有 DOM 操作（比如修改样式、计算位置），导致主线程忙不过来，页面卡。&lt;br&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用节流控制执行频率（比如每隔 100ms 执行一次）；&lt;/li&gt;
&lt;li&gt;复杂计算用 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 包裹，让浏览器在重绘时执行，避免掉帧；&lt;/li&gt;
&lt;li&gt;能用 &lt;code&gt;IntersectionObserver&lt;/code&gt; 替代的场景，尽量不用滚动事件（比如 “元素进入视口时加载”）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优化后的滚动事件处理：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; throttledScroll = &lt;span class=&#34;title function_&#34;&gt;throttle&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 用 requestAnimationFrame 确保在重绘时执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;requestAnimationFrame&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 处理DOM操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;title function_&#34;&gt;updateNavPosition&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}, &lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;window&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;scroll&#39;&lt;/span&gt;, throttledScroll, { &lt;span class=&#34;attr&#34;&gt;passive&lt;/span&gt;: &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt; });&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;不使用滚动事件，而是使用&lt;code&gt;IntersectionObserver&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; observer = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;IntersectionObserver&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;entries&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  entries.&lt;span class=&#34;title function_&#34;&gt;forEach&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;entry&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (entry.&lt;span class=&#34;property&#34;&gt;isIntersecting&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 元素进入视口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;observer.&lt;span class=&#34;title function_&#34;&gt;observe&lt;/span&gt;(element);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;4-2-移动端点击有-300ms-延迟&#34;&gt;&lt;a href=&#34;#4-2-移动端点击有-300ms-延迟&#34; class=&#34;headerlink&#34; title=&#34;4.2 移动端点击有 300ms 延迟&#34;&gt;&lt;/a&gt;4.2 移动端点击有 300ms 延迟&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：早期移动端浏览器为了判断用户是否双击缩放，会在点击后延迟 300ms 再触发 &lt;code&gt;click&lt;/code&gt; 事件，导致按钮点击反应慢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加 viewport meta 标签，禁用缩放（推荐，简单有效）；&lt;figure class=&#34;highlight html&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;meta&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;name&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;viewport&#34;&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;content&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;width=device-width, initial-scale=1.0, user-scalable=no&#34;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;touchstart&lt;/code&gt;/&lt;code&gt;touchend&lt;/code&gt; 替代 &lt;code&gt;click&lt;/code&gt;（需要处理触摸穿透问题）；&lt;/li&gt;
&lt;li&gt;旧项目可用 FastClick 库（现在大部分现代浏览器已优化，但兼容旧设备时可能需要）。&lt;figure class=&#34;highlight html&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;script&lt;/span&gt; &lt;span class=&#34;attr&#34;&gt;src&lt;/span&gt;=&lt;span class=&#34;string&#34;&gt;&#34;https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js&#34;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;&lt;span class=&#34;name&#34;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;language-javascript&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;string&#34;&gt;&#39;addEventListener&#39;&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;) {&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;      &lt;span class=&#34;string&#34;&gt;&#39;DOMContentLoaded&#39;&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;      &lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;        &lt;span class=&#34;title class_&#34;&gt;FastClick&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;attach&lt;/span&gt;(&lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;body&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;      },&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;      &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;    );&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;language-javascript&#34;&gt;&lt;/span&gt;&lt;span class=&#34;tag&#34;&gt;&amp;lt;/&lt;span class=&#34;name&#34;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-3-事件冒泡导致父元素事件误触发&#34;&gt;&lt;a href=&#34;#4-3-事件冒泡导致父元素事件误触发&#34; class=&#34;headerlink&#34; title=&#34;4.3 事件冒泡导致父元素事件误触发&#34;&gt;&lt;/a&gt;4.3 事件冒泡导致父元素事件误触发&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：点击子元素时，父元素的同类型事件也会触发（比如子按钮和父容器都绑了 &lt;code&gt;click&lt;/code&gt; 事件）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：在子元素的事件处理函数里调用 &lt;code&gt;stopPropagation()&lt;/code&gt;，阻止事件继续冒泡。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 子元素事件：阻止冒泡，父元素事件不触发&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;querySelector&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;.child-btn&#39;&lt;/span&gt;).&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;event&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  event.&lt;span class=&#34;title function_&#34;&gt;stopPropagation&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 阻止事件冒泡到父元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;子元素被点击&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 父元素事件：子元素点击时不会触发&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;querySelector&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;.parent-container&#39;&lt;/span&gt;).&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;父元素被点击&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;4-4-单页应用切换组件，事件监听器没解绑&#34;&gt;&lt;a href=&#34;#4-4-单页应用切换组件，事件监听器没解绑&#34; class=&#34;headerlink&#34; title=&#34;4.4 单页应用切换组件，事件监听器没解绑&#34;&gt;&lt;/a&gt;4.4 单页应用切换组件，事件监听器没解绑&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：单页应用（SPA）切换组件时，旧组件的事件监听器没解绑，导致内存泄漏，甚至出现 “幽灵点击”（切换后旧组件的事件还在触发）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;组件销毁时手动解绑事件（如前面 3.6 的示例）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用 &lt;code&gt;AbortController&lt;/code&gt; 批量解绑（现代浏览器推荐）。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 方案2：用 AbortController 批量解绑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; controller = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;AbortController&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; signal = controller.&lt;span class=&#34;property&#34;&gt;signal&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 绑定多个事件，都用同一个 signal&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;element1.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;click&#39;&lt;/span&gt;, handleClick1, { signal });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;element2.&lt;span class=&#34;title function_&#34;&gt;addEventListener&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;scroll&#39;&lt;/span&gt;, handleScroll2, { signal });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 组件销毁时，调用 abort() 批量解绑所有事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;controller.&lt;span class=&#34;title function_&#34;&gt;abort&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;五、现代事件处理技巧：更高效的玩法&#34;&gt;&lt;a href=&#34;#五、现代事件处理技巧：更高效的玩法&#34; class=&#34;headerlink&#34; title=&#34;五、现代事件处理技巧：更高效的玩法&#34;&gt;&lt;/a&gt;五、现代事件处理技巧：更高效的玩法&lt;/h2&gt;&lt;h3 id=&#34;5-1-事件总线（Event-Bus）：非关联组件通信&#34;&gt;&lt;a href=&#34;#5-1-事件总线（Event-Bus）：非关联组件通信&#34; class=&#34;headerlink&#34; title=&#34;5.1 事件总线（Event Bus）：非关联组件通信&#34;&gt;&lt;/a&gt;5.1 事件总线（Event Bus）：非关联组件通信&lt;/h3&gt;&lt;p&gt;如果两个组件没有直接关系（比如兄弟组件、跨层级组件），可以用 “事件总线” 传递消息，不用一层层传 props 或用全局状态。&lt;/p&gt;
&lt;h4 id=&#34;简单实现事件总线&#34;&gt;&lt;a href=&#34;#简单实现事件总线&#34; class=&#34;headerlink&#34; title=&#34;简单实现事件总线&#34;&gt;&lt;/a&gt;简单实现事件总线&lt;/h4&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;EventBus&lt;/span&gt; = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 存储事件：key是事件名，value是回调函数数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;attr&#34;&gt;events&lt;/span&gt;: {},&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 触发事件：传事件名和数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;emit&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;eventName, data&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;events&lt;/span&gt;[eventName]) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;comment&#34;&gt;// 执行所有绑定的回调&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;events&lt;/span&gt;[eventName].&lt;span class=&#34;title function_&#34;&gt;forEach&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;cb&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;cb&lt;/span&gt;(data));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 绑定事件：传事件名和回调&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;on&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;eventName, callback&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;events&lt;/span&gt;[eventName]) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;events&lt;/span&gt;[eventName] = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;events&lt;/span&gt;[eventName].&lt;span class=&#34;title function_&#34;&gt;push&lt;/span&gt;(callback);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 解绑事件（可选）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;off&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;eventName, callback&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;events&lt;/span&gt;[eventName]) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;events&lt;/span&gt;[eventName] = &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;events&lt;/span&gt;[eventName].&lt;span class=&#34;title function_&#34;&gt;filter&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;cb&lt;/span&gt;) =&amp;gt;&lt;/span&gt; cb !== callback);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 组件A：触发事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;EventBus&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;emit&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;user-login&#39;&lt;/span&gt;, { &lt;span class=&#34;attr&#34;&gt;username&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&#39;test&#39;&lt;/span&gt; });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 组件B：监听事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;EventBus&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;on&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;user-login&#39;&lt;/span&gt;, &lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;userInfo&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`用户&lt;span class=&#34;subst&#34;&gt;${userInfo.username}&lt;/span&gt;登录了。`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;});&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;5-2-AbortController：现代事件管理&#34;&gt;&lt;a href=&#34;#5-2-AbortController：现代事件管理&#34; class=&#34;headerlink&#34; title=&#34;5.2 AbortController：现代事件管理&#34;&gt;&lt;/a&gt;5.2 AbortController：现代事件管理&lt;/h3&gt;&lt;p&gt;前面提到过 &lt;code&gt;AbortController&lt;/code&gt; 能批量解绑事件，它还能配合 fetch、定时器等使用，是现代浏览器推荐的 “资源管理” 方案。&lt;/p&gt;
&lt;h4 id=&#34;用-AbortController-取消-fetch-请求&#34;&gt;&lt;a href=&#34;#用-AbortController-取消-fetch-请求&#34; class=&#34;headerlink&#34; title=&#34;用 AbortController 取消 fetch 请求&#34;&gt;&lt;/a&gt;用 AbortController 取消 fetch 请求&lt;/h4&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; controller = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;AbortController&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; signal = controller.&lt;span class=&#34;property&#34;&gt;signal&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 发起fetch请求，传signal&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;fetch&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;/api/data&#39;&lt;/span&gt;, { signal })&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  .&lt;span class=&#34;title function_&#34;&gt;then&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; res.&lt;span class=&#34;title function_&#34;&gt;json&lt;/span&gt;())&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  .&lt;span class=&#34;title function_&#34;&gt;catch&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;err&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (err.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt; === &lt;span class=&#34;string&#34;&gt;&#39;AbortError&#39;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;请求被取消了&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  });&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 3秒后取消请求（比如用户点击“取消”按钮）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;setTimeout&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; controller.&lt;span class=&#34;title function_&#34;&gt;abort&lt;/span&gt;(), &lt;span class=&#34;number&#34;&gt;3000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;最后小测验&#34;&gt;&lt;a href=&#34;#最后小测验&#34; class=&#34;headerlink&#34; title=&#34;最后小测验&#34;&gt;&lt;/a&gt;最后小测验&lt;/h2&gt;&lt;p&gt;当用户点击一个按钮时，事件流的哪个阶段最先触发？&lt;br&gt;A) 目标阶段&lt;br&gt;B) 冒泡阶段&lt;br&gt;C) 捕获阶段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案&lt;/strong&gt;：C) 捕获阶段（事件从 &lt;code&gt;window&lt;/code&gt; 向下传递到目标元素，先经过捕获阶段，再到目标阶段，最后是冒泡阶段）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;事件系统是前端交互的核心，掌握它不仅能写出流畅的交互，还能避免很多隐藏的性能问题。建议大家在实际项目中多尝试优化技巧，比如用事件委托替代多监听器、用 &lt;code&gt;passive&lt;/code&gt; 提升滚动流畅度 —— 这些小改动能让页面体验提升一大截！&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://toukoxu.github.io/archives/prototype-chain/</guid>
            <title>原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心</title>
            <link>http://toukoxu.github.io/archives/prototype-chain/</link>
            <category>JavaScript</category>
            <category>性能优化</category>
            <category>ES6</category>
            <pubDate>Sun, 02 May 2021 20:46:25 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;原型链是 JavaScript 面向对象的 “底层逻辑”—— 它让对象能 “继承” 其他对象的属性和方法，而 ES6 的 &lt;code&gt;class&lt;/code&gt; 只是这套逻辑的 “语法糖”。今天从原型链的本质讲到 Class 的应用，帮你彻底搞懂 JS 继承到底是怎么回事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一、原型链：JS-对象继承的“底层骨架”&#34;&gt;&lt;a href=&#34;#一、原型链：JS-对象继承的“底层骨架”&#34; class=&#34;headerlink&#34; title=&#34;一、原型链：JS 对象继承的“底层骨架”&#34;&gt;&lt;/a&gt;一、原型链：JS 对象继承的 “底层骨架”&lt;/h2&gt;&lt;h3 id=&#34;1-1-什么是原型链？&#34;&gt;&lt;a href=&#34;#1-1-什么是原型链？&#34; class=&#34;headerlink&#34; title=&#34;1.1 什么是原型链？&#34;&gt;&lt;/a&gt;1.1 什么是原型链？&lt;/h3&gt;&lt;p&gt;简单说，&lt;strong&gt;原型链是 JS 实现继承的核心机制&lt;/strong&gt;：每个对象都有一个隐藏的 “原型”（&lt;code&gt;[[Prototype]]&lt;/code&gt;，可通过 &lt;code&gt;Object.getPrototypeOf()&lt;/code&gt; 访问），这个原型本身也是一个对象，它也有自己的原型 —— 这样层层向上，就形成了一条 “原型链”。&lt;/p&gt;
&lt;p&gt;当你访问一个对象的属性时，如果当前对象没有这个属性，JS 会自动沿着原型链向上查找，直到找到属性或走到链的尽头（&lt;code&gt;null&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;看个直观的例子：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 父对象：动物，有一个共享属性 eats&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; animal = { &lt;span class=&#34;attr&#34;&gt;eats&lt;/span&gt;: &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt; };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 子对象：兔子，有自己的属性 jumps&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; rabbit = { &lt;span class=&#34;attr&#34;&gt;jumps&lt;/span&gt;: &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt; };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 把 rabbit 的原型设为 animal（让兔子继承动物的属性）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;setPrototypeOf&lt;/span&gt;(rabbit, animal);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 现在兔子能访问动物的 eats 属性了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(rabbit.&lt;span class=&#34;property&#34;&gt;eats&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// true（从原型链上找到的）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;1-2-原型链的三个核心概念&#34;&gt;&lt;a href=&#34;#1-2-原型链的三个核心概念&#34; class=&#34;headerlink&#34; title=&#34;1.2 原型链的三个核心概念&#34;&gt;&lt;/a&gt;1.2 原型链的三个核心概念&lt;/h3&gt;&lt;p&gt;要理解原型链，必须分清这三个容易混淆的概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;prototype&lt;/code&gt;&lt;/strong&gt;：只有&lt;strong&gt;函数&lt;/strong&gt;才有这个属性，它是一个对象，存储着 “该函数创建的实例要继承的属性和方法”（比如 &lt;code&gt;Person.prototype&lt;/code&gt; 里的方法，会被所有 &lt;code&gt;new Person()&lt;/code&gt; 出来的实例继承）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;[[Prototype]]&lt;/code&gt;&lt;/strong&gt;：所有对象（包括函数）都有的隐藏属性，指向该对象的 “原型对象”（可通过 &lt;code&gt;Object.getPrototypeOf(obj)&lt;/code&gt; 访问，旧版的 &lt;code&gt;__proto__&lt;/code&gt; 已不推荐使用）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;constructor&lt;/code&gt;&lt;/strong&gt;：原型对象上的属性，指向 “创建该原型对应的实例的构造函数”（比如 &lt;code&gt;Person.prototype.constructor === Person&lt;/code&gt;）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它们的关系可以用一张图表示：&lt;/p&gt;
&lt;div class=&#34;mermaid-wrap&#34;&gt;&lt;pre class=&#34;mermaid-src&#34; hidden=&#34;&#34;&gt;  graph LR
A[&#34;实例对象（如 new Person()）&#34;] --&amp;gt;|&#34;[[Prototype]]&#34;| B[&#34;构造函数的 prototype（Person.prototype）&#34;]
B --&amp;gt;|&#34;[[Prototype]]&#34;| C[&#34;Object.prototype（所有对象的最终原型）&#34;]
C --&amp;gt;|&#34;[[Prototype]]&#34;| D[&#34;null（原型链的终点）&#34;]
B --&amp;gt;|constructor| E[&#34;构造函数（Person）&#34;]
  &lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;二、原型链是怎么“造”出来的？&#34;&gt;&lt;a href=&#34;#二、原型链是怎么“造”出来的？&#34; class=&#34;headerlink&#34; title=&#34;二、原型链是怎么“造”出来的？&#34;&gt;&lt;/a&gt;二、原型链是怎么 “造” 出来的？&lt;/h2&gt;&lt;h3 id=&#34;2-1-用构造函数创建对象：原型链的常见来源&#34;&gt;&lt;a href=&#34;#2-1-用构造函数创建对象：原型链的常见来源&#34; class=&#34;headerlink&#34; title=&#34;2.1 用构造函数创建对象：原型链的常见来源&#34;&gt;&lt;/a&gt;2.1 用构造函数创建对象：原型链的常见来源&lt;/h3&gt;&lt;p&gt;我们平时用 &lt;code&gt;new 构造函数()&lt;/code&gt; 创建对象时，原型链会自动生成。比如：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 1. 定义构造函数（用来创建“人”实例）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;Person&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;name&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 实例独有的属性：每个实例的 name 都不同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt; = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 2. 在构造函数的 prototype 上定义共享方法（所有实例共用）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Person&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;sayHello&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`你好，我是&lt;span class=&#34;subst&#34;&gt;${&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.name}&lt;/span&gt;`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 3. 用 new 创建实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; alice = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Person&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;Alice&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 验证原型关系&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getPrototypeOf&lt;/span&gt;(alice) === &lt;span class=&#34;title class_&#34;&gt;Person&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// true（实例的原型是构造函数的 prototype）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Person&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;constructor&lt;/span&gt; === &lt;span class=&#34;title class_&#34;&gt;Person&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// true（原型的构造函数指向原函数）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;2-2-new-操作符的底层逻辑&#34;&gt;&lt;a href=&#34;#2-2-new-操作符的底层逻辑&#34; class=&#34;headerlink&#34; title=&#34;2.2 new 操作符的底层逻辑&#34;&gt;&lt;/a&gt;2.2 &lt;code&gt;new&lt;/code&gt; 操作符的底层逻辑&lt;/h3&gt;&lt;p&gt;你可能好奇：&lt;code&gt;new&lt;/code&gt; 到底做了什么，能让实例和原型链关联起来？其实它只干了四件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个空对象（&lt;code&gt;{}&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;把这个空对象的原型，设为构造函数的 &lt;code&gt;prototype&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;执行构造函数，把 &lt;code&gt;this&lt;/code&gt; 指向这个空对象（给对象加属性）；&lt;/li&gt;
&lt;li&gt;如果构造函数没有返回其他对象，就返回这个新对象（否则返回构造函数的返回值）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以手动模拟一个 &lt;code&gt;new&lt;/code&gt; 操作符，更直观地看到这个过程：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;myNew&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;constructor, ...args&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 1. 创建空对象，并把它的原型设为构造函数的 prototype&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; obj = &lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;create&lt;/span&gt;(constructor.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 2. 执行构造函数，this 指向新对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; result = constructor.&lt;span class=&#34;title function_&#34;&gt;apply&lt;/span&gt;(obj, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 3. 返回结果：如果构造函数返回了对象，就用它；否则用新对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; result &lt;span class=&#34;keyword&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt; ? result : obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 用自定义的 myNew 创建实例，和原生 new 效果一样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; bob = &lt;span class=&#34;title function_&#34;&gt;myNew&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Person&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&#39;Bob&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;bob.&lt;span class=&#34;title function_&#34;&gt;sayHello&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 你好，我是Bob&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;三、原型链的“查找规则”：属性是怎么找到的？&#34;&gt;&lt;a href=&#34;#三、原型链的“查找规则”：属性是怎么找到的？&#34; class=&#34;headerlink&#34; title=&#34;三、原型链的“查找规则”：属性是怎么找到的？&#34;&gt;&lt;/a&gt;三、原型链的 “查找规则”：属性是怎么找到的？&lt;/h2&gt;&lt;h3 id=&#34;3-1-属性查找的完整流程&#34;&gt;&lt;a href=&#34;#3-1-属性查找的完整流程&#34; class=&#34;headerlink&#34; title=&#34;3.1 属性查找的完整流程&#34;&gt;&lt;/a&gt;3.1 属性查找的完整流程&lt;/h3&gt;&lt;p&gt;当你访问 &lt;code&gt;obj.prop&lt;/code&gt; 时，JS 会按以下步骤查找：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先检查 &lt;code&gt;obj&lt;/code&gt; 自身有没有 &lt;code&gt;prop&lt;/code&gt;（通过 &lt;code&gt;obj.hasOwnProperty(&#39;prop&#39;)&lt;/code&gt; 可判断）；&lt;/li&gt;
&lt;li&gt;如果没有，就找 &lt;code&gt;obj&lt;/code&gt; 的原型（&lt;code&gt;Object.getPrototypeOf(obj)&lt;/code&gt;），检查原型有没有 &lt;code&gt;prop&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;如果原型也没有，就找原型的原型，以此类推；&lt;/li&gt;
&lt;li&gt;直到找到 &lt;code&gt;prop&lt;/code&gt; 并返回，或者走到原型链尽头（&lt;code&gt;null&lt;/code&gt;），返回 &lt;code&gt;undefined&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看个例子理解这个流程：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 1. 定义构造函数 Animal&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;Animal&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;name&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt; = name; &lt;span class=&#34;comment&#34;&gt;// 实例独有的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 2. 在 Animal.prototype 上定义共享方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Animal&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;eat&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`&lt;span class=&#34;subst&#34;&gt;${&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.name}&lt;/span&gt; 在吃东西`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 3. 创建实例 cat&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; cat = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Animal&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;喵星人&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 4. 调用 cat.eat()，查找流程：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// ① 检查 cat 自身：没有 eat 方法 → ② 查 cat 的原型（Animal.prototype）→ 找到 eat 方法，执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;cat.&lt;span class=&#34;title function_&#34;&gt;eat&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 喵星人 在吃东西&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;3-2-原型链的终点：null&#34;&gt;&lt;a href=&#34;#3-2-原型链的终点：null&#34; class=&#34;headerlink&#34; title=&#34;3.2 原型链的终点：null&#34;&gt;&lt;/a&gt;3.2 原型链的终点：&lt;code&gt;null&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;所有原型链的最终尽头都是 &lt;code&gt;null&lt;/code&gt;—— 因为 &lt;code&gt;Object.prototype&lt;/code&gt; 的原型就是 &lt;code&gt;null&lt;/code&gt;，它是 “所有对象的最终原型”（除了用 &lt;code&gt;Object.create(null)&lt;/code&gt; 创建的 “纯净对象”）。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; cat = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Animal&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;喵星人&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 顺着原型链往上找：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getPrototypeOf&lt;/span&gt;(cat)); &lt;span class=&#34;comment&#34;&gt;// Animal.prototype（第一层）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getPrototypeOf&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Animal&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;)); &lt;span class=&#34;comment&#34;&gt;// Object.prototype（第二层）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getPrototypeOf&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;)); &lt;span class=&#34;comment&#34;&gt;// null（第三层，终点）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getPrototypeOf&lt;/span&gt;(&lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;)); &lt;span class=&#34;comment&#34;&gt;// 报错（null 没有原型）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这也解释了为什么所有对象都能调用 &lt;code&gt;toString()&lt;/code&gt;、&lt;code&gt;hasOwnProperty()&lt;/code&gt; 等方法 —— 这些方法其实定义在 &lt;code&gt;Object.prototype&lt;/code&gt; 上，所有对象都能通过原型链找到它们。&lt;/p&gt;
&lt;h2 id=&#34;四、原型链的“动态特性”：改原型会影响实例吗？&#34;&gt;&lt;a href=&#34;#四、原型链的“动态特性”：改原型会影响实例吗？&#34; class=&#34;headerlink&#34; title=&#34;四、原型链的“动态特性”：改原型会影响实例吗？&#34;&gt;&lt;/a&gt;四、原型链的 “动态特性”：改原型会影响实例吗？&lt;/h2&gt;&lt;h3 id=&#34;4-1-动态修改原型：已创建的实例也会受影响&#34;&gt;&lt;a href=&#34;#4-1-动态修改原型：已创建的实例也会受影响&#34; class=&#34;headerlink&#34; title=&#34;4.1 动态修改原型：已创建的实例也会受影响&#34;&gt;&lt;/a&gt;4.1 动态修改原型：已创建的实例也会受影响&lt;/h3&gt;&lt;p&gt;JS 的原型是 “活的”—— 即使实例已经创建，后续给原型添加的属性 / 方法，实例也能访问到：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;Dog&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 创建实例 dog1（此时 Dog.prototype 上还没有 bark 方法）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; dog1 = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Dog&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 后续给 Dog.prototype 添加 bark 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Dog&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;bark&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;汪汪！&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// dog1 能调用到新添加的 bark 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;dog1.&lt;span class=&#34;title function_&#34;&gt;bark&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 汪汪！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这是因为实例访问的是 “原型的引用”，而不是 “原型的副本”—— 原型变了，所有指向它的实例都会跟着变。&lt;/p&gt;
&lt;h3 id=&#34;4-2-重写原型：旧实例不受影响&#34;&gt;&lt;a href=&#34;#4-2-重写原型：旧实例不受影响&#34; class=&#34;headerlink&#34; title=&#34;4.2 重写原型：旧实例不受影响&#34;&gt;&lt;/a&gt;4.2 重写原型：旧实例不受影响&lt;/h3&gt;&lt;p&gt;但如果是 “完全重写原型”（而不是修改原型的属性），情况就不一样了：重写后的原型是一个新对象，只有重写后创建的实例会用新原型，之前的旧实例还是指向原来的原型。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;Cat&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 旧实例：创建于原型重写前&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; cat1 = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Cat&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 完全重写 Cat.prototype（新对象）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Cat&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt; = {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;meow&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;喵喵~&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 新实例：创建于原型重写后&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; cat2 = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Cat&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;cat1.&lt;span class=&#34;title function_&#34;&gt;meow&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 报错（cat1 的原型还是原来的空对象，没有 meow 方法）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;cat2.&lt;span class=&#34;title function_&#34;&gt;meow&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 喵喵~（cat2 的原型是新对象，有 meow 方法）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;五、ES6-Class：原型链的“语法糖”&#34;&gt;&lt;a href=&#34;#五、ES6-Class：原型链的“语法糖”&#34; class=&#34;headerlink&#34; title=&#34;五、ES6 Class：原型链的“语法糖”&#34;&gt;&lt;/a&gt;五、ES6 Class：原型链的 “语法糖”&lt;/h2&gt;&lt;h3 id=&#34;5-1-Class-本质：还是原型继承&#34;&gt;&lt;a href=&#34;#5-1-Class-本质：还是原型继承&#34; class=&#34;headerlink&#34; title=&#34;5.1 Class 本质：还是原型继承&#34;&gt;&lt;/a&gt;5.1 Class 本质：还是原型继承&lt;/h3&gt;&lt;p&gt;ES6 引入的 &lt;code&gt;class&lt;/code&gt; 语法，看起来像其他语言的 “类”，但底层还是基于原型链实现的 —— 它只是把原型继承的写法变得更简洁、更易读，没有改变 JS 的底层逻辑。&lt;/p&gt;
&lt;p&gt;比如下面两段代码，功能完全一样：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 写法1：ES6 Class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Animal&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 构造函数：对应原来的构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;constructor&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;name&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt; = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 实例方法：会被添加到 Animal.prototype 上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;eat&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`&lt;span class=&#34;subst&#34;&gt;${&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.name}&lt;/span&gt; 在吃东西`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 写法2：ES5 原型继承（和上面完全等价）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;Animal&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;name&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt; = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Animal&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;eat&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`&lt;span class=&#34;subst&#34;&gt;${&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.name}&lt;/span&gt; 在吃东西`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;5-2-Class-继承：extends-怎么工作？&#34;&gt;&lt;a href=&#34;#5-2-Class-继承：extends-怎么工作？&#34; class=&#34;headerlink&#34; title=&#34;5.2 Class 继承：extends 怎么工作？&#34;&gt;&lt;/a&gt;5.2 Class 继承：&lt;code&gt;extends&lt;/code&gt; 怎么工作？&lt;/h3&gt;&lt;p&gt;Class 的 &lt;code&gt;extends&lt;/code&gt; 关键字，本质是帮我们自动搭建了原型链。比如让 &lt;code&gt;Rabbit&lt;/code&gt; 继承 &lt;code&gt;Animal&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 子类 Rabbit 继承父类 Animal&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Rabbit&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;title class_ inherited__&#34;&gt;Animal&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;constructor&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;name, speed&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// super()：调用父类的 constructor，相当于 Animal.call(this, name)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;super&lt;/span&gt;(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 子类独有的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;speed&lt;/span&gt; = speed;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 子类独有的方法（添加到 Rabbit.prototype 上）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;jump&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`&lt;span class=&#34;subst&#34;&gt;${&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.name}&lt;/span&gt; 跳得很快，速度&lt;span class=&#34;subst&#34;&gt;${&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.speed}&lt;/span&gt;`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 创建子类实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; bunny = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Rabbit&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;小兔&#39;&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 验证继承关系&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(bunny &lt;span class=&#34;keyword&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Rabbit&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// true（是 Rabbit 的实例）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(bunny &lt;span class=&#34;keyword&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Animal&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// true（也是 Animal 的实例，因为继承）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(bunny &lt;span class=&#34;keyword&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// true（最终继承自 Object）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 调用继承的方法和自己的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;bunny.&lt;span class=&#34;title function_&#34;&gt;eat&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 小兔 在吃东西（继承自 Animal）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;bunny.&lt;span class=&#34;title function_&#34;&gt;jump&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 小兔 跳得很快，速度10（自己的方法）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;extends&lt;/code&gt; 做的核心事情：把 &lt;code&gt;Rabbit.prototype&lt;/code&gt; 的原型，设为 &lt;code&gt;Animal.prototype&lt;/code&gt;，从而搭建起 “&lt;code&gt;bunny&lt;/code&gt; → &lt;code&gt;Rabbit.prototype&lt;/code&gt; → &lt;code&gt;Animal.prototype&lt;/code&gt; → &lt;code&gt;Object.prototype&lt;/code&gt; → &lt;code&gt;null&lt;/code&gt;” 的原型链。&lt;/p&gt;
&lt;h2 id=&#34;六、原型链的实际用途：这些场景会用到&#34;&gt;&lt;a href=&#34;#六、原型链的实际用途：这些场景会用到&#34; class=&#34;headerlink&#34; title=&#34;六、原型链的实际用途：这些场景会用到&#34;&gt;&lt;/a&gt;六、原型链的实际用途：这些场景会用到&lt;/h2&gt;&lt;h3 id=&#34;6-1-共享方法：节省内存&#34;&gt;&lt;a href=&#34;#6-1-共享方法：节省内存&#34; class=&#34;headerlink&#34; title=&#34;6.1 共享方法：节省内存&#34;&gt;&lt;/a&gt;6.1 共享方法：节省内存&lt;/h3&gt;&lt;p&gt;如果多个实例需要用同一个方法，把方法放在原型上（而不是每个实例都定义一次），能大幅节省内存 —— 因为所有实例共享同一个方法引用。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;User&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;name&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt; = name; &lt;span class=&#34;comment&#34;&gt;// 每个实例独有的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 所有 User 实例共享 sayHi 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;User&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;sayHi&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`你好，&lt;span class=&#34;subst&#34;&gt;${&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.name}&lt;/span&gt;`&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; user1 = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;User&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;Alice&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; user2 = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;User&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;Bob&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 验证：两个实例的 sayHi 是同一个函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(user1.&lt;span class=&#34;property&#34;&gt;sayHi&lt;/span&gt; === user2.&lt;span class=&#34;property&#34;&gt;sayHi&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果把 &lt;code&gt;sayHi&lt;/code&gt; 写在构造函数里（&lt;code&gt;this.sayHi = function() {}&lt;/code&gt;），每个实例都会有一个独立的函数副本，内存占用会翻倍。&lt;/p&gt;
&lt;h3 id=&#34;6-2-实现自定义继承（ES5-写法）&#34;&gt;&lt;a href=&#34;#6-2-实现自定义继承（ES5-写法）&#34; class=&#34;headerlink&#34; title=&#34;6.2 实现自定义继承（ES5 写法）&#34;&gt;&lt;/a&gt;6.2 实现自定义继承（ES5 写法）&lt;/h3&gt;&lt;p&gt;在 Class 出现前，我们用原型链手动实现继承。比如让 &lt;code&gt;Circle&lt;/code&gt; 继承 &lt;code&gt;Shape&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 父类：图形&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;Shape&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;color&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;color&lt;/span&gt; = color;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 父类的共享方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Shape&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;getColor&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;color&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 子类：圆形&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;Circle&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;radius, color&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 1. 调用父类构造函数，继承父类的属性（color）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title class_&#34;&gt;Shape&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;call&lt;/span&gt;(&lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;, color);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 2. 子类独有的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;radius&lt;/span&gt; = radius;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 3. 搭建原型链：让 Circle.prototype 继承 Shape.prototype&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Circle&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt; = &lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;create&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Shape&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 4. 修复 constructor 指向（因为上面一步把 Circle.prototype 换成了新对象，constructor 会指向 Shape）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Circle&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;constructor&lt;/span&gt; = &lt;span class=&#34;title class_&#34;&gt;Circle&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 5. 子类的共享方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Circle&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;getArea&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Math&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;PI&lt;/span&gt; * &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;radius&lt;/span&gt; ** &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 使用子类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; redCircle = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Circle&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&#39;red&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(redCircle.&lt;span class=&#34;title function_&#34;&gt;getColor&lt;/span&gt;()); &lt;span class=&#34;comment&#34;&gt;// red（继承自 Shape）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(redCircle.&lt;span class=&#34;title function_&#34;&gt;getArea&lt;/span&gt;()); &lt;span class=&#34;comment&#34;&gt;// 78.539...（自己的方法）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;6-3-扩展内置对象（谨慎使用）&#34;&gt;&lt;a href=&#34;#6-3-扩展内置对象（谨慎使用）&#34; class=&#34;headerlink&#34; title=&#34;6.3 扩展内置对象（谨慎使用）&#34;&gt;&lt;/a&gt;6.3 扩展内置对象（谨慎使用）&lt;/h3&gt;&lt;p&gt;我们可以给内置对象的原型添加方法，让所有该类型的对象都能使用。比如给数组加一个 &lt;code&gt;sum&lt;/code&gt; 方法：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 给 Array.prototype 加 sum 方法，所有数组都能调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Array&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;sum&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;reduce&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;total, num&lt;/span&gt;) =&amp;gt;&lt;/span&gt; total + num, &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; numbers = [&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;4&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(numbers.&lt;span class=&#34;title function_&#34;&gt;sum&lt;/span&gt;()); &lt;span class=&#34;comment&#34;&gt;// 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;⚠️ 注意：扩展内置原型有风险！可能和其他库的方法重名（比如别人也给数组加了 &lt;code&gt;sum&lt;/code&gt; 方法），导致代码冲突。非必要不推荐用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;note warning flat&#34;&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 扩展内置原型有风险！可能和其他库的方法重名（比如别人也给数组加了 `sum` 方法），导致代码冲突。非必要不推荐用。&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&#34;七、原型链的坑：这些问题要注意&#34;&gt;&lt;a href=&#34;#七、原型链的坑：这些问题要注意&#34; class=&#34;headerlink&#34; title=&#34;七、原型链的坑：这些问题要注意&#34;&gt;&lt;/a&gt;七、原型链的坑：这些问题要注意&lt;/h2&gt;&lt;h3 id=&#34;7-1-原型污染：修改内置原型影响所有对象&#34;&gt;&lt;a href=&#34;#7-1-原型污染：修改内置原型影响所有对象&#34; class=&#34;headerlink&#34; title=&#34;7.1 原型污染：修改内置原型影响所有对象&#34;&gt;&lt;/a&gt;7.1 原型污染：修改内置原型影响所有对象&lt;/h3&gt;&lt;p&gt;如果恶意代码（或不小心）修改了 &lt;code&gt;Object.prototype&lt;/code&gt;，所有对象都会受到影响 —— 这就是 “原型污染”。比如：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 不小心给 Object.prototype 加了一个 hack 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;hack&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;所有对象都会有这个方法！&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 即使是新建的空对象，也会有 hack 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; emptyObj = {};&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;emptyObj.&lt;span class=&#34;title function_&#34;&gt;hack&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 所有对象都会有这个方法！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：用 &lt;code&gt;Object.create(null)&lt;/code&gt; 创建 “纯净对象”—— 这种对象没有原型（&lt;code&gt;[[Prototype]]&lt;/code&gt; 是 &lt;code&gt;null&lt;/code&gt;），不会继承 &lt;code&gt;Object.prototype&lt;/code&gt; 的属性，也就不会被污染：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; pureObj = &lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;create&lt;/span&gt;(&lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(pureObj.&lt;span class=&#34;property&#34;&gt;hack&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// undefined（不受原型污染影响）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;7-2-实例属性“遮蔽”原型属性&#34;&gt;&lt;a href=&#34;#7-2-实例属性“遮蔽”原型属性&#34; class=&#34;headerlink&#34; title=&#34;7.2 实例属性“遮蔽”原型属性&#34;&gt;&lt;/a&gt;7.2 实例属性 “遮蔽” 原型属性&lt;/h3&gt;&lt;p&gt;如果实例有一个和原型同名的属性，实例属性会 “覆盖” 原型属性（这叫 “属性遮蔽”）：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;Person&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 原型上的 name 属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Person&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt; = &lt;span class=&#34;string&#34;&gt;&#39;原型默认名&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 实例上的 name 属性（和原型同名）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; person = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Person&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;person.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt; = &lt;span class=&#34;string&#34;&gt;&#39;实例自定义名&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 访问时会优先用实例的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(person.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 实例自定义名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 要访问原型的属性，需要手动找原型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getPrototypeOf&lt;/span&gt;(person).&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// 原型默认名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;7-3-循环引用：导致栈溢出&#34;&gt;&lt;a href=&#34;#7-3-循环引用：导致栈溢出&#34; class=&#34;headerlink&#34; title=&#34;7.3 循环引用：导致栈溢出&#34;&gt;&lt;/a&gt;7.3 循环引用：导致栈溢出&lt;/h3&gt;&lt;p&gt;如果两个构造函数的原型互相指向对方，会形成 “循环原型链”，创建实例时会报错：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;A&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;B&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// A 的原型指向 B 的实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;A.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;B&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// B 的原型指向 A 的实例 → 循环引用！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;B.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;A&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 尝试创建实例：会触发无限递归，栈溢出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; a = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;A&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;} &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (e) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;error&lt;/span&gt;(e.&lt;span class=&#34;property&#34;&gt;message&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// Maximum call stack size exceeded&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;八、原型链最佳实践：写代码更安全&#34;&gt;&lt;a href=&#34;#八、原型链最佳实践：写代码更安全&#34; class=&#34;headerlink&#34; title=&#34;八、原型链最佳实践：写代码更安全&#34;&gt;&lt;/a&gt;八、原型链最佳实践：写代码更安全&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;优先用 Class 语法&lt;/strong&gt;：&lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;extends&lt;/code&gt; 比 ES5 手动改原型更清晰，不容易出错，比如：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Animal&lt;/span&gt; {}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Rabbit&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;title class_ inherited__&#34;&gt;Animal&lt;/span&gt; {}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不用 &lt;code&gt;__proto__&lt;/code&gt;，用标准方法操作原型&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查原型：&lt;code&gt;Object.getPrototypeOf(obj)&lt;/code&gt;（替代 &lt;code&gt;obj.__proto__&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;改原型：&lt;code&gt;Object.setPrototypeOf(obj, newProto)&lt;/code&gt;（替代 &lt;code&gt;obj.__proto__ = newProto&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;创建带原型的对象：&lt;code&gt;Object.create(proto)&lt;/code&gt;（比 &lt;code&gt;new&lt;/code&gt; 更灵活）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;属性和方法分开放&lt;/strong&gt;：构造函数里定义 “实例独有的属性”，原型上定义 “所有实例共享的方法”—— 符合内存高效利用的原则：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;Person&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;name&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;this&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;name&lt;/span&gt; = name; &lt;span class=&#34;comment&#34;&gt;// 实例独有属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;Person&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;sayName&lt;/span&gt; = &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {}; &lt;span class=&#34;comment&#34;&gt;// 共享方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;避免修改内置原型&lt;/strong&gt;：除非有绝对必要，否则不要给 &lt;code&gt;Array.prototype&lt;/code&gt;、&lt;code&gt;Object.prototype&lt;/code&gt; 等加方法，防止冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;最后小测验&#34;&gt;&lt;a href=&#34;#最后小测验&#34; class=&#34;headerlink&#34; title=&#34;最后小测验&#34;&gt;&lt;/a&gt;最后小测验&lt;/h2&gt;&lt;p&gt;看看你有没有掌握原型链的核心逻辑，下面代码会输出什么？&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;Foo&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; f1 = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Foo&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(f1 &lt;span class=&#34;keyword&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Foo&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;Object&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getPrototypeOf&lt;/span&gt;(f1) === &lt;span class=&#34;title class_&#34;&gt;Foo&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;prototype&lt;/span&gt;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;答案&lt;/strong&gt;：&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f1&lt;/code&gt; 是 &lt;code&gt;Foo&lt;/code&gt; 的实例，&lt;code&gt;Foo.prototype&lt;/code&gt; 继承自 &lt;code&gt;Object.prototype&lt;/code&gt;，所以 &lt;code&gt;f1 instanceof Object&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Foo.prototype&lt;/code&gt; 是一个普通对象，继承自 &lt;code&gt;Object.prototype&lt;/code&gt;，所以 &lt;code&gt;Foo.prototype instanceof Object&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new Foo()&lt;/code&gt; 创建的实例，原型就是 &lt;code&gt;Foo.prototype&lt;/code&gt;，所以第三个判断为 &lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;原型链虽然是 JS 的 “底层概念”，但理解它能帮你避开很多隐藏的坑（比如原型污染、属性遮蔽），也能让你更懂 Class 的本质 —— 不是 “新的继承方式”，只是原型链的优雅包装。掌握这些，你对 JS 面向对象的理解会更上一层楼～&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://toukoxu.github.io/archives/scope-chain/</guid>
            <title>作用域链（Scope Chain）：JS 变量查找的 “路线图”</title>
            <link>http://toukoxu.github.io/archives/scope-chain/</link>
            <category>JavaScript</category>
            <category>性能优化</category>
            <pubDate>Tue, 16 Mar 2021 20:46:25 +0800</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;作用域链是 JavaScript 查找变量的核心机制&lt;/strong&gt; —— 当代码需要访问一个变量时，JS 引擎会沿着 “当前作用域 → 父作用域 → 全局作用域” 的顺序层层查找，这条查找路径就像一张 “路线图”，指引引擎找到目标变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一、作用域链的本质：静态的查找路径&#34;&gt;&lt;a href=&#34;#一、作用域链的本质：静态的查找路径&#34; class=&#34;headerlink&#34; title=&#34;一、作用域链的本质：静态的查找路径&#34;&gt;&lt;/a&gt;一、作用域链的本质：静态的查找路径&lt;/h2&gt;&lt;h3 id=&#34;1-1-核心概念：从“作用域”到“作用域链”&#34;&gt;&lt;a href=&#34;#1-1-核心概念：从“作用域”到“作用域链”&#34; class=&#34;headerlink&#34; title=&#34;1.1 核心概念：从“作用域”到“作用域链”&#34;&gt;&lt;/a&gt;1.1 核心概念：从 “作用域” 到 “作用域链”&lt;/h3&gt;&lt;p&gt;首先要明确：&lt;strong&gt;作用域是变量的 “可访问范围”&lt;/strong&gt;（比如函数内部的变量只能在函数内访问），而 “作用域链” 是多个嵌套作用域组成的 “查找链条”。&lt;/p&gt;
&lt;p&gt;比如函数嵌套场景，内部函数会形成包含父函数作用域、祖父函数作用域的链条，最终指向全局作用域：&lt;/p&gt;
&lt;div class=&#34;mermaid-wrap&#34;&gt;&lt;pre class=&#34;mermaid-src&#34; hidden=&#34;&#34;&gt;  graph LR
A[当前作用域（如 inner 函数）] --&amp;gt; B[父作用域（如 outer 函数）]
B --&amp;gt; C[祖父作用域（更外层函数）]
C --&amp;gt; D[...]
D --&amp;gt; E[全局作用域]
  &lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&#34;1-2-关键特性：作用域链“定义时确定，而非调用时”&#34;&gt;&lt;a href=&#34;#1-2-关键特性：作用域链“定义时确定，而非调用时”&#34; class=&#34;headerlink&#34; title=&#34;1.2 关键特性：作用域链“定义时确定，而非调用时”&#34;&gt;&lt;/a&gt;1.2 关键特性：作用域链 “定义时确定，而非调用时”&lt;/h3&gt;&lt;p&gt;这是理解作用域链的核心 —— 函数的作用域链在&lt;strong&gt;函数定义的那一刻就固定了&lt;/strong&gt;，和函数什么时候调用、在哪里调用无关。这个特性也是闭包（👉 &lt;a href=&#34;/archives/closure/&#34; title=&#34;闭包（Closure）：JavaScript 里的“记忆小助手”&#34;&gt;闭包（Closure）：JavaScript 里的 “记忆小助手”&lt;/a&gt;）能 “记住外部变量” 的底层原因。&lt;/p&gt;
&lt;p&gt;看个例子验证：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;outer&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; outerVar = &lt;span class=&#34;string&#34;&gt;&#39;我是外层变量&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 父作用域的变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// inner 函数在 outer 内部定义，此时就确定了作用域链：inner → outer → 全局&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;inner&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(outerVar); &lt;span class=&#34;comment&#34;&gt;// 能访问 outerVar，因为作用域链包含 outer 作用域&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; inner; &lt;span class=&#34;comment&#34;&gt;// 返回 inner 函数（此时 inner 已携带作用域链）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 调用 outer，拿到 inner 函数（此时 outer 已执行完，但 inner 的作用域链还在）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; innerFunc = &lt;span class=&#34;title function_&#34;&gt;outer&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;innerFunc&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 输出“我是外层变量”（inner 按定义时的作用域链找到了 outerVar）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;div class=&#34;note warning flat&#34;&gt;&lt;p&gt;&lt;strong&gt;重点：&lt;/strong&gt; 作用域链是 “静态” 的 —— 函数定义时就确定，不会因调用位置变化而改变。&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;二、作用域链的组成：变量查找的层级结构&#34;&gt;&lt;a href=&#34;#二、作用域链的组成：变量查找的层级结构&#34; class=&#34;headerlink&#34; title=&#34;二、作用域链的组成：变量查找的层级结构&#34;&gt;&lt;/a&gt;二、作用域链的组成：变量查找的层级结构&lt;/h2&gt;&lt;p&gt;作用域链由 “嵌套的作用域” 按顺序组成，通常分为以下几层，查找时严格遵循 “从内到外” 的顺序：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;层级&lt;/th&gt;
&lt;th&gt;作用域类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;1️⃣&lt;/td&gt;
&lt;td&gt;局部作用域&lt;/td&gt;
&lt;td&gt;当前执行代码的作用域（如函数内部、&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; 块内）&lt;/td&gt;
&lt;td&gt;函数内用 &lt;code&gt;let&lt;/code&gt; 声明的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2️⃣&lt;/td&gt;
&lt;td&gt;父级作用域&lt;/td&gt;
&lt;td&gt;包含当前作用域的外层作用域（如嵌套函数的父函数）&lt;/td&gt;
&lt;td&gt;父函数内的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;td&gt;更多嵌套父级&lt;/td&gt;
&lt;td&gt;层层向外的作用域（如祖父函数、曾祖父函数）&lt;/td&gt;
&lt;td&gt;更外层函数的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;🌍&lt;/td&gt;
&lt;td&gt;全局作用域&lt;/td&gt;
&lt;td&gt;最顶层作用域（浏览器中是 &lt;code&gt;window&lt;/code&gt;，Node.js 中是 &lt;code&gt;global&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;直接在脚本顶层声明的变量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&#34;实际查找过程：按链条顺序查找&#34;&gt;&lt;a href=&#34;#实际查找过程：按链条顺序查找&#34; class=&#34;headerlink&#34; title=&#34;实际查找过程：按链条顺序查找&#34;&gt;&lt;/a&gt;实际查找过程：按链条顺序查找&lt;/h3&gt;&lt;p&gt;看一段代码，直观感受变量查找的步骤：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 全局作用域的变量 🌍&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; globalVar = &lt;span class=&#34;string&#34;&gt;&#39;我是全局变量&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;outer&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// outer 作用域的变量（父作用域）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; outerVar = &lt;span class=&#34;string&#34;&gt;&#39;我是外层变量&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;inner&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// inner 作用域的变量（当前作用域）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; innerVar = &lt;span class=&#34;string&#34;&gt;&#39;我是内层变量&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// 变量查找过程：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(innerVar); &lt;span class=&#34;comment&#34;&gt;// 1. 先查当前作用域 → 找到，直接使用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(outerVar); &lt;span class=&#34;comment&#34;&gt;// 2. 当前作用域没有 → 查父作用域（outer）→ 找到&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(globalVar); &lt;span class=&#34;comment&#34;&gt;// 3. 父作用域没有 → 查全局作用域 → 找到&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(notExistVar); &lt;span class=&#34;comment&#34;&gt;// 4. 全局作用域也没有 → 抛出 ReferenceError&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;title function_&#34;&gt;inner&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;outer&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;三、作用域链-vs-执行上下文：别搞混的两个概念&#34;&gt;&lt;a href=&#34;#三、作用域链-vs-执行上下文：别搞混的两个概念&#34; class=&#34;headerlink&#34; title=&#34;三、作用域链 vs 执行上下文：别搞混的两个概念&#34;&gt;&lt;/a&gt;三、作用域链 vs 执行上下文：别搞混的两个概念&lt;/h2&gt;&lt;p&gt;很多人会把 “作用域链” 和 “执行上下文” 弄混，其实它们是完全不同的概念 —— 一个是 “静态查找路径”，一个是 “动态执行环境”。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;作用域链&lt;/th&gt;
&lt;th&gt;执行上下文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;创建时机&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;函数&lt;strong&gt;定义时&lt;/strong&gt;（静态固定）&lt;/td&gt;
&lt;td&gt;函数&lt;strong&gt;调用时&lt;/strong&gt;（动态创建）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;核心内容&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;变量的查找顺序（路径）&lt;/td&gt;
&lt;td&gt;当前执行的代码、&lt;code&gt;this&lt;/code&gt; 指向、变量对象等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;是否变化&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不变化（定义后固定）&lt;/td&gt;
&lt;td&gt;每次调用都创建新的执行上下文（动态变化）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;生命周期&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;和函数生命周期一致（函数存在则链存在）&lt;/td&gt;
&lt;td&gt;函数执行期间存在，执行完后被销毁&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;简单说：&lt;strong&gt;作用域链决定 “变量能在哪里找到”&lt;/strong&gt;，而&lt;strong&gt;执行上下文决定 “代码当前如何执行”&lt;/strong&gt;。执行上下文会包含作用域链，但作用域链本身是独立的静态结构。&lt;/p&gt;
&lt;h2 id=&#34;四、ES6-块级作用域：让作用域链更精细&#34;&gt;&lt;a href=&#34;#四、ES6-块级作用域：让作用域链更精细&#34; class=&#34;headerlink&#34; title=&#34;四、ES6 块级作用域：让作用域链更精细&#34;&gt;&lt;/a&gt;四、ES6 块级作用域：让作用域链更精细&lt;/h2&gt;&lt;p&gt;ES6 之前，JS 只有 “函数作用域” 和 “全局作用域”，&lt;code&gt;var&lt;/code&gt; 声明的变量会 “穿透”&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt; 等块级结构。ES6 引入的 &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; 解决了这个问题，带来了 “块级作用域”—— 变量只在 &lt;code&gt;{}&lt;/code&gt; 包裹的块内有效，也会加入作用域链。&lt;/p&gt;
&lt;h3 id=&#34;4-1-块级作用域的影响：变量不再“穿透”&#34;&gt;&lt;a href=&#34;#4-1-块级作用域的影响：变量不再“穿透”&#34; class=&#34;headerlink&#34; title=&#34;4.1 块级作用域的影响：变量不再“穿透”&#34;&gt;&lt;/a&gt;4.1 块级作用域的影响：变量不再 “穿透”&lt;/h3&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;{&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; blockVar = &lt;span class=&#34;string&#34;&gt;&#39;我只在块内有效&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// let 声明的块级变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; funcVar = &lt;span class=&#34;string&#34;&gt;&#39;我在函数内有效（穿透块）&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// var 声明的函数级变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(funcVar); &lt;span class=&#34;comment&#34;&gt;// 输出“我在函数内有效（穿透块）”（var 不支持块级）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(blockVar); &lt;span class=&#34;comment&#34;&gt;// 报错 ReferenceError（let 限制在块内，作用域链找不到）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;4-2-块级作用域的查找逻辑&#34;&gt;&lt;a href=&#34;#4-2-块级作用域的查找逻辑&#34; class=&#34;headerlink&#34; title=&#34;4.2 块级作用域的查找逻辑&#34;&gt;&lt;/a&gt;4.2 块级作用域的查找逻辑&lt;/h3&gt;&lt;p&gt;块级作用域会成为作用域链的一环，查找时同样遵循 “从内到外”：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;blockExample&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; topVar = &lt;span class=&#34;string&#34;&gt;&#39;顶层变量（函数内）&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 函数作用域的变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; innerVar = &lt;span class=&#34;string&#34;&gt;&#39;块内变量&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 块级作用域的变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(topVar); &lt;span class=&#34;comment&#34;&gt;// ✅ 块级作用域 → 函数作用域，找到 topVar&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(innerVar); &lt;span class=&#34;comment&#34;&gt;// ❌ 函数作用域无法向下查找块级作用域，报错&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;blockExample&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;五、作用域链的实战技巧：优化与封装&#34;&gt;&lt;a href=&#34;#五、作用域链的实战技巧：优化与封装&#34; class=&#34;headerlink&#34; title=&#34;五、作用域链的实战技巧：优化与封装&#34;&gt;&lt;/a&gt;五、作用域链的实战技巧：优化与封装&lt;/h2&gt;&lt;h3 id=&#34;5-1-性能优化：减少作用域链查找次数&#34;&gt;&lt;a href=&#34;#5-1-性能优化：减少作用域链查找次数&#34; class=&#34;headerlink&#34; title=&#34;5.1 性能优化：减少作用域链查找次数&#34;&gt;&lt;/a&gt;5.1 性能优化：减少作用域链查找次数&lt;/h3&gt;&lt;p&gt;作用域链层级越深，查找变量的速度越慢。如果某个变量需要频繁访问（比如循环中），可以把它 “缓存” 到当前作用域，减少查找次数。在实际项目中，我经常会用到它来优化代码！&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 优化前：每次循环都要沿作用域链查找全局的 document（层级深，慢）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;number&#34;&gt;1000&lt;/span&gt;; i++) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;getElementById&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`item-&lt;span class=&#34;subst&#34;&gt;${i}&lt;/span&gt;`&lt;/span&gt;).&lt;span class=&#34;property&#34;&gt;style&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;color&lt;/span&gt; = &lt;span class=&#34;string&#34;&gt;&#39;red&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 优化后：把全局的 document 缓存到当前作用域（只查找一次，快）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; doc = &lt;span class=&#34;variable language_&#34;&gt;document&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 一次查找全局作用域，缓存到当前作用域&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;number&#34;&gt;1000&lt;/span&gt;; i++) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  doc.&lt;span class=&#34;title function_&#34;&gt;getElementById&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;`item-&lt;span class=&#34;subst&#34;&gt;${i}&lt;/span&gt;`&lt;/span&gt;).&lt;span class=&#34;property&#34;&gt;style&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;color&lt;/span&gt; = &lt;span class=&#34;string&#34;&gt;&#39;red&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 直接访问当前作用域的 doc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;5-2-模块模式：用作用域链实现“私有变量”&#34;&gt;&lt;a href=&#34;#5-2-模块模式：用作用域链实现“私有变量”&#34; class=&#34;headerlink&#34; title=&#34;5.2 模块模式：用作用域链实现“私有变量”&#34;&gt;&lt;/a&gt;5.2 模块模式：用作用域链实现 “私有变量”&lt;/h3&gt;&lt;p&gt;JS 没有原生的 “私有变量” 语法，但可以通过 “立即执行函数（IIFE）” 创建独立作用域，利用作用域链的 “隔离性” 实现私有变量封装（外部无法访问函数内部变量）。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;CounterModule&lt;/span&gt; = (&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 私有变量：只能在 IIFE 内部访问（作用域链限制）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; privateCount = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 私有函数：同样只能内部访问&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;privateIncrement&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    privateCount++;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 暴露公共接口：外部只能通过这些方法操作私有变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;attr&#34;&gt;increment&lt;/span&gt;: &lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;title function_&#34;&gt;privateIncrement&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;当前计数：&#39;&lt;/span&gt;, privateCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;attr&#34;&gt;reset&lt;/span&gt;: &lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      privateCount = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;计数已重置&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    },&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;})();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 使用公共接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;CounterModule&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;increment&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 输出“当前计数：1”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;CounterModule&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;increment&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 输出“当前计数：2”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title class_&#34;&gt;CounterModule&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;reset&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 输出“计数已重置”&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 尝试访问私有变量：无法找到（作用域链不包含 IIFE 内部）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(&lt;span class=&#34;title class_&#34;&gt;CounterModule&lt;/span&gt;.&lt;span class=&#34;property&#34;&gt;privateCount&lt;/span&gt;); &lt;span class=&#34;comment&#34;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&#34;六、常见陷阱：避开作用域链的坑&#34;&gt;&lt;a href=&#34;#六、常见陷阱：避开作用域链的坑&#34; class=&#34;headerlink&#34; title=&#34;六、常见陷阱：避开作用域链的坑&#34;&gt;&lt;/a&gt;六、常见陷阱：避开作用域链的坑&lt;/h2&gt;&lt;h3 id=&#34;6-1-循环中的变量问题（var-vs-let）&#34;&gt;&lt;a href=&#34;#6-1-循环中的变量问题（var-vs-let）&#34; class=&#34;headerlink&#34; title=&#34;6.1 循环中的变量问题（var vs let）&#34;&gt;&lt;/a&gt;6.1 循环中的变量问题（var vs let）&lt;/h3&gt;&lt;p&gt;ES6 之前用 &lt;code&gt;var&lt;/code&gt; 声明循环变量，会因 &lt;code&gt;var&lt;/code&gt; 没有块级作用域导致 “所有回调共享同一个变量”；用 &lt;code&gt;let&lt;/code&gt; 则会为每次循环创建独立的块级作用域，解决这个问题。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 问题代码（var 无块级作用域）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;; i++) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;built_in&#34;&gt;setTimeout&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(i); &lt;span class=&#34;comment&#34;&gt;// 输出 3、3、3（所有回调共享全局的 i，循环结束后 i=3）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }, &lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 解决方案1：用 let 创建块级作用域&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;; i++) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;built_in&#34;&gt;setTimeout&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(i); &lt;span class=&#34;comment&#34;&gt;// 输出 0、1、2（每次循环有独立的 i）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  }, &lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 解决方案2：ES5 兼容方案（立即执行函数创建作用域）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;keyword&#34;&gt;var&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&#34;number&#34;&gt;3&lt;/span&gt;; i++) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  (&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;j&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;// j 是每次循环的 i 的副本，存在独立作用域&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;setTimeout&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(j); &lt;span class=&#34;comment&#34;&gt;// 输出 0、1、2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }, &lt;span class=&#34;number&#34;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  })(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;6-2-变量遮蔽（Variable-Shadowing）&#34;&gt;&lt;a href=&#34;#6-2-变量遮蔽（Variable-Shadowing）&#34; class=&#34;headerlink&#34; title=&#34;6.2 变量遮蔽（Variable Shadowing）&#34;&gt;&lt;/a&gt;6.2 变量遮蔽（Variable Shadowing）&lt;/h3&gt;&lt;p&gt;如果内层作用域的变量名和外层作用域一致，内层变量会 “遮蔽” 外层变量（查找时找到内层变量后就停止，不会继续向上找）。&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; message = &lt;span class=&#34;string&#34;&gt;&#39;全局消息&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 外层变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;showMessage&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; message = &lt;span class=&#34;string&#34;&gt;&#39;局部消息&#39;&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 内层变量，遮蔽外层的 message&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(message); &lt;span class=&#34;comment&#34;&gt;// 输出“局部消息”（找到内层变量后停止查找）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;showMessage&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(message); &lt;span class=&#34;comment&#34;&gt;// 输出“全局消息”（外层变量未被影响）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;div class=&#34;note warning flat&#34;&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 遮蔽是 “暂时性” 的，只影响内层作用域的查找，不会修改外层变量。&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;七、作用域链与内存管理：避免内存泄漏&#34;&gt;&lt;a href=&#34;#七、作用域链与内存管理：避免内存泄漏&#34; class=&#34;headerlink&#34; title=&#34;七、作用域链与内存管理：避免内存泄漏&#34;&gt;&lt;/a&gt;七、作用域链与内存管理：避免内存泄漏&lt;/h2&gt;&lt;h3 id=&#34;7-1-作用域链与垃圾回收&#34;&gt;&lt;a href=&#34;#7-1-作用域链与垃圾回收&#34; class=&#34;headerlink&#34; title=&#34;7.1 作用域链与垃圾回收&#34;&gt;&lt;/a&gt;7.1 作用域链与垃圾回收&lt;/h3&gt;&lt;p&gt;JS 的垃圾回收机制（GC）会回收 “不再被引用的变量”。如果作用域链断裂（比如函数执行完后，没有闭包引用其内部变量），作用域内的变量就会被 GC 清理。&lt;/p&gt;
&lt;p&gt;流程如下：&lt;/p&gt;
&lt;div class=&#34;mermaid-wrap&#34;&gt;&lt;pre class=&#34;mermaid-src&#34; hidden=&#34;&#34;&gt;  graph TD
A[变量不再被任何作用域引用] --&amp;gt; B[作用域链对该变量的引用断开]
B --&amp;gt; C[GC 标记该变量为“可回收”]
C --&amp;gt; D[内存被释放]
  &lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&#34;7-2-常见内存泄漏场景&#34;&gt;&lt;a href=&#34;#7-2-常见内存泄漏场景&#34; class=&#34;headerlink&#34; title=&#34;7.2 常见内存泄漏场景&#34;&gt;&lt;/a&gt;7.2 常见内存泄漏场景&lt;/h3&gt;&lt;h4 id=&#34;（1）意外创建全局变量&#34;&gt;&lt;a href=&#34;#（1）意外创建全局变量&#34; class=&#34;headerlink&#34; title=&#34;（1）意外创建全局变量&#34;&gt;&lt;/a&gt;（1）意外创建全局变量&lt;/h4&gt;&lt;p&gt;忘记用 &lt;code&gt;var&lt;/code&gt;/&lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; 声明变量，变量会自动成为全局变量，挂载到 &lt;code&gt;window&lt;/code&gt; 上，作用域链一直包含它，导致无法回收：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;createLeak&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 错误：忘记写 let，leak 成为全局变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  leak = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Array&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1000000&lt;/span&gt;).&lt;span class=&#34;title function_&#34;&gt;fill&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;大量数据&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;title function_&#34;&gt;createLeak&lt;/span&gt;(); &lt;span class=&#34;comment&#34;&gt;// 执行后，leak 一直存在于全局作用域，无法被 GC 回收&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&#34;（2）闭包导致的内存泄漏&#34;&gt;&lt;a href=&#34;#（2）闭包导致的内存泄漏&#34; class=&#34;headerlink&#34; title=&#34;（2）闭包导致的内存泄漏&#34;&gt;&lt;/a&gt;（2）闭包导致的内存泄漏&lt;/h4&gt;&lt;p&gt;如果闭包长期被引用（比如挂载到全局），它引用的外层变量（即使很大）也会一直存在于作用域链中，无法回收：&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;createBigClosure&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 大数组：占用大量内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; hugeArray = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Array&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;1000000&lt;/span&gt;).&lt;span class=&#34;title function_&#34;&gt;fill&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&#39;我是大数据&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;comment&#34;&gt;// 闭包：引用了 hugeArray&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;function&#34;&gt;() =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable language_&#34;&gt;console&lt;/span&gt;.&lt;span class=&#34;title function_&#34;&gt;log&lt;/span&gt;(hugeArray.&lt;span class=&#34;property&#34;&gt;length&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  };&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 闭包被全局变量引用，导致 hugeArray 一直存在于作用域链&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;const&lt;/span&gt; globalClosure = &lt;span class=&#34;title function_&#34;&gt;createBigClosure&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;解决办法：不再需要闭包时，手动将其设为 &lt;code&gt;null&lt;/code&gt;（&lt;code&gt;globalClosure = null&lt;/code&gt;），断开引用，让 GC 能回收 &lt;code&gt;hugeArray&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;作用域链是 JS 变量查找的 “底层规则”，理解它不仅能帮你避开 “变量找不到”“变量值不对” 的坑，还能让你更清晰地理解闭包、模块模式等高级特性。&lt;br&gt;记住核心：&lt;strong&gt;作用域链是静态的，定义时确定；查找时从内到外，找到即停&lt;/strong&gt; —— 掌握这个规则，就能轻松驾驭 JS 的变量访问逻辑！&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
