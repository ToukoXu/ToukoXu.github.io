{
    "version": "https://jsonfeed.org/version/1",
    "title": "Touko • All posts by \"性能优化\" tag",
    "description": "这是一个博客网站，记录我的学习和生活点滴。",
    "home_page_url": "http://toukoxu.github.io",
    "items": [
        {
            "id": "http://toukoxu.github.io/archives/proxy/",
            "url": "http://toukoxu.github.io/archives/proxy/",
            "title": "代理（Proxy）：ES6 元编程的 “对象拦截器”",
            "date_published": "2024-08-15T12:46:25.000Z",
            "content_html": "<blockquote>\n<p><strong>Proxy</strong> 是 ES6 引入的元编程特性，简单说就是给对象 “装一层拦截器”—— 所有对对象的操作（比如读属性、改属性、删属性），都会先经过这层拦截器，我们可以在拦截器里自定义操作逻辑。它的灵活性极高，是 Vue3 响应式、数据验证、API 拦截等场景的核心技术。</p>\n</blockquote>\n<h2 id=\"关联知识\"><a href=\"#关联知识\" class=\"headerlink\" title=\"关联知识\"></a>关联知识</h2><p>可以将 Proxy 和 Reflect 合并在一起学习～</p>\n<div><a class=\"tag-Link\" target=\"_blank\" href=\"/archives/reflect\">\n    <div class=\"tag-link-bottom\">\n        <div class=\"tag-link-left\" style=\"background-image: url(/img/512.png)\">\n          <i class=\"anzhiyufont anzhiyu-icon-link\" style=\"display: none\"></i>\n        </div>\n        <div class=\"tag-link-right\">\n            <div class=\"tag-link-title\">Reflect：ES6 标准化对象操作的 “工具库”</div>\n            <div class=\"tag-link-sitename\"> Touko</div>\n        </div>\n        <i class=\"anzhiyufont anzhiyu-icon-angle-right\"></i>\n    </div>\n    </a></div>\n\n<h2 id=\"一、Proxy-的核心：三要素与基础用法\"><a href=\"#一、Proxy-的核心：三要素与基础用法\" class=\"headerlink\" title=\"一、Proxy 的核心：三要素与基础用法\"></a>一、Proxy 的核心：三要素与基础用法</h2><p>Proxy 的使用很直观，核心是 <code>new Proxy(target, handler)</code> 这个构造函数，需要传入两个关键参数：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本语法：创建一个代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(target, handler);</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li><strong>target</strong>：被代理的 “目标对象”（可以是普通对象、数组、函数，甚至另一个代理）。</li>\n<li><strong>handler</strong>：“拦截器配置对象”，里面定义了各种 “拦截方法”（比如 <code>get</code> 拦截读操作，<code>set</code> 拦截写操作）。</li>\n<li><strong>proxy</strong>：生成的 “代理对象”—— 后续操作都要通过这个代理对象，才能触发拦截逻辑。</li>\n</ul>\n<p>举个最简单的例子：给普通对象加一层拦截，监控属性的读写：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 目标对象：一个普通用户对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = { <span class=\"attr\">name</span>: <span class=\"string\">'Alice'</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 拦截器配置：定义要拦截的操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> userHandler = {</span><br><span class=\"line\">  <span class=\"comment\">// 拦截“读属性”操作（比如 proxy.name）</span></span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`正在读取属性：<span class=\"subst\">${propKey}</span>`</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 用 Reflect.get 保持默认读逻辑（避免破坏原对象行为）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"comment\">// 拦截“写属性”操作（比如 proxy.age = 29）</span></span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">target, propKey, value</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`正在修改属性 <span class=\"subst\">${propKey}</span>：从 <span class=\"subst\">${target[propKey]}</span> 改成 <span class=\"subst\">${value}</span>`</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 用 Reflect.set 保持默认写逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, propKey, value);</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxyUser = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(user, userHandler);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试拦截效果</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(proxyUser.<span class=\"property\">name</span>); <span class=\"comment\">// 触发 get：输出“正在读取属性：name”，再输出“Alice”</span></span><br><span class=\"line\">proxyUser.<span class=\"property\">age</span> = <span class=\"number\">29</span>; <span class=\"comment\">// 触发 set：输出“正在修改属性 age：从 28 改成 29”</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"二、13-种核心拦截方法：覆盖所有对象操作\"><a href=\"#二、13-种核心拦截方法：覆盖所有对象操作\" class=\"headerlink\" title=\"二、13 种核心拦截方法：覆盖所有对象操作\"></a>二、13 种核心拦截方法：覆盖所有对象操作</h2><p>Proxy 提供了 13 种拦截方法，覆盖了对象的几乎所有基础操作。我整理了日常开发中最常用的几种，按使用频率排序：</p>\n<table>\n<thead>\n<tr>\n<th>拦截器方法</th>\n<th>触发时机</th>\n<th>示例</th>\n<th>核心作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>get(target, propKey, receiver)</code></td>\n<td>读取对象属性时</td>\n<td><code>proxy.name</code>、<code>proxy[0]</code></td>\n<td>监控属性读取、返回自定义值（比如默认值）</td>\n</tr>\n<tr>\n<td><code>set(target, propKey, value, receiver)</code></td>\n<td>设置对象属性时</td>\n<td><code>proxy.age = 30</code></td>\n<td>验证属性值、监控属性修改</td>\n</tr>\n<tr>\n<td><code>has(target, propKey)</code></td>\n<td>使用 <code>in</code> 操作符时</td>\n<td><code>'name' in proxy</code></td>\n<td>自定义 “属性是否存在” 的判断逻辑</td>\n</tr>\n<tr>\n<td><code>deleteProperty(target, propKey)</code></td>\n<td>使用 <code>delete</code> 操作时</td>\n<td><code>delete proxy.age</code></td>\n<td>监控属性删除、阻止敏感属性删除</td>\n</tr>\n<tr>\n<td><code>apply(target, thisArg, args)</code></td>\n<td>代理的目标是函数，且函数被调用时</td>\n<td><code>proxy(1, 2)</code></td>\n<td>拦截函数调用、修改参数或返回值</td>\n</tr>\n<tr>\n<td><code>construct(target, args)</code></td>\n<td>代理的目标是构造函数，且用 <code>new</code> 创建实例时</td>\n<td><code>new proxy(1, 2)</code></td>\n<td>拦截实例创建、修改实例属性</td>\n</tr>\n<tr>\n<td><code>ownKeys(target)</code></td>\n<td>遍历对象属性时（如 <code>Object.keys(proxy)</code>、<code>for...in</code>）</td>\n<td><code>Object.keys(proxy)</code></td>\n<td>自定义遍历返回的属性列表（比如隐藏敏感属性）</td>\n</tr>\n</tbody></table>\n<p>其他拦截方法多用于底层元编程，日常开发中较少直接使用，了解即可。</p>\n<ul>\n<li>getOwnPropertyDescriptor(target, propKey)</li>\n<li>defineProperty(target, propKey, propDesc)</li>\n<li>preventExtensions(target)</li>\n<li>getPrototypeOf(target)</li>\n<li>isExtensible(target)</li>\n<li>setPrototypeOf(target, proto)</li>\n</ul>\n<h2 id=\"三、Proxy-的实战场景：这些地方用它最香\"><a href=\"#三、Proxy-的实战场景：这些地方用它最香\" class=\"headerlink\" title=\"三、Proxy 的实战场景：这些地方用它最香\"></a>三、Proxy 的实战场景：这些地方用它最香</h2><h3 id=\"3-1-响应式数据（Vue3-核心原理）\"><a href=\"#3-1-响应式数据（Vue3-核心原理）\" class=\"headerlink\" title=\"3.1 响应式数据（Vue3 核心原理）\"></a>3.1 响应式数据（Vue3 核心原理）</h3><p>Vue3 的响应式系统就是基于 Proxy 实现的 —— 通过拦截对象的 <code>get</code>（收集依赖）和 <code>set</code>（触发更新），实现 “数据变，视图自动变”。</p>\n<p>简化版实现如下：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储依赖：key 是目标对象，value 是该对象各属性的依赖列表</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> reactiveMap = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakMap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 收集依赖：记录“哪个函数在用这个属性”</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">track</span>(<span class=\"params\">target, propKey</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 这里简化处理，实际 Vue 中会关联组件渲染函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!reactiveMap.<span class=\"title function_\">has</span>(target)) {</span><br><span class=\"line\">    reactiveMap.<span class=\"title function_\">set</span>(target, <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>());</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">const</span> propMap = reactiveMap.<span class=\"title function_\">get</span>(target);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!propMap.<span class=\"title function_\">has</span>(propKey)) {</span><br><span class=\"line\">    propMap.<span class=\"title function_\">set</span>(propKey, <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>());</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">// 假设当前依赖是一个“更新函数”</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">updateFn</span> = (<span class=\"params\"></span>) =&gt; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`属性 <span class=\"subst\">${propKey}</span> 变了，更新视图！`</span>);</span><br><span class=\"line\">  propMap.<span class=\"title function_\">get</span>(propKey).<span class=\"title function_\">add</span>(updateFn);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 触发更新：通知所有依赖该属性的函数执行</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">trigger</span>(<span class=\"params\">target, propKey</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!reactiveMap.<span class=\"title function_\">has</span>(target)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> propMap = reactiveMap.<span class=\"title function_\">get</span>(target);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (propMap.<span class=\"title function_\">has</span>(propKey)) {</span><br><span class=\"line\">    propMap.<span class=\"title function_\">get</span>(propKey).<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">fn</span>) =&gt;</span> <span class=\"title function_\">fn</span>());</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成响应式对象的核心函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reactive</span>(<span class=\"params\">target</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 避免重复代理（同一对象只代理一次）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (reactiveMap.<span class=\"title function_\">has</span>(target)) <span class=\"keyword\">return</span> reactiveMap.<span class=\"title function_\">get</span>(target);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(target, {</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey, receiver</span>) {</span><br><span class=\"line\">      <span class=\"comment\">// 读取属性时，收集依赖</span></span><br><span class=\"line\">      <span class=\"title function_\">track</span>(target, propKey);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey, receiver);</span><br><span class=\"line\">      <span class=\"comment\">// 嵌套对象递归代理（比如 user.address.city 也能响应）</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value === <span class=\"string\">'object'</span> &amp;&amp; value !== <span class=\"literal\">null</span> ? <span class=\"title function_\">reactive</span>(value) : value;</span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">target, propKey, value, receiver</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">const</span> oldValue = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey, receiver);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> success = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, propKey, value, receiver);</span><br><span class=\"line\">      <span class=\"comment\">// 只有值真的变了，才触发更新</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (oldValue !== value) {</span><br><span class=\"line\">        <span class=\"title function_\">trigger</span>(target, propKey);</span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">    },</span><br><span class=\"line\">  });</span><br><span class=\"line\"></span><br><span class=\"line\">  reactiveMap.<span class=\"title function_\">set</span>(target, proxy);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试响应式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = <span class=\"title function_\">reactive</span>({ <span class=\"attr\">name</span>: <span class=\"string\">'Bob'</span>, <span class=\"attr\">address</span>: { <span class=\"attr\">city</span>: <span class=\"string\">'Beijing'</span> } });</span><br><span class=\"line\">user.<span class=\"property\">name</span> = <span class=\"string\">'Charlie'</span>; <span class=\"comment\">// 触发 set → 输出“属性 name 变了，更新视图！”</span></span><br><span class=\"line\">user.<span class=\"property\">address</span>.<span class=\"property\">city</span> = <span class=\"string\">'Shanghai'</span>; <span class=\"comment\">// 嵌套对象也触发 → 输出“属性 city 变了，更新视图！”</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-2-数据验证：确保属性值符合规则\"><a href=\"#3-2-数据验证：确保属性值符合规则\" class=\"headerlink\" title=\"3.2 数据验证：确保属性值符合规则\"></a>3.2 数据验证：确保属性值符合规则</h3><p>比如要求 <code>age</code> 必须是正整数，<code>name</code> 不能是空字符串 —— 通过 <code>set</code> 拦截器就能实现：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义验证规则的拦截器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> validatorHandler = {</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">target, propKey, value</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (propKey) {</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'age'</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 验证 age 必须是正整数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"title class_\">Number</span>.<span class=\"title function_\">isInteger</span>(value) || value &lt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">`年龄 <span class=\"subst\">${value}</span> 无效！必须是正整数`</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'name'</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 验证 name 不能是空字符串</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value !== <span class=\"string\">'string'</span> || value.<span class=\"title function_\">trim</span>() === <span class=\"string\">''</span>) {</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">'姓名不能为空！'</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 验证通过，执行默认的赋值逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, propKey, value);</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建带验证的代理对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>({}, validatorHandler);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试验证逻辑</span></span><br><span class=\"line\">person.<span class=\"property\">age</span> = <span class=\"number\">30</span>; <span class=\"comment\">// 验证通过</span></span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">'David'</span>; <span class=\"comment\">// 验证通过</span></span><br><span class=\"line\"></span><br><span class=\"line\">person.<span class=\"property\">age</span> = <span class=\"string\">'thirty'</span>; <span class=\"comment\">// 报错：TypeError: 年龄 thirty 无效！必须是正整数</span></span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">''</span>; <span class=\"comment\">// 报错：TypeError: 姓名不能为空！</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-3-API-请求拦截：统一管理接口调用\"><a href=\"#3-3-API-请求拦截：统一管理接口调用\" class=\"headerlink\" title=\"3.3 API 请求拦截：统一管理接口调用\"></a>3.3 API 请求拦截：统一管理接口调用</h3><p>比如给所有 API 调用加 “请求日志” 和 “基础 URL 拼接”，不用每次调用都写重复逻辑：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 目标对象：存储 API 基础配置</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> apiConfig = { <span class=\"attr\">baseURL</span>: <span class=\"string\">'https://api.example.com'</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// API 拦截器：拦截属性访问，返回封装后的请求函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> apiHandler = {</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, endpoint</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 比如访问 api.users，返回一个请求 /users 接口的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">async</span> (params) =&gt; {</span><br><span class=\"line\">      <span class=\"comment\">// 统一加请求日志</span></span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`调用 API：<span class=\"subst\">${endpoint}</span>，参数：`</span>, params);</span><br><span class=\"line\">      <span class=\"comment\">// 统一拼接基础 URL</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> url = <span class=\"string\">`<span class=\"subst\">${target.baseURL}</span>/<span class=\"subst\">${endpoint}</span>`</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 发送请求</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url, {</span><br><span class=\"line\">        <span class=\"attr\">method</span>: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">        <span class=\"attr\">headers</span>: { <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/json'</span> },</span><br><span class=\"line\">        <span class=\"attr\">body</span>: <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(params),</span><br><span class=\"line\">      });</span><br><span class=\"line\">      <span class=\"keyword\">return</span> response.<span class=\"title function_\">json</span>();</span><br><span class=\"line\">    };</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建 API 代理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> api = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(apiConfig, apiHandler);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 API：简洁且统一</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> userData = <span class=\"keyword\">await</span> api.<span class=\"title function_\">users</span>({ <span class=\"attr\">id</span>: <span class=\"number\">123</span> }); <span class=\"comment\">// 调用 https://api.example.com/users</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> orderData = <span class=\"keyword\">await</span> api.<span class=\"title function_\">orders</span>({ <span class=\"attr\">userId</span>: <span class=\"number\">123</span> }); <span class=\"comment\">// 调用 https://api.example.com/orders</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-4-自动持久化：修改数据自动存到本地存储\"><a href=\"#3-4-自动持久化：修改数据自动存到本地存储\" class=\"headerlink\" title=\"3.4 自动持久化：修改数据自动存到本地存储\"></a>3.4 自动持久化：修改数据自动存到本地存储</h3><p>比如让配置数据修改后自动保存到 <code>localStorage</code>，刷新页面也不会丢：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建“自动持久化”的代理函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createPersistentState</span>(<span class=\"params\">storageKey, initialState</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 从 localStorage 读取已有数据（没有则用初始值）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> storedData = <span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">getItem</span>(storageKey);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = storedData ? <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(storedData) : initialState;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 拦截 set 操作：修改后自动保存</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = {</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">target, propKey, value</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">const</span> success = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, propKey, value);</span><br><span class=\"line\">      <span class=\"comment\">// 自动同步到 localStorage</span></span><br><span class=\"line\">      <span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">setItem</span>(storageKey, <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(target));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">    },</span><br><span class=\"line\">  };</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(state, handler);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建自动持久化的配置对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> appSettings = <span class=\"title function_\">createPersistentState</span>(<span class=\"string\">'app-settings'</span>, {</span><br><span class=\"line\">  <span class=\"attr\">theme</span>: <span class=\"string\">'light'</span>,</span><br><span class=\"line\">  <span class=\"attr\">fontSize</span>: <span class=\"number\">16</span>,</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试：修改后自动保存到 localStorage</span></span><br><span class=\"line\">appSettings.<span class=\"property\">theme</span> = <span class=\"string\">'dark'</span>; <span class=\"comment\">// localStorage 里的 app-settings 会自动更新</span></span><br><span class=\"line\">appSettings.<span class=\"property\">fontSize</span> = <span class=\"number\">18</span>; <span class=\"comment\">// 同样自动保存</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-5-数组变化监听：完美支持数组方法\"><a href=\"#3-5-数组变化监听：完美支持数组方法\" class=\"headerlink\" title=\"3.5 数组变化监听：完美支持数组方法\"></a>3.5 数组变化监听：完美支持数组方法</h3><p>Proxy 能原生拦截数组的 <code>push</code>、<code>pop</code>、<code>splice</code> 等方法，不用像 <code>Object.defineProperty</code> 那样做特殊 hack：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组拦截器：监控数组操作</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayHandler = {</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 拦截数组的变异方法（push、pop 等）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> mutationMethods = [<span class=\"string\">'push'</span>, <span class=\"string\">'pop'</span>, <span class=\"string\">'shift'</span>, <span class=\"string\">'unshift'</span>, <span class=\"string\">'splice'</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mutationMethods.<span class=\"title function_\">includes</span>(propKey)) {</span><br><span class=\"line\">      <span class=\"comment\">// 返回包装后的方法，保留原逻辑并加监控</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) {</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`数组执行 <span class=\"subst\">${propKey}</span>，参数：`</span>, args);</span><br><span class=\"line\">        <span class=\"comment\">// 调用数组原生方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>[propKey].<span class=\"title function_\">apply</span>(target, args);</span><br><span class=\"line\">      };</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 非数组方法，走默认逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey);</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试数组代理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> list = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], arrayHandler);</span><br><span class=\"line\">list.<span class=\"title function_\">push</span>(<span class=\"number\">4</span>); <span class=\"comment\">// 触发拦截：输出“数组执行 push，参数：[4]”，数组变成 [1,2,3,4]</span></span><br><span class=\"line\">list.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>); <span class=\"comment\">// 触发拦截：输出“数组执行 splice，参数：[0,1]”，数组变成 [2,3,4]</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"四、Proxy-实战注意事项与优化\"><a href=\"#四、Proxy-实战注意事项与优化\" class=\"headerlink\" title=\"四、Proxy 实战注意事项与优化\"></a>四、Proxy 实战注意事项与优化</h2><h3 id=\"4-1-必须用-Reflect-保持默认行为\"><a href=\"#4-1-必须用-Reflect-保持默认行为\" class=\"headerlink\" title=\"4.1 必须用 Reflect 保持默认行为\"></a>4.1 必须用 Reflect 保持默认行为</h3><p><code>Reflect</code> 是 ES6 配合 Proxy 推出的 API，它的方法和 Proxy 的拦截器一一对应（比如 <code>Reflect.get</code> 对应 <code>get</code> 拦截器）。在拦截器里用 <code>Reflect</code> 而不是直接操作 <code>target</code>，能确保：</p>\n<ul>\n<li>保持对象的默认行为（比如 <code>this</code> 指向正确）；</li>\n<li>正确处理复杂场景（比如继承属性、不可写属性）。</li>\n</ul>\n<p>反例（不推荐）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> badHandler = {</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target[propKey]; <span class=\"comment\">// 直接操作 target，可能破坏继承等默认行为</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>正例（推荐）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> goodHandler = {</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey, receiver</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey, receiver); <span class=\"comment\">// 用 Reflect 保持默认行为</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-2-避免过度代理：减少性能开销\"><a href=\"#4-2-避免过度代理：减少性能开销\" class=\"headerlink\" title=\"4.2 避免过度代理：减少性能开销\"></a>4.2 避免过度代理：减少性能开销</h3><p>Proxy 虽然灵活，但创建和递归代理会有性能开销，尤其是处理大型对象或频繁操作时。优化技巧：</p>\n<ol>\n<li><strong>避免重复代理</strong>：用 <code>WeakMap</code> 缓存已代理的对象，同一对象只代理一次（参考 3.1 响应式的 <code>reactiveMap</code>）；</li>\n<li><strong>浅层代理优先</strong>：如果只需要监控顶层属性，不用递归代理嵌套对象；</li>\n<li><strong>性能关键场景不用 Proxy</strong>：比如高频更新的列表、大型数据计算，用普通对象更高效。</li>\n</ol>\n<h3 id=\"4-3-嵌套对象代理：需要递归处理\"><a href=\"#4-3-嵌套对象代理：需要递归处理\" class=\"headerlink\" title=\"4.3 嵌套对象代理：需要递归处理\"></a>4.3 嵌套对象代理：需要递归处理</h3><p>Proxy 只能拦截 “直接操作的属性”，如果目标对象有嵌套对象（比如 <code>user.address.city</code>），直接代理顶层对象无法拦截嵌套属性的操作 —— 需要在 <code>get</code> 拦截器里递归代理嵌套对象：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> nestedHandler = {</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, propKey, receiver</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, propKey, receiver);</span><br><span class=\"line\">    <span class=\"comment\">// 如果值是对象且非 null，递归代理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value === <span class=\"string\">'object'</span> &amp;&amp; value !== <span class=\"literal\">null</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(value, nestedHandler);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">target, propKey, value</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`修改 <span class=\"subst\">${propKey}</span>：<span class=\"subst\">${value}</span>`</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, propKey, value);</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试嵌套代理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>({ <span class=\"attr\">address</span>: { <span class=\"attr\">city</span>: <span class=\"string\">'Beijing'</span> } }, nestedHandler);</span><br><span class=\"line\">user.<span class=\"property\">address</span>.<span class=\"property\">city</span> = <span class=\"string\">'Shanghai'</span>; <span class=\"comment\">// 触发 set：输出“修改 city：Shanghai”</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-4-浏览器兼容性：旧环境回退\"><a href=\"#4-4-浏览器兼容性：旧环境回退\" class=\"headerlink\" title=\"4.4 浏览器兼容性：旧环境回退\"></a>4.4 浏览器兼容性：旧环境回退</h3><p>Proxy 不支持 IE 浏览器，如果需要兼容旧环境，可以用 <code>Object.defineProperty</code> 做回退（类似 Vue2 的响应式方案）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createCompatProxy</span>(<span class=\"params\">target, handler</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 现代浏览器：用 Proxy</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"title class_\">Proxy</span> !== <span class=\"string\">'undefined'</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(target, handler);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 旧浏览器：用 Object.defineProperty 模拟（仅支持 get/set）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(target)) {</span><br><span class=\"line\">    <span class=\"comment\">// 数组回退：拦截索引和长度</span></span><br><span class=\"line\">    target.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">_, index</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(target, index, {</span><br><span class=\"line\">        <span class=\"title function_\">get</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">          <span class=\"keyword\">return</span> handler.<span class=\"property\">get</span>?.(target, index);</span><br><span class=\"line\">        },</span><br><span class=\"line\">        <span class=\"title function_\">set</span>(<span class=\"params\">value</span>) {</span><br><span class=\"line\">          handler.<span class=\"property\">set</span>?.(target, index, value);</span><br><span class=\"line\">        },</span><br><span class=\"line\">      });</span><br><span class=\"line\">    });</span><br><span class=\"line\">  } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 对象回退：拦截属性</span></span><br><span class=\"line\">    <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(target).<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(target, key, {</span><br><span class=\"line\">        <span class=\"title function_\">get</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">          <span class=\"keyword\">return</span> handler.<span class=\"property\">get</span>?.(target, key);</span><br><span class=\"line\">        },</span><br><span class=\"line\">        <span class=\"title function_\">set</span>(<span class=\"params\">value</span>) {</span><br><span class=\"line\">          handler.<span class=\"property\">set</span>?.(target, key, value);</span><br><span class=\"line\">        },</span><br><span class=\"line\">      });</span><br><span class=\"line\">    });</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"五、Proxy-vs-Object-defineProperty：核心差异\"><a href=\"#五、Proxy-vs-Object-defineProperty：核心差异\" class=\"headerlink\" title=\"五、Proxy vs Object.defineProperty：核心差异\"></a>五、Proxy vs Object.defineProperty：核心差异</h2><p>很多人会把 Proxy 和 ES5 的 <code>Object.defineProperty</code> 对比，两者都是 “对象拦截” 方案，但 Proxy 更强大、更灵活：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Proxy（ES6）</th>\n<th>Object.defineProperty（ES5）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>嵌套对象监听</td>\n<td>✅ 支持（需递归代理）</td>\n<td>❌ 不支持，需手动递归实现</td>\n</tr>\n<tr>\n<td>数组监听</td>\n<td>✅ 原生支持（push、splice 等方法）</td>\n<td>❌ 需 hack 数组原型，不完美</td>\n</tr>\n<tr>\n<td>新增属性监听</td>\n<td>✅ 自动支持（比如 <code>proxy.newKey = 1</code>）</td>\n<td>❌ 不支持，需手动调用 <code>defineProperty</code></td>\n</tr>\n<tr>\n<td>删除属性监听</td>\n<td>✅ 支持（<code>delete proxy.key</code>）</td>\n<td>❌ 不支持</td>\n</tr>\n<tr>\n<td>拦截操作数量</td>\n<td>13 种（覆盖所有对象操作）</td>\n<td>仅 2 种（get / set）</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>现代浏览器优化良好，一般场景足够用</td>\n<td>稍快，但功能有限</td>\n</tr>\n<tr>\n<td>浏览器支持</td>\n<td>现代浏览器（Chrome、Firefox、Edge），不支持 IE</td>\n<td>支持到 IE9</td>\n</tr>\n</tbody></table>\n<p>简单说：如果不需要兼容 IE，优先用 Proxy；如果需要兼容旧环境，才考虑 <code>Object.defineProperty</code>。</p>\n<h2 id=\"六、Proxy-的局限性\"><a href=\"#六、Proxy-的局限性\" class=\"headerlink\" title=\"六、Proxy 的局限性\"></a>六、Proxy 的局限性</h2><p>Proxy 虽强，但也有一些无法突破的限制：</p>\n<ol>\n<li><strong>无法拦截全等比较</strong>：<code>proxy === target</code> 永远是 <code>false</code>（代理和原对象是两个不同的引用）；</li>\n<li><strong>无法拦截某些内部方法</strong>：比如 <code>Object.prototype.toString.call(proxy)</code>，返回的是代理对象的类型，无法自定义；</li>\n<li><strong>序列化问题</strong>：代理对象不能直接用 <code>JSON.stringify</code> 序列化（会序列化原对象的属性，但拦截逻辑不生效）；</li>\n<li><strong>内存消耗</strong>：深度代理大型对象（比如嵌套多层的数组 / 对象），会占用较多内存。</li>\n</ol>\n<hr>\n<p>Proxy 是 ES6 中最强大的特性之一，它的核心价值在于 “不修改原对象，却能自定义对象的行为”—— 这种 “非侵入式” 的拦截能力，让它在框架开发、工具库、数据处理等场景中大放异彩。掌握 Proxy，不仅能看懂 Vue3 等框架的底层逻辑，还能写出更灵活、更优雅的代码～</p>\n",
            "tags": [
                "JavaScript",
                "性能优化",
                "ES6"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/async+await/",
            "url": "http://toukoxu.github.io/archives/async+await/",
            "title": "Async / Await：用同步的方式写异步，真香！",
            "date_published": "2024-07-13T12:46:25.000Z",
            "content_html": "<blockquote>\n<p>async/await 是 ES2017 引入的强大特性，使得处理异步操作变得更加简单和直观。使用 async 声明的函数总是返回一个 Promise，而 await 关键字则像是它的指挥棒，允许你暂停函数的执行，直到 Promise 被解决或拒绝。这种方式让异步代码看起来更像同步代码，从而提高了可读性和可维护性。尤其在处理链式异步操作和错误捕获时，async/await 显示出其独特的优势。</p>\n</blockquote>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>如果对生成器函数和 yield 不太熟悉，可以先看看下面这篇，了解基础后再看 Async / Await 会更顺～</p>\n<div><a class=\"tag-Link\" target=\"_blank\" href=\"/archives/generator\">\n    <div class=\"tag-link-bottom\">\n        <div class=\"tag-link-left\" style=\"background-image: url(/img/512.png)\">\n          <i class=\"anzhiyufont anzhiyu-icon-link\" style=\"display: none\"></i>\n        </div>\n        <div class=\"tag-link-right\">\n            <div class=\"tag-link-title\">生成器函数与 yield</div>\n            <div class=\"tag-link-sitename\"> Touko</div>\n        </div>\n        <i class=\"anzhiyufont anzhiyu-icon-angle-right\"></i>\n    </div>\n    </a></div>\n\n<h2 id=\"一、Async-Await-的本质：老熟人的默契配合\"><a href=\"#一、Async-Await-的本质：老熟人的默契配合\" class=\"headerlink\" title=\"一、Async/Await 的本质：老熟人的默契配合\"></a>一、Async / Await 的本质：老熟人的默契配合</h2><p>你可能觉得 Async / Await 是 JavaScript 里的 “新黑科技”，但其实它的底层是三个老熟人在搭班子干活。说穿了，就是把咱们早就眼熟的技术组合得更顺手了。</p>\n<h3 id=\"1-1-三大核心组件\"><a href=\"#1-1-三大核心组件\" class=\"headerlink\" title=\"1.1 三大核心组件\"></a>1.1 三大核心组件</h3><ul>\n<li><strong>Generator（生成器）</strong>：提供<strong>暂停 - 恢复</strong>的能力，就像给函数装了个暂停键</li>\n<li><strong>Promise</strong>：处理<strong>异步操作</strong>的 “标准接口”，负责管理异步结果</li>\n<li><strong>自动执行器</strong>：默默工作的<strong>调度员</strong>，悄悄驱动生成器跑完全程</li>\n</ul>\n<h3 id=\"1-2-从代码看转换逻辑\"><a href=\"#1-2-从代码看转换逻辑\" class=\"headerlink\" title=\"1.2 从代码看转换逻辑\"></a>1.2 从代码看转换逻辑</h3><p>咱们写的 Async 函数，其实会被引擎偷偷转换成类似生成器的结构。比如这样一段代码：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 咱们写的优雅代码</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> api.<span class=\"title function_\">get</span>(<span class=\"string\">'/data'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">process</span>(data);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>引擎背地里会把它转成差不多这样（简化版）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引擎实际处理的样子</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// spawn就是那个自动执行器，负责驱动生成器</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">spawn</span>(<span class=\"keyword\">function</span>* () {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">yield</span> api.<span class=\"title function_\">get</span>(<span class=\"string\">'/data'</span>); <span class=\"comment\">// 用yield代替await</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">process</span>(data);</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<div class=\"note info flat\"><p><strong>这里有个小细节：</strong> 每个 Async 函数都被转换成一个生成器函数，由<mark>自动执行器</mark>接管执行！</p>咱们不用手动调用<code>next()</code>，全是执行器在后台搞定，这也是<code>Async/Await</code>比直接用<code>Generator</code>方便的地方～</div>\n\n<h2 id=\"二、自动执行器：幕后的引擎\"><a href=\"#二、自动执行器：幕后的引擎\" class=\"headerlink\" title=\"二、自动执行器：幕后的引擎\"></a>二、自动执行器：幕后的引擎</h2><p>自动执行器是 Async / Await 能自动跑起来的关键，我试着简化了它的核心代码，大概长这样：</p>\n<h3 id=\"2-1-核心逻辑（简化版）\"><a href=\"#2-1-核心逻辑（简化版）\" class=\"headerlink\" title=\"2.1 核心逻辑（简化版）\"></a>2.1 核心逻辑（简化版）</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">spawn</span>(<span class=\"params\">generatorFunc</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 返回一个Promise，这也是async函数总返回Promise的原因</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> generator = <span class=\"title function_\">generatorFunc</span>(); <span class=\"comment\">// 创建生成器实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 步进函数：驱动生成器一步步执行</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">step</span>(<span class=\"params\">nextFn</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">try</span> {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> { value, done } = <span class=\"title function_\">nextFn</span>(); <span class=\"comment\">// 执行到下一个yield</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (done) {</span><br><span class=\"line\">          <span class=\"comment\">// 生成器跑完了，把结果传给Promise</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title function_\">resolve</span>(value);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把yield后的结果包装成Promise（不管是不是Promise）</span></span><br><span class=\"line\">        <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(value).<span class=\"title function_\">then</span>(</span><br><span class=\"line\">          <span class=\"comment\">// 成功了就把结果传给下一次next()，继续执行</span></span><br><span class=\"line\">          <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"title function_\">next</span>(v)),</span><br><span class=\"line\">          <span class=\"comment\">// 失败了就把错误抛回生成器，让try/catch接住</span></span><br><span class=\"line\">          <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"keyword\">throw</span>(e)),</span><br><span class=\"line\">        );</span><br><span class=\"line\">      } <span class=\"keyword\">catch</span> (e) {</span><br><span class=\"line\">        <span class=\"comment\">// 捕获生成器内部的错误</span></span><br><span class=\"line\">        <span class=\"title function_\">reject</span>(e);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 启动生成器</span></span><br><span class=\"line\">    <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"title function_\">next</span>());</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"2-2-执行过程图解\"><a href=\"#2-2-执行过程图解\" class=\"headerlink\" title=\"2.2 执行过程图解\"></a>2.2 执行过程图解</h3><p>我画了个流程图帮大家理解，其实就是执行器在中间当 “裁判”，协调生成器和异步操作：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  sequenceDiagram\nparticipant 调用者\nparticipant Async 函数\nparticipant 执行器\nparticipant 生成器\n\n    调用者-&gt;&gt;Async函数: 调用 asyncFunc()\n    Async函数-&gt;&gt;执行器: “麻烦帮我跑一下这个生成器”\n    执行器-&gt;&gt;生成器: “开始执行咯（调用next()）”\n    生成器--&gt;&gt;执行器: “遇到await了，先停在这”（返回yield的值）\n    执行器-&gt;&gt;Promise: “等你结果出来喊我”\n    Promise--&gt;&gt;执行器: “搞定，结果在这”\n    执行器-&gt;&gt;生成器:  “继续跑吧，这是刚才的结果”（调用next(结果)）\n    生成器--&gt;&gt;执行器: “跑完了，这是最终结果”\n    执行器-&gt;&gt;调用者: “任务完成，给你结果”（Promise resolved）\n\n  </pre></div>\n\n<p>简单说就是：执行器启动生成器后，每次遇到 yield（也就是咱们写的 await）就停下来等异步结果，拿到结果再叫醒生成器继续跑，直到结束。全程不用手动干预，比直接用 Generator 省太多事了～</p>\n<h2 id=\"三、await-到底做了什么？四步看懂它的“小动作”\"><a href=\"#三、await-到底做了什么？四步看懂它的“小动作”\" class=\"headerlink\" title=\"三、await 到底做了什么？四步看懂它的“小动作”\"></a>三、await 到底做了什么？四步看懂它的 “小动作”</h2><p>每次写<code>await</code>的时候，引擎其实在背后干了四件事，我拆开来给大家说说：</p>\n<ol>\n<li><strong>暂停当前函数</strong>：就像按了暂停键，当前的变量、执行位置都被 “冻” 起来</li>\n<li><strong>包装异步结果</strong>：不管 await 后面是 Promise 还是普通值（比如 await 42），都会被转成 Promise。普通值会被 Promise.resolve() 包一层，确保统一用 Promise 处理</li>\n<li><strong>注册回调</strong>：把 await 后面的代码（比如拿到 data 后处理的逻辑）打包成一个微任务，注册到事件循环里</li>\n<li><strong>让出主线程</strong>：当前函数暂停后，主线程会去执行其他任务（比如渲染、处理其他事件），等 Promise 有结果了，再回头执行刚才打包的微任务</li>\n</ol>\n<div class=\"note info flat\"><p><strong>这里有个性能小细节：</strong> <code>await</code>不会阻塞主线程！它只是把后续代码挂起（包装成<mark>微任务</mark>），让主线程先忙别的。这也是为什么用<code>await</code>的时候，页面不会卡 —— 因为它会主动 “让道”。</p>\n</div>\n\n<h2 id=\"四、错误处理：try-catch-居然能管到异步操作？\"><a href=\"#四、错误处理：try-catch-居然能管到异步操作？\" class=\"headerlink\" title=\"四、错误处理：try/catch 居然能管到异步操作？\"></a>四、错误处理：try / catch 居然能管到异步操作？</h2><p>这是我觉得 Async/Await 最方便的一点：用同步代码里的 try/catch 就能搞定异步错误，不用像回调那样嵌套多层 error 处理。</p>\n<h3 id=\"4-1-同步式的错误处理\"><a href=\"#4-1-同步式的错误处理\" class=\"headerlink\" title=\"4.1 同步式的错误处理\"></a>4.1 同步式的错误处理</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchUser</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">'/user'</span>); <span class=\"comment\">// 可能失败</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> posts = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">`/posts/<span class=\"subst\">${user.id}</span>`</span>); <span class=\"comment\">// 依赖上一步结果，也可能失败</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> { user, posts };</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">    <span class=\"comment\">// 不管哪一步失败，都会跑到这里</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">'请求失败:'</span>, error);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> { <span class=\"attr\">user</span>: <span class=\"literal\">null</span>, <span class=\"attr\">posts</span>: [] };</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-2-背后的错误传递\"><a href=\"#4-2-背后的错误传递\" class=\"headerlink\" title=\"4.2 背后的错误传递\"></a>4.2 背后的错误传递</h3><p>为什么 try / catch 能抓到异步错误？秘密在自动执行器的这段代码里：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自动执行器处理Promise的部分</span></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(value).<span class=\"title function_\">then</span>(</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"title function_\">next</span>(v)), <span class=\"comment\">// 成功就传结果继续执行</span></span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> <span class=\"title function_\">step</span>(<span class=\"function\">() =&gt;</span> generator.<span class=\"keyword\">throw</span>(e)), <span class=\"comment\">// 失败就把错误抛回生成器！</span></span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>当 await 后面的 Promise 失败时，执行器会调用<code>generator.throw(e)</code>，把错误 “扔回” 生成器函数内部。这时候生成器里的 try / catch 就会像捕获同步错误一样，把这个异步错误接住。</p>\n<blockquote>\n<p>之前用回调的时候，每次异步操作都要单独写 error 处理，现在一个 try / catch 全搞定，代码清爽多了～</p>\n</blockquote>\n<h2 id=\"五、性能优化：我在项目里掉过的性能坑\"><a href=\"#五、性能优化：我在项目里掉过的性能坑\" class=\"headerlink\" title=\"五、性能优化：我在项目里掉过的性能坑\"></a>五、性能优化：我在项目里掉过的性能坑</h2><p>分享几个我实际开发中遇到的问题，都是关于 Async / Await 性能的，新手很容易踩坑：</p>\n<h3 id=\"5-1-坑一：没必要的顺序执行\"><a href=\"#5-1-坑一：没必要的顺序执行\" class=\"headerlink\" title=\"5.1 坑一：没必要的顺序执行\"></a>5.1 坑一：没必要的顺序执行</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反面例子：两个请求本来可以同时跑，却写成了顺序执行</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">slowFetch</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"keyword\">await</span> <span class=\"title function_\">fetchA</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = <span class=\"keyword\">await</span> <span class=\"title function_\">fetchB</span>(); <span class=\"comment\">// 等A完了才开始B</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> [a, b];</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这两个请求如果没依赖关系（比如 A 不影响 B 的参数），完全可以同时启动，我后来改成这样：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 优化后：同时启动两个请求，总耗时是最慢那个的时间</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fastFetch</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 先同时发起请求，拿到两个Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> promiseA = <span class=\"title function_\">fetchA</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promiseB = <span class=\"title function_\">fetchB</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 再等它们结果</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"keyword\">await</span> promiseA;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = <span class=\"keyword\">await</span> promiseB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> [a, b];</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-2-坑二：多余的-await-包装\"><a href=\"#5-2-坑二：多余的-await-包装\" class=\"headerlink\" title=\"5.2 坑二：多余的 await 包装\"></a>5.2 坑二：多余的 await 包装</h3><p>有时候会下意识地在 return 前面加 await，但其实没必要：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 多余的await</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getData</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"title function_\">fetchData</span>(); <span class=\"comment\">// fetchData本身已经返回Promise</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>因为 Async 函数会自动把返回值包成 Promise，这里的 await 纯属多此一举，直接 return 就行：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更简洁高效</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getData</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">fetchData</span>(); <span class=\"comment\">// 等价于上面的写法，但少一层Promise包装</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-3-多个异步操作：用-Promise-all-处理并行\"><a href=\"#5-3-多个异步操作：用-Promise-all-处理并行\" class=\"headerlink\" title=\"5.3 多个异步操作：用 Promise.all()处理并行\"></a>5.3 多个异步操作：用 Promise.all() 处理并行</h3><p>如果需要等多个异步操作都完成，<code>Promise.all()</code>配合 await 是绝配，下面的写法在实际项目中会经常用到哦~</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchAll</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 同时启动，等所有请求完成</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [user, posts] = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([<span class=\"title function_\">fetch</span>(<span class=\"string\">'/user'</span>), <span class=\"title function_\">fetch</span>(<span class=\"string\">'/posts'</span>)]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> { user, posts };</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<div class=\"note warning flat\"><p><strong>不过要注意：</strong> <code>Promise.all()</code>是 “一损俱损”，只要有一个请求失败，整个就会报错，这时候可以用<code>Promise.allSettled()</code>处理需要全部结果的场景（哪怕部分失败）。</p>\n</div>\n\n<h3 id=\"5-4-高级技巧：模块里的顶级-await\"><a href=\"#5-4-高级技巧：模块里的顶级-await\" class=\"headerlink\" title=\"5.4 高级技巧：模块里的顶级 await\"></a>5.4 高级技巧：模块里的顶级 await</h3><p>现在很多打包工具（比如 Webpack、Vite）已经支持模块顶层的 await 了，不用再包在 Async 函数里：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接在模块顶层用await</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = <span class=\"keyword\">await</span> <span class=\"title function_\">loadConfig</span>(); <span class=\"comment\">// 加载配置</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> settings = <span class=\"title function_\">process</span>(config);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其实引擎会把模块转成类似这样</span></span><br><span class=\"line\"><span class=\"title function_\">loadConfig</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">config</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">const</span> settings = <span class=\"title function_\">process</span>(config);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在做一个工具库的时候用过这个，用来加载动态配置，比以前用 IIFE（立即执行函数）清爽多了。</p>\n<h2 id=\"六、Async-Await-实战场景：这些地方用起来超顺手\"><a href=\"#六、Async-Await-实战场景：这些地方用起来超顺手\" class=\"headerlink\" title=\"六、Async/Await 实战场景：这些地方用起来超顺手\"></a>六、Async / Await 实战场景：这些地方用起来超顺手</h2><h3 id=\"6-1-异步初始化（比如数据库连接）\"><a href=\"#6-1-异步初始化（比如数据库连接）\" class=\"headerlink\" title=\"6.1 异步初始化（比如数据库连接）\"></a>6.1 异步初始化（比如数据库连接）</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Database</span> {</span><br><span class=\"line\">  <span class=\"comment\">// 静态方法做异步初始化</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">init</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> connection = <span class=\"keyword\">await</span> <span class=\"title function_\">createConnection</span>(); <span class=\"comment\">// 建立连接（异步）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Database</span>(connection);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用的时候直接await</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> db = <span class=\"keyword\">await</span> <span class=\"title class_\">Database</span>.<span class=\"title function_\">init</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这种场景如果用回调，很容易写成嵌套的 init 回调，用 Async / Await 就清晰多了。</p>\n<h3 id=\"6-2-有依赖关系的顺序请求\"><a href=\"#6-2-有依赖关系的顺序请求\" class=\"headerlink\" title=\"6.2 有依赖关系的顺序请求\"></a>6.2 有依赖关系的顺序请求</h3><p>比如先拿用户 ID，再用 ID 查订单：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">purchase</span>(<span class=\"params\">itemId</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> <span class=\"title function_\">getUser</span>(); <span class=\"comment\">// 先查用户</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> item = <span class=\"keyword\">await</span> <span class=\"title function_\">getItem</span>(itemId); <span class=\"comment\">// 再查商品</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">validatePurchase</span>(user, item); <span class=\"comment\">// 验证能否购买（异步）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> receipt = <span class=\"keyword\">await</span> <span class=\"title function_\">createReceipt</span>(user, item); <span class=\"comment\">// 生成订单</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> receipt;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>步骤再复杂，用顺序 await 写出来也像同步代码一样好懂。</p>\n<h3 id=\"6-3-带重试的请求\"><a href=\"#6-3-带重试的请求\" class=\"headerlink\" title=\"6.3 带重试的请求\"></a>6.3 带重试的请求</h3><p>处理可能偶尔失败的接口时，用 Async / Await 写重试逻辑很直观：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchWithRetry</span>(<span class=\"params\">url, retries = <span class=\"number\">3</span></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">  } <span class=\"keyword\">catch</span> (error) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retries &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> error; <span class=\"comment\">// 重试次数用完</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">delay</span>(<span class=\"number\">1000</span>); <span class=\"comment\">// 等1秒再重试</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">fetchWithRetry</span>(url, retries - <span class=\"number\">1</span>); <span class=\"comment\">// 递归重试</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在对接一个不稳定的第三方接口时，就用这个逻辑做了重试，成功率提高了不少。</p>\n<h3 id=\"6-4-超时控制（防止请求卡太久）\"><a href=\"#6-4-超时控制（防止请求卡太久）\" class=\"headerlink\" title=\"6.4 超时控制（防止请求卡太久）\"></a>6.4 超时控制（防止请求卡太久）</h3><p>结合<code>Promise.race()</code>实现超时控制：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchWithTimeout</span>(<span class=\"params\">url, timeout = <span class=\"number\">5000</span></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchPromise = <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">  <span class=\"comment\">// 超时Promise</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> timeoutPromise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">_, reject</span>) =&gt;</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">reject</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">'请求超时'</span>)), timeout),</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 谁先完成就用谁的结果</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">race</span>([fetchPromise, timeoutPromise]);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这个在做支付回调的时候特别有用，防止因为网络问题让用户一直等。</p>\n<h2 id=\"七、踩过的坑：这些细节要注意\"><a href=\"#七、踩过的坑：这些细节要注意\" class=\"headerlink\" title=\"七、踩过的坑：这些细节要注意\"></a>七、踩过的坑：这些细节要注意</h2><h3 id=\"7-1-箭头函数的-this-陷阱\"><a href=\"#7-1-箭头函数的-this-陷阱\" class=\"headerlink\" title=\"7.1 箭头函数的 this 陷阱\"></a>7.1 箭头函数的 this 陷阱</h3><p>用 Async 箭头函数当对象方法时，<code>this</code>会丢：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 有问题：this指向不对</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">  <span class=\"attr\">print</span>: <span class=\"title function_\">async</span> () =&gt; {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>); <span class=\"comment\">// undefined! 因为箭头函数的this是定义时的上下文</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确写法：用传统函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">42</span>,</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"title function_\">print</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">value</span>); <span class=\"comment\">// 42，this指向obj</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在写一个类的方法时犯过这个错，调试了半天才发现是箭头函数的锅。</p>\n<h3 id=\"7-2-控制并发数量\"><a href=\"#7-2-控制并发数量\" class=\"headerlink\" title=\"7.2 控制并发数量\"></a>7.2 控制并发数量</h3><p>如果并行请求太多（比如一次发 20 个接口），可能会触发浏览器的并发限制，这时候需要控制并发数：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">processBatch</span>(<span class=\"params\">items</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promises = items.<span class=\"title function_\">map</span>(processItem); <span class=\"comment\">// 所有任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 控制最多同时跑5个</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> results = <span class=\"keyword\">await</span> <span class=\"title function_\">throttlePromises</span>(promises, <span class=\"number\">5</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这里的<code>throttlePromises</code>是一个工具函数，原理是把任务分成多批，一批批执行（每批 5 个），避免一次性发起太多请求。</p>\n<h3 id=\"7-3-可取消的异步任务（结合-AbortSignal）\"><a href=\"#7-3-可取消的异步任务（结合-AbortSignal）\" class=\"headerlink\" title=\"7.3 可取消的异步任务（结合 AbortSignal）\"></a>7.3 可取消的异步任务（结合 AbortSignal）</h3><p>有时候需要中途取消异步操作（比如用户离开页面），可以用<code>AbortSignal</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">longRunningTask</span>(<span class=\"params\">abortSignal</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (!abortSignal.<span class=\"property\">aborted</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">doWork</span>();<span class=\"comment\">// 每次做一点工作</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每次循环检查退出信号</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (abortSignal.<span class=\"property\">aborted</span>) {</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"title function_\">cleanup</span>(); <span class=\"comment\">// 做清理工作</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> controller = <span class=\"keyword\">new</span> <span class=\"title class_\">AbortController</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> signal = controller.<span class=\"property\">signal</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动长时间运行的任务</span></span><br><span class=\"line\"><span class=\"title function_\">longRunningTask</span>(signal);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> cancelTask {</span><br><span class=\"line\">  controller.<span class=\"title function_\">abort</span>(); <span class=\"comment\">// 中止任务</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置一个定时器，以便在 3 秒后中止任务</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  <span class=\"title function_\">cancelTask</span>();</span><br><span class=\"line\">}, <span class=\"number\">3000</span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我在做一个文件上传组件时用过这个，用户点取消按钮时，就通过<code>AbortSignal</code>终止上传。</p>\n<h2 id=\"八、常见问题解答（我当初学的时候也纠结过）\"><a href=\"#八、常见问题解答（我当初学的时候也纠结过）\" class=\"headerlink\" title=\"八、常见问题解答（我当初学的时候也纠结过）\"></a>八、常见问题解答（我当初学的时候也纠结过）</h2><h3 id=\"Q1-Async-函数会阻塞主线程吗？\"><a href=\"#Q1-Async-函数会阻塞主线程吗？\" class=\"headerlink\" title=\"Q1: Async 函数会阻塞主线程吗？\"></a>Q1: Async 函数会阻塞主线程吗？</h3><p><strong>不会！</strong> Async 函数遇到 await 时会<strong>暂停并释放主线程</strong>，JavaScript 的单线程模型通过事件循环实现异步执行。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'开始'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">delay</span>(<span class=\"number\">1000</span>); <span class=\"comment\">// 假设delay是个等待1秒的Promise</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'结束'</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>执行到 await 时，函数会暂停，主线程可以去处理其他任务（比如点击事件、渲染），等 1 秒后才回头执行 console.log(‘结束’)，所以不会卡页面。</p>\n<h3 id=\"Q2-可以-await-一个非-Promise-值吗？\"><a href=\"#Q2-可以-await-一个非-Promise-值吗？\" class=\"headerlink\" title=\"Q2: 可以 await 一个非 Promise 值吗？\"></a>Q2: 可以 await 一个非 Promise 值吗？</h3><p><strong>可以！</strong> 引擎会自动用 <code>Promise.resolve()</code> 包装非 Promise 值：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getNumber</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> num = <span class=\"keyword\">await</span> <span class=\"number\">42</span>; <span class=\"comment\">// 合法！等价于 await Promise.resolve(42)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>不过实际开发中很少这么用，一般 await 后面都是异步操作返回的 Promise。</p>\n<h3 id=\"Q3-为什么-Async-函数不管-return-什么，最后都返回-Promise？\"><a href=\"#Q3-为什么-Async-函数不管-return-什么，最后都返回-Promise？\" class=\"headerlink\" title=\"Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？\"></a>Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？</h3><p>因为它本质是异步操作的包装器。哪怕你 return 一个原始值，引擎也会用 Promise.resolve() 包一层：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">answer</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">42</span>; <span class=\"comment\">// 等价于 return Promise.resolve(42)</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>所以调用 Async 函数时，必须用<code>await</code>或者<code>.then()</code>才能拿到结果。</p>\n<h3 id=\"Q4-用-Promise-all-的时候，如果有一个请求失败怎么办？\"><a href=\"#Q4-用-Promise-all-的时候，如果有一个请求失败怎么办？\" class=\"headerlink\" title=\"Q4: 用 Promise.all()的时候，如果有一个请求失败怎么办？\"></a>Q4: 用 Promise.all() 的时候，如果有一个请求失败怎么办？</h3><p>之前已经提到过了，Promise.all() 会 “快速失败”—— 只要有一个 Promise 被拒绝，整个 Promise.all() 就会立刻失败，进入 catch。如果需要等所有请求完成（不管成功失败），可以用<code>Promise.allSettled()</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchAll</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> results = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">allSettled</span>([<span class=\"title function_\">fetchA</span>(), <span class=\"title function_\">fetchB</span>()]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 过滤出成功的结果</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> successData = results.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> r.<span class=\"property\">status</span> === <span class=\"string\">'fulfilled'</span>).<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> r.<span class=\"property\">value</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Q5-为什么说-Async-Await-比回调好？\"><a href=\"#Q5-为什么说-Async-Await-比回调好？\" class=\"headerlink\" title=\"Q5: 为什么说 Async/Await 比回调好？\"></a>Q5: 为什么说 Async / Await 比回调好？</h3><p>我总结了几个实际开发中的感受：</p>\n<ul>\n<li>代码不嵌套，扁平结构更易读（告别 “回调地狱”）</li>\n<li>错误处理统一用 try / catch，不用每层回调都写 error 处理</li>\n<li>逻辑顺序和代码执行顺序一致，不用跳来跳去看代码</li>\n<li>调试更方便，错误堆栈更完整（回调的堆栈经常被异步操作打断）</li>\n</ul>\n<hr>\n<p>其实 Async/Await 不算什么高深的技术，就是把 Generator、Promise 这些老东西包装得更好用了。但正是这种 “语法糖”，让我们写异步代码时能少掉很多头发～ 如果你也有过用 Async/Await 踩坑的经历，欢迎在评论区分享呀！</p>\n",
            "tags": [
                "JavaScript",
                "性能优化",
                "ES2017(ES8)"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/message-channel/",
            "url": "http://toukoxu.github.io/archives/message-channel/",
            "title": "MessageChannel 详解：浏览器中的 “点对点双向通信管道”",
            "date_published": "2024-06-23T12:46:25.000Z",
            "content_html": "<blockquote>\n<p><code>MessageChannel</code> 是浏览器提供的<strong>点对点双向通信 API</strong>，核心是创建一对关联的 “通信端口”（<code>port1</code> 和 <code>port2</code>），让不同上下文（比如主线程与 Worker、父页面与 iframe）能安全、高效地传递消息。它不像全局事件那样容易污染，也比普通 <code>postMessage</code> 更专注于 “一对一” 通信场景。</p>\n</blockquote>\n<h2 id=\"一、核心概念：从创建到通信的基本流程\"><a href=\"#一、核心概念：从创建到通信的基本流程\" class=\"headerlink\" title=\"一、核心概念：从创建到通信的基本流程\"></a>一、核心概念：从创建到通信的基本流程</h2><p><code>MessageChannel</code> 的用法很直观：先创建通道，拿到两个端口，再通过端口的 <code>postMessage</code> 发消息、<code>onmessage</code> 收消息，形成双向通信链路。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建一个 MessageChannel 实例（相当于建立一条通信管道）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> channel = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageChannel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 从管道中获取两个相互关联的端口（port1 和 port2 是“一对”）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> port1 = channel.<span class=\"property\">port1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> port2 = channel.<span class=\"property\">port2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 端口1 发送消息（可传字符串、对象等结构化数据）</span></span><br><span class=\"line\">port1.<span class=\"title function_\">postMessage</span>(<span class=\"string\">'你好，我是 port1！'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 端口2 监听并接收消息</span></span><br><span class=\"line\">port2.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'port2 收到消息：'</span>, event.<span class=\"property\">data</span>); <span class=\"comment\">// 输出“你好，我是 port1！”</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5. 端口2 也能回复消息（双向通信）</span></span><br><span class=\"line\">  port2.<span class=\"title function_\">postMessage</span>(<span class=\"string\">'收到啦，port1！'</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 6. 端口1 接收端口2 的回复</span></span><br><span class=\"line\">port1.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'port1 收到回复：'</span>, event.<span class=\"property\">data</span>); <span class=\"comment\">// 输出“收到啦，port1！”</span></span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这里有个关键逻辑：<code>port1</code> 发的消息只有 <code>port2</code> 能收，<code>port2</code> 发的消息也只有 <code>port1</code> 能收 —— 它们是 “点对点绑定” 的，不会被其他上下文干扰。</p>\n<h2 id=\"二、MessageChannel-的核心特性\"><a href=\"#二、MessageChannel-的核心特性\" class=\"headerlink\" title=\"二、MessageChannel 的核心特性\"></a>二、MessageChannel 的核心特性</h2><ol>\n<li><strong>双向平等通信</strong>：<code>port1</code> 和 <code>port2</code> 没有 “主从” 之分，双方都能主动发消息、收消息，通信是双向的。</li>\n<li><strong>独立消息队列</strong>：每个端口都有自己的消息队列，消息按发送顺序处理，不会出现 “插队” 或混乱。</li>\n<li><strong>同源安全限制</strong>：和 <code>postMessage</code> 一样，默认遵循同源策略（协议、域名、端口一致），跨域通信需要额外配置（如 <code>postMessage</code> 的目标 Origin）。</li>\n<li><strong>支持 “可转移对象”</strong>：能传递 <code>ArrayBuffer</code>、<code>MessagePort</code> 这类特殊对象，转移后原上下文会失去对对象的控制权（避免数据拷贝，提升性能）。</li>\n<li><strong>低延迟任务调度</strong>：比 <code>setTimeout(fn, 0)</code> 更高效 ——<code>MessageChannel</code> 的消息回调会进入 “微任务队列”，执行时机更早，延迟更低。</li>\n</ol>\n<h2 id=\"三、实战场景：这些地方用-MessageChannel-更合适\"><a href=\"#三、实战场景：这些地方用-MessageChannel-更合适\" class=\"headerlink\" title=\"三、实战场景：这些地方用 MessageChannel 更合适\"></a>三、实战场景：这些地方用 MessageChannel 更合适</h2><h3 id=\"3-1-主线程与-Web-Worker-的“专用通信”\"><a href=\"#3-1-主线程与-Web-Worker-的“专用通信”\" class=\"headerlink\" title=\"3.1 主线程与 Web Worker 的“专用通信”\"></a>3.1 主线程与 Web Worker 的 “专用通信”</h3><p>Web Worker 是主线程之外的独立线程，两者通信常用 <code>postMessage</code>，但如果需要 “长期、专用” 的通信链路（比如频繁传递大数据），<code>MessageChannel</code> 更合适 —— 避免和其他消息混在一起。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程代码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(<span class=\"string\">'worker.js'</span>); <span class=\"comment\">// 新建 Worker</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> channel = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageChannel</span>(); <span class=\"comment\">// 创建通信管道</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把 port2 传给 Worker（通过 postMessage 的“转移列表”，确保端口唯一）</span></span><br><span class=\"line\">worker.<span class=\"title function_\">postMessage</span>(<span class=\"string\">'初始化通信端口'</span>, [channel.<span class=\"property\">port2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主线程通过 port1 与 Worker 通信</span></span><br><span class=\"line\">channel.<span class=\"property\">port1</span>.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'主线程收到 Worker 消息：'</span>, event.<span class=\"property\">data</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主线程给 Worker 发消息</span></span><br><span class=\"line\">channel.<span class=\"property\">port1</span>.<span class=\"title function_\">postMessage</span>({ <span class=\"attr\">type</span>: <span class=\"string\">'FETCH_DATA'</span>, <span class=\"attr\">url</span>: <span class=\"string\">'/api/data'</span> });</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// worker.js（Worker 线程代码）</span></span><br><span class=\"line\">self.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"comment\">// 接收主线程传来的 port2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.<span class=\"property\">data</span> === <span class=\"string\">'初始化通信端口'</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> port = event.<span class=\"property\">ports</span>[<span class=\"number\">0</span>]; <span class=\"comment\">// 拿到 port2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Worker 通过 port 接收主线程消息</span></span><br><span class=\"line\">    port.<span class=\"property\">onmessage</span> = <span class=\"title function_\">async</span> (e) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (e.<span class=\"property\">data</span>.<span class=\"property\">type</span> === <span class=\"string\">'FETCH_DATA'</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 模拟请求数据</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(e.<span class=\"property\">data</span>.<span class=\"property\">url</span>);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> res.<span class=\"title function_\">json</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把数据发回主线程</span></span><br><span class=\"line\">        port.<span class=\"title function_\">postMessage</span>({ <span class=\"attr\">type</span>: <span class=\"string\">'DATA_SUCCESS'</span>, data });</span><br><span class=\"line\">      }</span><br><span class=\"line\">    };</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这种方式的好处是：主线程与 Worker 的通信被 “隔离” 在这对端口中，不会和其他 <code>worker.postMessage</code> 消息混淆。</p>\n<h3 id=\"3-2-父页面与-iframe-的跨上下文通信\"><a href=\"#3-2-父页面与-iframe-的跨上下文通信\" class=\"headerlink\" title=\"3.2 父页面与 iframe 的跨上下文通信\"></a>3.2 父页面与 iframe 的跨上下文通信</h3><p>如果页面里有 iframe，且需要和 iframe 进行 “一对一” 通信（比如父子页面传递表单数据），<code>MessageChannel</code> 比直接用 <code>iframe.contentWindow.postMessage</code> 更安全（避免消息被其他 iframe 监听）。</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 父页面代码 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">id</span>=<span class=\"string\">\"childIframe\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"child.html\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">const</span> iframe = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'childIframe'</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">const</span> channel = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageChannel</span>();</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"comment\">// 等 iframe 加载完成后，传递 port2 给子页面</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  iframe.<span class=\"property\">onload</span> = <span class=\"function\">() =&gt;</span> {</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 第三个参数是“转移列表”，把 port2 的控制权转给 iframe</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">    iframe.<span class=\"property\">contentWindow</span>.<span class=\"title function_\">postMessage</span>(<span class=\"string\">'绑定通信端口'</span>, <span class=\"string\">'*'</span>, [channel.<span class=\"property\">port2</span>]);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  };</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"comment\">// 父页面通过 port1 接收 iframe 消息</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  channel.<span class=\"property\">port1</span>.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'父页面收到 iframe 消息：'</span>, event.<span class=\"property\">data</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"comment\">// 比如收到 iframe 传来的表单数据，做后续处理</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  };</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"comment\">// 父页面给 iframe 发消息（比如传递配置）</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  channel.<span class=\"property\">port1</span>.<span class=\"title function_\">postMessage</span>({ <span class=\"attr\">theme</span>: <span class=\"string\">'dark'</span>, <span class=\"attr\">userId</span>: <span class=\"number\">123</span> });</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- child.html（iframe 子页面代码） --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"comment\">// 监听父页面传来的“绑定端口”消息</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'message'</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">if</span> (event.<span class=\"property\">data</span> === <span class=\"string\">'绑定通信端口'</span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"keyword\">const</span> port = event.<span class=\"property\">ports</span>[<span class=\"number\">0</span>]; <span class=\"comment\">// 拿到父页面传来的 port2</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"comment\">// 子页面给父页面发消息（比如传递表单数据）</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">      port.<span class=\"title function_\">postMessage</span>({</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"attr\">formData</span>: { <span class=\"attr\">username</span>: <span class=\"string\">'test'</span>, <span class=\"attr\">email</span>: <span class=\"string\">'test@xxx.com'</span> },</span></span><br><span class=\"line\"><span class=\"language-javascript\">      });</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"comment\">// 子页面接收父页面的消息（比如配置）</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">      port.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> {</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'iframe 收到父页面配置：'</span>, e.<span class=\"property\">data</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"comment\">// 根据配置设置页面主题等</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">      };</span></span><br><span class=\"line\"><span class=\"language-javascript\">    }</span></span><br><span class=\"line\"><span class=\"language-javascript\">  });</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-3-非父子组件通信（以-React-为例）\"><a href=\"#3-3-非父子组件通信（以-React-为例）\" class=\"headerlink\" title=\"3.3 非父子组件通信（以 React 为例）\"></a>3.3 非父子组件通信（以 React 为例）</h3><p>在 React、Vue 等框架中，如果两个组件没有直接的父子关系（比如兄弟组件、跨层级组件），用 <code>MessageChannel</code> 可以实现 “无侵入” 的通信，不用依赖全局状态（如 Redux）或事件总线。</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 先创建一个全局的 MessageChannel（可放在单独的工具文件中）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> componentChannel = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageChannel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 组件 A（发送消息的一方）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">ComponentA</span> = (<span class=\"params\"></span>) =&gt; {</span><br><span class=\"line\">  <span class=\"comment\">// 点击按钮时给 ComponentB 发消息</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">sendMessage</span> = (<span class=\"params\"></span>) =&gt; {</span><br><span class=\"line\">    componentChannel.<span class=\"property\">port2</span>.<span class=\"title function_\">postMessage</span>({</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"string\">'UPDATE_COUNT'</span>,</span><br><span class=\"line\">      <span class=\"attr\">count</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">    });</span><br><span class=\"line\">  };</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{sendMessage}</span>&gt;</span>给 ComponentB 发消息<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 组件 B（接收消息的一方）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">ComponentB</span> = (<span class=\"params\"></span>) =&gt; {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title class_\">React</span>.<span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 组件挂载时，监听 port1 的消息</span></span><br><span class=\"line\">  <span class=\"title class_\">React</span>.<span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">handleMessage</span> = (<span class=\"params\">event</span>) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (event.<span class=\"property\">data</span>.<span class=\"property\">type</span> === <span class=\"string\">'UPDATE_COUNT'</span>) {</span><br><span class=\"line\">        <span class=\"title function_\">setCount</span>(event.<span class=\"property\">data</span>.<span class=\"property\">count</span>); <span class=\"comment\">// 更新组件状态</span></span><br><span class=\"line\">      }</span><br><span class=\"line\">    };</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 绑定消息监听</span></span><br><span class=\"line\">    componentChannel.<span class=\"property\">port1</span>.<span class=\"property\">onmessage</span> = handleMessage;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 组件卸载时，关闭端口（避免内存泄漏）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      componentChannel.<span class=\"property\">port1</span>.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">    };</span><br><span class=\"line\">  }, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>从 ComponentA 收到的 count：{count}<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这种方式的好处是：组件间通信不依赖框架 API，逻辑更独立，也不会污染全局事件。</p>\n<h3 id=\"3-4-性能优化：替代-setTimeout-的“微任务调度”\"><a href=\"#3-4-性能优化：替代-setTimeout-的“微任务调度”\" class=\"headerlink\" title=\"3.4 性能优化：替代 setTimeout 的“微任务调度”\"></a>3.4 性能优化：替代 setTimeout 的 “微任务调度”</h3><p><code>setTimeout(fn, 0)</code> 会把任务推到 “宏任务队列”，延迟较高（通常 4ms 以上）；而 <code>MessageChannel</code> 的消息回调会进入 “微任务队列”，执行时机更早，适合需要 “尽快执行但不阻塞当前同步代码” 的场景（比如 DOM 更新后执行回调）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用 MessageChannel 实现“微任务调度”</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">scheduleMicroTask</span>(<span class=\"params\">task</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> { port1, port2 } = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageChannel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// port1 收到消息后执行任务</span></span><br><span class=\"line\">  port1.<span class=\"property\">onmessage</span> = <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"title function_\">task</span>();</span><br><span class=\"line\">    port1.<span class=\"title function_\">close</span>(); <span class=\"comment\">// 执行完关闭端口，避免内存泄漏</span></span><br><span class=\"line\">  };</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 发送一条空消息，触发 port1 的回调</span></span><br><span class=\"line\">  port2.<span class=\"title function_\">postMessage</span>(<span class=\"string\">'run'</span>);</span><br><span class=\"line\">  port2.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用示例：</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'同步代码开始'</span>);</span><br><span class=\"line\"><span class=\"title function_\">scheduleMicroTask</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'微任务执行（MessageChannel）'</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'宏任务执行（setTimeout）'</span>);</span><br><span class=\"line\">}, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'同步代码结束'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行顺序：</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 同步代码开始</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 同步代码结束</span></span><br><span class=\"line\"><span class=\"comment\">// 3. 微任务执行（MessageChannel）</span></span><br><span class=\"line\"><span class=\"comment\">// 4. 宏任务执行（setTimeout）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-5-主线程与-Service-Worker-的双向通信\"><a href=\"#3-5-主线程与-Service-Worker-的双向通信\" class=\"headerlink\" title=\"3.5 主线程与 Service Worker 的双向通信\"></a>3.5 主线程与 Service Worker 的双向通信</h3><p>Service Worker 负责离线缓存、后台同步等功能，主线程与它通信时，<code>MessageChannel</code> 可以建立 “长期专用链路”，避免消息混淆（比如同时处理缓存更新和推送通知）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程代码（页面中）</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator) {</span><br><span class=\"line\">  navigator.<span class=\"property\">serviceWorker</span>.<span class=\"title function_\">register</span>(<span class=\"string\">'/sw.js'</span>).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">registration</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 注册成功后，创建 MessageChannel</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> channel = <span class=\"keyword\">new</span> <span class=\"title class_\">MessageChannel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 把 port2 传给 Service Worker</span></span><br><span class=\"line\">    registration.<span class=\"property\">active</span>.<span class=\"title function_\">postMessage</span>(<span class=\"string\">'绑定 SW 通信端口'</span>, [channel.<span class=\"property\">port2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 主线程通过 port1 接收 SW 消息（比如缓存更新结果）</span></span><br><span class=\"line\">    channel.<span class=\"property\">port1</span>.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'主线程收到 SW 消息：'</span>, event.<span class=\"property\">data</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (event.<span class=\"property\">data</span>.<span class=\"property\">type</span> === <span class=\"string\">'CACHE_UPDATED'</span>) {</span><br><span class=\"line\">        <span class=\"title function_\">alert</span>(<span class=\"string\">'缓存已更新，下次访问更快速！'</span>);</span><br><span class=\"line\">      }</span><br><span class=\"line\">    };</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 主线程给 SW 发消息（比如触发缓存更新）</span></span><br><span class=\"line\">    channel.<span class=\"property\">port1</span>.<span class=\"title function_\">postMessage</span>({</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"string\">'UPDATE_CACHE'</span>,</span><br><span class=\"line\">      <span class=\"attr\">urls</span>: [<span class=\"string\">'/index.html'</span>, <span class=\"string\">'/style.css'</span>],</span><br><span class=\"line\">    });</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// sw.js（Service Worker 代码）</span></span><br><span class=\"line\">self.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'message'</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.<span class=\"property\">data</span> === <span class=\"string\">'绑定 SW 通信端口'</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> port = event.<span class=\"property\">ports</span>[<span class=\"number\">0</span>]; <span class=\"comment\">// 拿到主线程传来的 port2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// SW 接收主线程消息（比如处理缓存更新）</span></span><br><span class=\"line\">    port.<span class=\"property\">onmessage</span> = <span class=\"title function_\">async</span> (e) =&gt; {</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (e.<span class=\"property\">data</span>.<span class=\"property\">type</span> === <span class=\"string\">'UPDATE_CACHE'</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">          <span class=\"comment\">// 模拟更新缓存</span></span><br><span class=\"line\">          <span class=\"keyword\">const</span> cache = <span class=\"keyword\">await</span> caches.<span class=\"title function_\">open</span>(<span class=\"string\">'v2'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">await</span> cache.<span class=\"title function_\">addAll</span>(e.<span class=\"property\">data</span>.<span class=\"property\">urls</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// 给主线程回复“缓存更新成功”</span></span><br><span class=\"line\">          port.<span class=\"title function_\">postMessage</span>({ <span class=\"attr\">type</span>: <span class=\"string\">'CACHE_UPDATED'</span>, <span class=\"attr\">success</span>: <span class=\"literal\">true</span> });</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (err) {</span><br><span class=\"line\">          port.<span class=\"title function_\">postMessage</span>({ <span class=\"attr\">type</span>: <span class=\"string\">'CACHE_ERROR'</span>, <span class=\"attr\">error</span>: err.<span class=\"property\">message</span> });</span><br><span class=\"line\">        }</span><br><span class=\"line\">      }</span><br><span class=\"line\">    };</span><br><span class=\"line\">  }</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"四、关键注意事项：避坑指南\"><a href=\"#四、关键注意事项：避坑指南\" class=\"headerlink\" title=\"四、关键注意事项：避坑指南\"></a>四、关键注意事项：避坑指南</h2><ol>\n<li><p><strong>使用后必须关闭端口，避免内存泄漏</strong><br>端口如果不手动关闭，会一直占用内存（尤其是在组件卸载、Worker 终止时）。关闭端口用 <code>port.close()</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件卸载或通信结束时关闭端口</span></span><br><span class=\"line\">port1.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">port2.<span class=\"title function_\">close</span>();</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p><strong>消息传递遵循 “结构化克隆算法”</strong><br>能传递的对象包括：字符串、数字、数组、普通对象、<code>Map</code>、<code>Set</code>、<code>ArrayBuffer</code>、<code>Blob</code> 等，但<strong>不能传递函数、DOM 元素、循环引用对象</strong>。如果传递不支持的类型，会触发 <code>onmessageerror</code>。</p>\n</li>\n<li><p><strong>必须监听错误事件（onmessageerror）</strong><br>当消息无法解析（比如传递了不支持的类型）时，会触发 <code>onmessageerror</code>，不监听会导致控制台报错：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port1.<span class=\"property\">onmessageerror</span> = <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">'消息解析失败：'</span>, event.<span class=\"property\">error</span>);</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p><strong>端口只能 “转移”，不能 “复制”</strong><br>把端口通过 <code>postMessage</code> 传递给其他上下文时，必须放在 “转移列表”（第三个参数）中 —— 转移后，原上下文的端口会失效，只能在目标上下文使用（确保端口唯一，避免通信混乱）。</p>\n</li>\n</ol>\n<h2 id=\"五、对比其他通信方式：该选哪一个？\"><a href=\"#五、对比其他通信方式：该选哪一个？\" class=\"headerlink\" title=\"五、对比其他通信方式：该选哪一个？\"></a>五、对比其他通信方式：该选哪一个？</h2><table>\n<thead>\n<tr>\n<th>通信方式</th>\n<th>适用场景</th>\n<th>核心特点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MessageChannel</code></td>\n<td>点对点精确通信（如主线程 - Worker、父 - iframe）</td>\n<td>双向、低延迟、专用链路、可转移对象</td>\n<td>只支持 “一对一”，不适合广播</td>\n</tr>\n<tr>\n<td>普通 <code>postMessage</code></td>\n<td>简单的跨窗口通信（如父 - iframe 单次消息）</td>\n<td>无需创建通道，用法简单</td>\n<td>需持有目标上下文引用，易混淆</td>\n</tr>\n<tr>\n<td><code>BroadcastChannel</code></td>\n<td>同源所有上下文广播（如多标签页同步状态）</td>\n<td>一对多、无需目标引用</td>\n<td>不支持可转移对象，跨域受限</td>\n</tr>\n<tr>\n<td><code>SharedWorker</code></td>\n<td>多标签页共享数据 / 计算（如共享缓存）</td>\n<td>持久化连接，多上下文共享</td>\n<td>实现复杂，浏览器兼容性稍差</td>\n</tr>\n<tr>\n<td><code>CustomEvent</code></td>\n<td>同文档内组件通信（如父子组件）</td>\n<td>同步执行，易集成</td>\n<td>受事件冒泡影响，无法跨上下文</td>\n</tr>\n</tbody></table>\n<p>简单总结：</p>\n<ul>\n<li>若需要 “一对一、低延迟、长期通信” → 选 <code>MessageChannel</code>；</li>\n<li>若需要 “一对多广播” → 选 <code>BroadcastChannel</code>；</li>\n<li>若只是 “同文档内简单通信” → 选 <code>CustomEvent</code>；</li>\n<li>若需要 “多标签页共享计算” → 选 <code>SharedWorker</code>。</li>\n</ul>\n<hr>\n<p><code>MessageChannel</code> 虽然不是日常开发中 “天天用” 的 API，但在处理 “跨上下文专用通信” 和 “高性能任务调度” 时，它是比其他方案更优雅、更高效的选择。掌握它，能让你在面对复杂通信场景时多一种可靠的解决方案～</p>\n",
            "tags": [
                "JavaScript",
                "性能优化"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/event/",
            "url": "http://toukoxu.github.io/archives/event/",
            "title": "JS 事件系统完全指南与性能优化",
            "date_published": "2022-02-01T12:46:25.000Z",
            "content_html": "<blockquote>\n<p>在 JavaScript 的世界里，事件就像网页的 “交互信号”—— 用户点击按钮、滚动页面、输入文字，都是通过事件让网页做出反应。今天我们从基础到进阶，把浏览器事件机制拆解开，再聊聊怎么用得更高效，避免常见的性能坑！</p>\n</blockquote>\n<h2 id=\"一、事件系统：网页的“交互逻辑骨架”\"><a href=\"#一、事件系统：网页的“交互逻辑骨架”\" class=\"headerlink\" title=\"一、事件系统：网页的“交互逻辑骨架”\"></a>一、事件系统：网页的 “交互逻辑骨架”</h2><h3 id=\"1-1-事件流三阶段：从顶层到目标，再回到顶层\"><a href=\"#1-1-事件流三阶段：从顶层到目标，再回到顶层\" class=\"headerlink\" title=\"1.1 事件流三阶段：从顶层到目标，再回到顶层\"></a>1.1 事件流三阶段：从顶层到目标，再回到顶层</h3><p>事件触发后，不是直接定位到目标元素，而是会经历 “捕获 → 目标 → 冒泡” 三个阶段，就像水流先向下流到目标，再向上回流：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  graph LR\nA[捕获阶段] --&gt; B[目标阶段] --&gt; C[冒泡阶段]\nstyle A fill:#4CAF50,stroke:#388E3C\nstyle B fill:#2196F3,stroke:#1976D2\nstyle C fill:#FF9800,stroke:#F57C00\n  </pre></div>\n\n<ul>\n<li><strong>捕获阶段 (Capture Phase)</strong>：事件从 <code>window</code> 开始，顺着 DOM 树向下传递，直到目标元素的父级（比如点击按钮时，先经过 <code>body</code>、<code>div</code>，再到按钮的父元素）</li>\n<li><strong>目标阶段 (Target Phase)</strong>：事件终于到达触发的目标元素（比如刚才的按钮）</li>\n<li><strong>冒泡阶段 (Bubble Phase)</strong>：事件从目标元素开始，顺着 DOM 树向上 “回流”，回到 <code>window</code>（按钮 → 父 <code>div</code>→<code>body</code>→<code>window</code>）</li>\n</ul>\n<h3 id=\"1-2-三种事件监听方式：哪种最实用？\"><a href=\"#1-2-三种事件监听方式：哪种最实用？\" class=\"headerlink\" title=\"1.2 三种事件监听方式：哪种最实用？\"></a>1.2 三种事件监听方式：哪种最实用？</h3><p>日常开发中，绑定事件主要有三种方式，各有优劣，我整理成了表格：</p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>示例</th>\n<th>👍 优点</th>\n<th>👎 缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>HTML 属性绑定</strong></td>\n<td><code>&lt;button onclick=\"handleClick()\"&gt;</code></td>\n<td>写起来快，适合简单 demo</td>\n<td>HTML 和 JS 混在一起，代码难维护；无法绑定多个处理函数</td>\n</tr>\n<tr>\n<td><strong>DOM 属性绑定</strong></td>\n<td><code>btn.onclick = handleClick</code></td>\n<td>比 HTML 属性清晰，不用混写</td>\n<td>一个事件只能绑一个函数，后面的会覆盖前面的</td>\n</tr>\n<tr>\n<td><strong><code>addEventListener</code></strong></td>\n<td><code>btn.addEventListener('click', handleClick)</code></td>\n<td>🏆 推荐！支持绑多个函数；能控制事件阶段；可手动移除</td>\n<td>需要手动解绑，否则可能内存泄漏</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>实际开发里，我几乎只用 <code>addEventListener</code>—— 它的灵活性和控制力是另外两种方式比不了的，尤其是复杂项目里，多监听器、阶段控制这些功能很关键。</p>\n</blockquote>\n<h3 id=\"1-3-addEventListener详解：参数怎么用？\"><a href=\"#1-3-addEventListener详解：参数怎么用？\" class=\"headerlink\" title=\"1.3 addEventListener详解：参数怎么用？\"></a>1.3 <code>addEventListener</code>详解：参数怎么用？</h3><h4 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h4><p>它有三种调用形式，核心是控制事件的触发规则：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 基础版：事件类型 + 处理函数</span></span><br><span class=\"line\"><span class=\"title function_\">addEventListener</span>(type, listener);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 旧版阶段控制：加个布尔值控制捕获/冒泡</span></span><br><span class=\"line\"><span class=\"title function_\">addEventListener</span>(type, listener, useCapture);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 新版选项控制：更灵活的配置（推荐）</span></span><br><span class=\"line\"><span class=\"title function_\">addEventListener</span>(type, listener, options);</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"关键参数说明\"><a href=\"#关键参数说明\" class=\"headerlink\" title=\"关键参数说明\"></a>关键参数说明</h4><ul>\n<li><p><strong><code>useCapture</code>（布尔值，旧版）</strong>：<br>控制事件在哪个阶段触发。<code>true</code> 是捕获阶段，<code>false</code>（默认）是冒泡阶段，和新版 <code>options.capture</code> 功能完全一样。</p>\n</li>\n<li><p><strong><code>options</code>（对象，新版）</strong>：<br>能精细控制事件行为，常用选项如下：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>类型</th>\n<th>默认值</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>capture</code></td>\n<td>Boolean</td>\n<td><code>false</code></td>\n<td>决定事件在哪个阶段触发：<code>false</code>（冒泡阶段）、<code>true</code>（捕获阶段）</td>\n</tr>\n<tr>\n<td><code>once</code></td>\n<td>Boolean</td>\n<td><code>false</code></td>\n<td><code>true</code> 时，函数只执行一次，执行完自动解绑（比如 “点击后失效” 的按钮）</td>\n</tr>\n<tr>\n<td><code>passive</code></td>\n<td>Boolean</td>\n<td><code>false</code></td>\n<td><code>true</code> 时，告诉浏览器 “这个函数不会调用 <code>preventDefault()</code>”，能提升滚动、触摸等高频事件的性能</td>\n</tr>\n<tr>\n<td><code>signal</code></td>\n<td>AbortSignal</td>\n<td>-</td>\n<td>配合 <code>AbortController</code> 使用，调用 <code>abort()</code> 就能批量解绑事件</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h2 id=\"二、常用事件类型：按场景分类整理\"><a href=\"#二、常用事件类型：按场景分类整理\" class=\"headerlink\" title=\"二、常用事件类型：按场景分类整理\"></a>二、常用事件类型：按场景分类整理</h2><p>浏览器事件类型非常多，我附上关键属性和用法，不用死记，需要时查就行。</p>\n<h3 id=\"先看事件的继承关系\"><a href=\"#先看事件的继承关系\" class=\"headerlink\" title=\"先看事件的继承关系\"></a>先看事件的继承关系</h3><p>所有事件都基于 <code>Event</code> 这个 “基类”，再衍生出不同场景的事件，比如鼠标事件、键盘事件等，关系如下：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  classDiagram\nclass Event {\n&lt;&lt;interface&gt;&gt;\n+type: string\n+bubbles: boolean\n+cancelable: boolean\n+target: EventTarget\n+currentTarget: EventTarget\n+eventPhase: number\n+timeStamp: DOMHighResTimeStamp\n+isTrusted: boolean\n+defaultPrevented: boolean\n+composed: boolean\n+preventDefault() void\n+stopPropagation() void\n+stopImmediatePropagation() void\n+composedPath() EventTarget[]\n}\n\nEvent &lt;|-- UIEvent\nEvent &lt;|-- AnimationEvent\nEvent &lt;|-- TransitionEvent\nEvent &lt;|-- ClipboardEvent\nEvent &lt;|-- CustomEvent\nEvent &lt;|-- ProgressEvent\nEvent &lt;|-- StorageEvent\nEvent &lt;|-- MessageEvent\nEvent &lt;|-- ToggleEvent\nEvent &lt;|-- SubmitEvent\n\nclass UIEvent {\n+view: WindowProxy\n+detail: number\n+sourceCapabilities: InputDeviceCapabilities\n}\n\nUIEvent &lt;|-- MouseEvent\nUIEvent &lt;|-- KeyboardEvent\nUIEvent &lt;|-- FocusEvent\nUIEvent &lt;|-- TouchEvent\nUIEvent &lt;|-- InputEvent\n\nclass MouseEvent {\n+screenX: number\n+screenY: number\n+clientX: number\n+clientY: number\n+pageX: number\n+pageY: number\n+offsetX: number\n+offsetY: number\n+button: number\n+buttons: number\n+relatedTarget: EventTarget\n+altKey: boolean\n+ctrlKey: boolean\n+shiftKey: boolean\n+metaKey: boolean\n+getModifierState(key: string) boolean\n}\n\nMouseEvent &lt;|-- PointerEvent\nMouseEvent &lt;|-- DragEvent\nMouseEvent &lt;|-- WheelEvent\n\nclass PointerEvent {\n+pointerId: number\n+width: number\n+height: number\n+pressure: number\n+tangentialPressure: number\n+tiltX: number\n+tiltY: number\n+twist: number\n+pointerType: string\n+isPrimary: boolean\n}\n\nclass WheelEvent {\n+deltaX: number\n+deltaY: number\n+deltaZ: number\n+deltaMode: number\n}\n\nclass KeyboardEvent {\n+key: string\n+code: string\n+location: number\n+repeat: boolean\n+isComposing: boolean\n+getModifierState(key: string) boolean\n}\n\nclass FocusEvent {\n+relatedTarget: EventTarget\n}\n\nclass TouchEvent {\n+touches: TouchList\n+targetTouches: TouchList\n+changedTouches: TouchList\n+altKey: boolean\n+ctrlKey: boolean\n+shiftKey: boolean\n+metaKey: boolean\n}\n\nclass AnimationEvent {\n+animationName: string\n+elapsedTime: number\n+pseudoElement: string\n}\n\nclass TransitionEvent {\n+propertyName: string\n+elapsedTime: number\n+pseudoElement: string\n}\n\nclass CustomEvent {\n+detail: any\n+initCustomEvent() void\n}\n\nclass InputEvent {\n+data: string\n+isComposing: boolean\n+inputType: string\n}\n\nclass ClipboardEvent {\n+clipboardData: DataTransfer\n}\n\nclass ProgressEvent {\n+lengthComputable: boolean\n+loaded: number\n+total: number\n}\n\nclass StorageEvent {\n+key: string\n+oldValue: any\n+newValue: any\n+url: string\n+storageArea: Storage\n}\n\nclass MessageEvent {\n+data: any\n+origin: string\n+lastEventId: string\n+source: WindowProxy\n+ports: MessagePort[]\n}\n\nclass ToggleEvent {\n+newState: string\n+oldState: string\n}\n\nclass DragEvent {\n+dataTransfer: DataTransfer\n}\n  </pre></div>\n\n<h3 id=\"1-Event（基础事件）\"><a href=\"#1-Event（基础事件）\" class=\"headerlink\" title=\"1. Event（基础事件）\"></a>1. Event（基础事件）</h3><p>所有事件的 “祖宗”，提供最基础的属性和方法，比如判断事件是否冒泡、阻止默认行为等。</p>\n<h4 id=\"常用属性\"><a href=\"#常用属性\" class=\"headerlink\" title=\"常用属性\"></a>常用属性</h4><ul>\n<li><code>type</code>：事件类型（如 “click”）</li>\n<li><code>target</code>：实际触发事件的元素（比如点击按钮，<code>target</code> 就是按钮）</li>\n<li><code>currentTarget</code>：始终为绑定事件的元素（比如给父容器绑事件，点击子元素时，<code>currentTarget</code> 是父容器）</li>\n<li><code>bubbles</code>：布尔值，判断事件是否会冒泡</li>\n<li><code>cancelable</code>：布尔值，判断事件能否用 <code>preventDefault()</code> 阻止默认行为</li>\n<li><code>eventPhase</code>：事件当前阶段（0 = NONE, 1 = CAPTURING, 2 = AT_TARGET, 3 = BUBBLING）</li>\n<li><code>timeStamp</code>：事件发生的时间戳</li>\n<li><code>isTrusted</code>：事件是否由用户触发（true）还是脚本创建（false）</li>\n<li><code>defaultPrevented</code>：是否已阻止默认行为</li>\n</ul>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><ul>\n<li><code>preventDefault()</code>：阻止默认行为（比如阻止表单提交、链接跳转），可以使用<code>Event.cancelable</code>来检查该事件是否支持取消</li>\n<li><code>stopPropagation()</code>：阻止事件继续冒泡或捕获（比如点击子元素后，父元素的事件不触发）</li>\n<li><code>stopImmediatePropagation()</code>：阻止其他监听器执行</li>\n</ul>\n<h4 id=\"高频基础事件\"><a href=\"#高频基础事件\" class=\"headerlink\" title=\"高频基础事件\"></a>高频基础事件</h4><table>\n<thead>\n<tr>\n<th>事件</th>\n<th>触发时机</th>\n<th>常用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DOMContentLoaded</code></td>\n<td>DOM 解析完成（不用等图片、CSS 加载）</td>\n<td>页面初始化逻辑（比如绑定事件、渲染列表）</td>\n</tr>\n<tr>\n<td><code>load</code></td>\n<td>整个页面（图片、CSS 等）加载完成</td>\n<td>处理图片相关逻辑（比如获取图片尺寸）</td>\n</tr>\n<tr>\n<td><code>scroll</code></td>\n<td>元素或页面滚动时</td>\n<td>滚动加载、导航栏吸顶</td>\n</tr>\n<tr>\n<td><code>resize</code></td>\n<td>窗口或元素大小改变时</td>\n<td>响应式布局调整（比如窗口缩小后重排内容）</td>\n</tr>\n<tr>\n<td><code>submit</code></td>\n<td>表单点击提交按钮或按回车时</td>\n<td>表单验证、阻止默认提交后用 AJAX 提交</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-UIEvent（用户界面事件）\"><a href=\"#2-UIEvent（用户界面事件）\" class=\"headerlink\" title=\"2. UIEvent（用户界面事件）\"></a>2. UIEvent（用户界面事件）</h3><p>继承自<strong> Event</strong>，处理与浏览器 UI 相关的事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>view</code>：关联的窗口对象</li>\n<li><code>detail</code>：事件详情（如点击次数）</li>\n</ul>\n<h4 id=\"2-1-MouseEvent（鼠标事件）\"><a href=\"#2-1-MouseEvent（鼠标事件）\" class=\"headerlink\" title=\"2.1 MouseEvent（鼠标事件）\"></a>2.1 MouseEvent（鼠标事件）</h4><p>继承自<strong> UIEvent</strong>，处理所有鼠标相关事件，比如点击、移动、滚轮操作都属于这类。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>screenX</code>, <code>screenY</code>：屏幕坐标</li>\n<li><code>clientX</code>, <code>clientY</code>：视口坐标</li>\n<li><code>pageX</code>, <code>pageY</code>：文档坐标</li>\n<li><code>screenX</code>, <code>screenY</code>：屏幕坐标</li>\n<li><code>offsetX</code>, <code>offsetY</code>：目标元素坐标</li>\n<li><code>button</code>：按下的鼠标按钮（0 = 左键, 1 = 中键, 2 = 右键）</li>\n<li><code>buttons</code>：按下的多个按钮</li>\n<li><code>relatedTarget</code>：相关元素（如 mouseover 时的来源元素）</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n<th>是否冒泡</th>\n<th>注意点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>click</code></td>\n<td>鼠标按下并释放（通常是左键）</td>\n<td>✅</td>\n<td>双击会触发两次 <code>click</code></td>\n</tr>\n<tr>\n<td><code>dblclick</code></td>\n<td>双击鼠标</td>\n<td>✅</td>\n<td>响应速度比 <code>click</code> 慢，慎用</td>\n</tr>\n<tr>\n<td><code>mousedown</code>/<code>mouseup</code></td>\n<td>鼠标按下 / 释放</td>\n<td>✅</td>\n<td>区分按下和释放的状态（比如拖拽开始 / 结束）</td>\n</tr>\n<tr>\n<td><code>mousemove</code></td>\n<td>鼠标移动</td>\n<td>✅</td>\n<td>触发频率高，需要节流优化</td>\n</tr>\n<tr>\n<td><code>mouseenter</code>/<code>mouseleave</code></td>\n<td>鼠标进入 / 离开元素</td>\n<td>❌</td>\n<td>不冒泡，子元素不会触发（比如鼠标从父元素进子元素，不会触发父元素的 <code>mouseleave</code>）</td>\n</tr>\n<tr>\n<td><code>mouseover</code>/<code>mouseout</code></td>\n<td>鼠标进入 / 离开元素或子元素</td>\n<td>✅</td>\n<td>冒泡，子元素会触发（比如鼠标从父元素进子元素，父元素会触发 <code>mouseout</code>）</td>\n</tr>\n<tr>\n<td><code>contextmenu</code></td>\n<td>右键菜单</td>\n<td>✅</td>\n<td></td>\n</tr>\n</tbody></table>\n<h5 id=\"2-1-1-WheelEvent（滚轮事件）\"><a href=\"#2-1-1-WheelEvent（滚轮事件）\" class=\"headerlink\" title=\"2.1.1 WheelEvent（滚轮事件）\"></a>2.1.1 WheelEvent（滚轮事件）</h5><p>继承自<strong> MouseEvent</strong>，处理滚轮 / 触控板滚动事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>deltaX</code>：水平滚动量（像素）</li>\n<li><code>deltaY</code>：垂直滚动量（像素）</li>\n<li><code>deltaZ</code>：Z 轴滚动量（3D 设备）</li>\n<li><code>deltaMode</code>：滚动单位（0 = 像素, 1 = 行, 2 = 页）</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n<th>注意点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>wheel</code></td>\n<td>滚轮滚动</td>\n<td>控制滚动方向和速度（替代旧的 <code>mousewheel</code> 事件）</td>\n</tr>\n</tbody></table>\n<h5 id=\"2-1-2-DragEvent（拖放事件）\"><a href=\"#2-1-2-DragEvent（拖放事件）\" class=\"headerlink\" title=\"2.1.2 DragEvent（拖放事件）\"></a>2.1.2 DragEvent（拖放事件）</h5><p>继承自<strong> MouseEvent</strong>，处理拖放事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>dataTransfer</code>：在拖放交互期间传输的数据</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>drag</code></td>\n<td>拖动元素（含选择的文本，下同）</td>\n</tr>\n<tr>\n<td><code>dragstart</code>, <code>dragend</code></td>\n<td>开始拖动元素, 拖动操作结束（释放鼠标按钮或按下退出键）</td>\n</tr>\n<tr>\n<td><code>dragover</code></td>\n<td>元素拖动到有效放置目标上（每几百毫秒）</td>\n</tr>\n<tr>\n<td><code>dragenter</code>, <code>dragleave</code></td>\n<td>拖动的元素进入放置目标, 拖动的元素离开放置目标</td>\n</tr>\n<tr>\n<td><code>drop</code></td>\n<td>在放置目标上放置元素</td>\n</tr>\n</tbody></table>\n<h5 id=\"2-1-3-PointerEvent（指针事件）\"><a href=\"#2-1-3-PointerEvent（指针事件）\" class=\"headerlink\" title=\"2.1.3 PointerEvent（指针事件）\"></a>2.1.3 PointerEvent（指针事件）</h5><p>继承自<strong> MouseEvent</strong>，统一鼠标、触摸、触控笔事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>pointerId</code>：唯一指针 ID</li>\n<li><code>width</code>, <code>height</code>：接触区域尺寸</li>\n<li><code>pressure</code>：压力值（0-1）</li>\n<li><code>pointerType</code>：设备类型（” mouse”, “pen”, “touch”）</li>\n<li><code>isPrimary</code>：是否为主指针</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pointerdown</code>, <code>pointerup</code></td>\n<td>指针按下, 指针释放</td>\n</tr>\n<tr>\n<td><code>pointermove</code></td>\n<td>指针移动</td>\n</tr>\n<tr>\n<td><code>pointerover</code>, <code>pointerout</code></td>\n<td>指针进入元素, 指针离开元素</td>\n</tr>\n<tr>\n<td><code>pointerenter</code>, <code>pointerleave</code></td>\n<td>指针进入元素, 指针离开元素</td>\n</tr>\n<tr>\n<td><code>pointercancel</code></td>\n<td>指针中断</td>\n</tr>\n<tr>\n<td><code>gotpointercapture</code>, <code>lostpointercapture</code></td>\n<td>元素启用捕获后触发, 捕获被释放后触发</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-2-KeyboardEvent（键盘事件）\"><a href=\"#2-2-KeyboardEvent（键盘事件）\" class=\"headerlink\" title=\"2.2 KeyboardEvent（键盘事件）\"></a>2.2 KeyboardEvent（键盘事件）</h4><p>继承自<strong> UIEvent</strong>，处理键盘输入事件，比如快捷键、输入验证等。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>key</code>：按键的实际内容（比如按 “A” 是 <code>\"a\"</code> 或 <code>\"A\"</code>，按回车是 <code>\"Enter\"</code>）</li>\n<li><code>code</code>：按键的物理位置（比如按 “A” 是 <code>\"KeyA\"</code>，不管是否按 Shift，位置不变）</li>\n<li><code>location</code>：按键位置（0 = 标准, 1 = 左侧, 2 = 右侧, 3 = 数字键盘）</li>\n<li><code>repeat</code>：布尔值，判断是否是长按重复触发</li>\n<li><code>isComposing</code>：布尔值，判断是否在输入法输入中（比如中文输入时避免误触发）</li>\n<li>修饰键状态：<code>altKey</code>, <code>ctrlKey</code>, <code>shiftKey</code>, <code>metaKey</code></li>\n</ul>\n<p>方法：</p>\n<ul>\n<li><code>getModifierState(key)</code>：检查特定修饰键状态</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件</th>\n<th>触发时机</th>\n<th>是否冒泡</th>\n<th>常用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>keydown</code></td>\n<td>按下任意键（包括功能键）</td>\n<td>✅</td>\n<td>监听快捷键（比如 Ctrl + S 保存）</td>\n</tr>\n<tr>\n<td><code>keyup</code></td>\n<td>释放按键时</td>\n<td>✅</td>\n<td>取消快捷键状态（比如松开 Ctrl 后停止批量操作）</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意：<code>keypress</code> 事件已过时，尽量用 <code>keydown</code> 替代，它支持所有按键类型。</p>\n</blockquote>\n<h4 id=\"2-3-FocusEvent（焦点事件）\"><a href=\"#2-3-FocusEvent（焦点事件）\" class=\"headerlink\" title=\"2.3 FocusEvent（焦点事件）\"></a>2.3 FocusEvent（焦点事件）</h4><p>继承自<strong> UIEvent</strong>，处理元素焦点变化，比如表单输入时的交互。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>relatedTarget</code>：相关元素（如失去焦点时获得焦点的元素）</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n<th>是否冒泡</th>\n<th>注意点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>focus</code>/<code>blur</code></td>\n<td>元素获得 / 失去焦点</td>\n<td>❌</td>\n<td>不冒泡，无法用事件委托</td>\n</tr>\n<tr>\n<td><code>focusin</code>/<code>focusout</code></td>\n<td>元素获得 / 失去焦点</td>\n<td>✅</td>\n<td>冒泡，推荐用它做事件委托（比如表单所有输入框的焦点处理）</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-4-TouchEvent（触摸事件）\"><a href=\"#2-4-TouchEvent（触摸事件）\" class=\"headerlink\" title=\"2.4 TouchEvent（触摸事件）\"></a>2.4 TouchEvent（触摸事件）</h4><p>继承自<strong> UIEvent</strong>，处理触摸屏设备交互。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>touches</code>：当前所有触摸点</li>\n<li><code>targetTouches</code>：当前元素上的触摸点</li>\n<li><code>changedTouches</code>：本次事件相关的触摸点</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>touchstart</code></td>\n<td>触摸开始</td>\n</tr>\n<tr>\n<td><code>touchmove</code></td>\n<td>触摸移动</td>\n</tr>\n<tr>\n<td><code>touchend</code></td>\n<td>触摸结束</td>\n</tr>\n<tr>\n<td><code>touchcancel</code></td>\n<td>触摸中断</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-5-InputEvent（输入事件）\"><a href=\"#2-5-InputEvent（输入事件）\" class=\"headerlink\" title=\"2.5 InputEvent（输入事件）\"></a>2.5 InputEvent（输入事件）</h4><p>继承自<strong> UIEvent</strong>，处理用户输入事件，比如实时监听输入框、文本域的内容变化，比 <code>change</code> 事件更灵敏（<code>change</code> 需要失去焦点才触发）。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>data</code>：插入的字符</li>\n<li><code>dataTransfer</code>：拖放或插入 / 删除的数据</li>\n<li><code>inputType</code>：更改的类型（<code>inserting</code>或<code>deleting</code>）</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n<th>常用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>input</code></td>\n<td>用户输入</td>\n<td>实时搜索提示、输入字数统计</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-AnimationEvent（动画事件）\"><a href=\"#3-AnimationEvent（动画事件）\" class=\"headerlink\" title=\"3. AnimationEvent（动画事件）\"></a>3. AnimationEvent（动画事件）</h3><p>继承自<strong> Event</strong>，处理 CSS 动画相关事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>animationName</code>：动画名称</li>\n<li><code>elapsedTime</code>：动画已运行时间（秒）</li>\n<li><code>pseudoElement</code>：关联的伪元素（如 “::before”）</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>animationstart</code>, <code>animationend</code></td>\n<td>动画开始, 动画结束</td>\n</tr>\n<tr>\n<td><code>animationiteration</code></td>\n<td>动画重复播放</td>\n</tr>\n<tr>\n<td><code>animationcancel</code></td>\n<td>动画被取消</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-TransitionEvent（过渡事件）\"><a href=\"#4-TransitionEvent（过渡事件）\" class=\"headerlink\" title=\"4. TransitionEvent（过渡事件）\"></a>4. TransitionEvent（过渡事件）</h3><p>继承自<strong> Event</strong>，处理 CSS 过渡效果相关事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>propertyName</code>：发生过渡的 CSS 属性</li>\n<li><code>elapsedTime</code>：过渡已运行时间（秒）</li>\n<li><code>pseudoElement</code>：关联的伪元素</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>transitionrun</code></td>\n<td>过渡创建时</td>\n</tr>\n<tr>\n<td><code>transitionstart</code></td>\n<td>过渡实际开始时</td>\n</tr>\n<tr>\n<td><code>transitionend</code></td>\n<td>过渡完成时</td>\n</tr>\n<tr>\n<td><code>transitioncancel</code></td>\n<td>过渡被取消时</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-ClipboardEvent（剪贴板事件）\"><a href=\"#5-ClipboardEvent（剪贴板事件）\" class=\"headerlink\" title=\"5. ClipboardEvent（剪贴板事件）\"></a>5. ClipboardEvent（剪贴板事件）</h3><p>继承自<strong> Event</strong>，用于处理剪切板相关信息的事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>clipboardData</code>：受剪贴板操作影响的数据</li>\n</ul>\n<p>具体事件类型：</p>\n<table>\n<thead>\n<tr>\n<th>事件类型</th>\n<th>触发时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>copy</code></td>\n<td>复制元素的内容</td>\n</tr>\n<tr>\n<td><code>cut</code></td>\n<td>剪切元素的内容</td>\n</tr>\n<tr>\n<td><code>paste</code></td>\n<td>将内容粘贴到元素中</td>\n</tr>\n</tbody></table>\n<h3 id=\"6-CustomEvent（自定义事件）\"><a href=\"#6-CustomEvent（自定义事件）\" class=\"headerlink\" title=\"6. CustomEvent（自定义事件）\"></a>6. CustomEvent（自定义事件）</h3><p>继承自<strong> Event</strong>，用于创建自定义事件。</p>\n<p>特有属性：</p>\n<ul>\n<li><code>detail</code>：自定义数据</li>\n</ul>\n<p>方法：</p>\n<ul>\n<li><code>initCustomEvent()</code>：初始化自定义事件</li>\n</ul>\n<h4 id=\"用法示例\"><a href=\"#用法示例\" class=\"headerlink\" title=\"用法示例\"></a>用法示例</h4><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建自定义事件：事件名 + 配置（可传自定义数据）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dataLoadedEvent = <span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">'data-loaded'</span>, {</span><br><span class=\"line\">  <span class=\"attr\">detail</span>: { <span class=\"attr\">list</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>] }, <span class=\"comment\">// 自定义数据，通过 event.detail 访问</span></span><br><span class=\"line\">  <span class=\"attr\">bubbles</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 是否冒泡</span></span><br><span class=\"line\">  <span class=\"attr\">cancelable</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 是否可阻止默认行为</span></span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 绑定事件监听</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'data-loaded'</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'收到数据：'</span>, event.<span class=\"property\">detail</span>.<span class=\"property\">list</span>); <span class=\"comment\">// 输出 [1,2,3]</span></span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 触发事件</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">dispatchEvent</span>(dataLoadedEvent);</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"三、事件性能优化：避免卡顿、减少浪费\"><a href=\"#三、事件性能优化：避免卡顿、减少浪费\" class=\"headerlink\" title=\"三、事件性能优化：避免卡顿、减少浪费\"></a>三、事件性能优化：避免卡顿、减少浪费</h2><p>事件处理很容易出性能问题，比如滚动、拖拽这类高频事件，处理不好会让页面卡顿。分享几个我实战中验证过的优化技巧：</p>\n<h3 id=\"3-1-高频事件：用防抖（debounce）和节流（throttle）控频率\"><a href=\"#3-1-高频事件：用防抖（debounce）和节流（throttle）控频率\" class=\"headerlink\" title=\"3.1 高频事件：用防抖（debounce）和节流（throttle）控频率\"></a>3.1 高频事件：用防抖（debounce）和节流（throttle）控频率</h3><p>像 <code>scroll</code>、<code>mousemove</code>、<code>resize</code> 这类事件，触发频率非常高（比如滚动时每秒触发几十次），直接执行处理函数会占用大量主线程，导致页面卡顿。这时候需要用 “防抖” 或 “节流” 控制执行次数。</p>\n<h4 id=\"防抖（debounce）：连续触发只执行最后一次\"><a href=\"#防抖（debounce）：连续触发只执行最后一次\" class=\"headerlink\" title=\"防抖（debounce）：连续触发只执行最后一次\"></a>防抖（debounce）：连续触发只执行最后一次</h4><p>比如窗口 resize 时，用户拖动窗口的过程中不执行，等用户停手后再执行一次，避免频繁计算。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 防抖：最后的胜利者（连续触发只执行最后一次）</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span>(<span class=\"params\">fn, delay</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer; <span class=\"comment\">// 用闭包保存定时器</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) {</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timer); <span class=\"comment\">// 每次触发都清空之前的定时器</span></span><br><span class=\"line\">    <span class=\"comment\">// 重新计时，等 delay 毫秒后执行</span></span><br><span class=\"line\">    timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args), delay);</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法：窗口 resize 时，等 200ms 稳定后再执行</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">'resize'</span>,</span><br><span class=\"line\">  <span class=\"title function_\">debounce</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'窗口大小稳定了，执行调整逻辑'</span>);</span><br><span class=\"line\">  }, <span class=\"number\">200</span>),</span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"节流（throttle）：固定间隔执行一次\"><a href=\"#节流（throttle）：固定间隔执行一次\" class=\"headerlink\" title=\"节流（throttle）：固定间隔执行一次\"></a>节流（throttle）：固定间隔执行一次</h4><p>比如滚动加载时，不管滚动多快，每隔 100ms 只执行一次，避免请求发送太频繁。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">throttle</span>(<span class=\"params\">fn, interval</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> lastTime = <span class=\"number\">0</span>; <span class=\"comment\">// 上次执行时间</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">const</span> now = <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 距离上次执行超过 interval 才执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (now - lastTime &gt;= interval) {</span><br><span class=\"line\">      fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args);</span><br><span class=\"line\">      lastTime = now; <span class=\"comment\">// 更新上次执行时间</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 用法：滚动时每隔 100ms 执行一次</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">'scroll'</span>,</span><br><span class=\"line\">  <span class=\"title function_\">throttle</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'滚动中，按固定间隔执行'</span>);</span><br><span class=\"line\">  }, <span class=\"number\">100</span>),</span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-2-多元素事件：用事件委托减少监听器\"><a href=\"#3-2-多元素事件：用事件委托减少监听器\" class=\"headerlink\" title=\"3.2 多元素事件：用事件委托减少监听器\"></a>3.2 多元素事件：用事件委托减少监听器</h3><p>如果有很多相同元素需要绑定事件（比如列表里的删除按钮），一个个绑定会创建大量监听器，浪费内存。这时候用 “事件委托”，把监听器绑在父元素上，通过 <code>event.target</code> 判断是否点击目标元素。</p>\n<h4 id=\"反面示例：逐个绑定（低效）\"><a href=\"#反面示例：逐个绑定（低效）\" class=\"headerlink\" title=\"反面示例：逐个绑定（低效）\"></a>反面示例：逐个绑定（低效）</h4><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给每个 .remove-btn 绑事件，元素多的时候很卡</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">'.remove-btn'</span>).<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">btn</span>) =&gt;</span> {</span><br><span class=\"line\">  btn.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    btn.<span class=\"property\">parentElement</span>.<span class=\"title function_\">remove</span>();</span><br><span class=\"line\">  });</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"正面示例：事件委托（高效）\"><a href=\"#正面示例：事件委托（高效）\" class=\"headerlink\" title=\"正面示例：事件委托（高效）\"></a>正面示例：事件委托（高效）</h4><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 只给父容器绑一个事件，不管有多少子元素都能处理</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'list-container'</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"comment\">// 判断点击的是不是 .remove-btn</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.<span class=\"property\">target</span>.<span class=\"title function_\">matches</span>(<span class=\"string\">'.remove-btn'</span>)) {</span><br><span class=\"line\">    event.<span class=\"property\">target</span>.<span class=\"property\">parentElement</span>.<span class=\"title function_\">remove</span>();</span><br><span class=\"line\">  }</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"额外优势：支持动态元素\"><a href=\"#额外优势：支持动态元素\" class=\"headerlink\" title=\"额外优势：支持动态元素\"></a>额外优势：支持动态元素</h4><p>如果列表是动态生成的（比如 AJAX 加载后新增的项），逐个绑定的事件会失效，但事件委托能自动处理 —— 因为监听器在父容器上，新元素只要符合选择器，点击就能触发。</p>\n<div class=\"note success flat\"><p><strong>性能秘诀：</strong> 对<mark>动态内容</mark>使用<mark>事件委托</mark>是高性能 Web 应用的关键！</p></div>\n\n<h3 id=\"3-3-一次性事件：用-once-true-自动解绑\"><a href=\"#3-3-一次性事件：用-once-true-自动解绑\" class=\"headerlink\" title=\"3.3 一次性事件：用 once: true 自动解绑\"></a>3.3 一次性事件：用 <code>once: true</code> 自动解绑</h3><p>有些事件只需要执行一次（比如 “点击后弹出提示，之后再点无效”），不用手动解绑，加个 <code>once: true</code> 选项，执行完会自动移除监听器。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以使用匿名函数，自动在调用后删除，再点不会触发</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'.tips-btn'</span>).<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">'click'</span>,</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"string\">'这是只弹一次的提示'</span>);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  { <span class=\"attr\">once</span>: <span class=\"literal\">true</span> },</span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-4-滚动-触摸事件：用-passive-true-提升流畅度\"><a href=\"#3-4-滚动-触摸事件：用-passive-true-提升流畅度\" class=\"headerlink\" title=\"3.4 滚动/触摸事件：用 passive: true 提升流畅度\"></a>3.4 滚动 / 触摸事件：用 <code>passive: true</code> 提升流畅度</h3><p>浏览器在处理 <code>scroll</code>、<code>touchmove</code> 这类事件时，会先检查函数是否调用 <code>preventDefault()</code>，如果有，会阻塞滚动，导致卡顿。如果你的函数不会阻止默认行为，加 <code>passive: true</code> 告诉浏览器 “不用等检查了，直接执行”，能显著提升滚动流畅度。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 滚动事件加 passive: true，提升流畅度</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">'scroll'</span>,</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'滚动中，不阻止默认行为'</span>);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  { <span class=\"attr\">passive</span>: <span class=\"literal\">true</span> },</span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote>\n<p>注意：如果加了 <code>passive: true</code>，再调用 <code>preventDefault()</code> 会报错，因为浏览器已经认定你不会阻止默认行为了。</p>\n</blockquote>\n<h3 id=\"3-5-事件顺序控制：用-capture-true-精确控制事件触发顺序（不是常规性能优化的手段）\"><a href=\"#3-5-事件顺序控制：用-capture-true-精确控制事件触发顺序（不是常规性能优化的手段）\" class=\"headerlink\" title=\"3.5 事件顺序控制：用 capture: true 精确控制事件触发顺序（不是常规性能优化的手段）\"></a>3.5 事件顺序控制：用 <code>capture: true</code> 精确控制事件触发顺序（不是常规性能优化的手段）</h3><p>在某些特定场景下，捕获阶段可能更早地处理事件，从而能够阻止事件进一步传播。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">'click'</span>,</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.<span class=\"property\">target</span>.<span class=\"title function_\">matches</span>(<span class=\"string\">'.should-block'</span>)) {</span><br><span class=\"line\">      e.<span class=\"title function_\">stopPropagation</span>(); <span class=\"comment\">// 阻止所有后续监听器</span></span><br><span class=\"line\">      e.<span class=\"title function_\">preventDefault</span>();</span><br><span class=\"line\">    }</span><br><span class=\"line\">  },</span><br><span class=\"line\">  { <span class=\"attr\">capture</span>: <span class=\"literal\">true</span> }, <span class=\"comment\">// 在捕获阶段早期检查</span></span><br><span class=\"line\">);</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-6-不再需要的事件：用-removeEventListener-及时解绑避免内存泄漏\"><a href=\"#3-6-不再需要的事件：用-removeEventListener-及时解绑避免内存泄漏\" class=\"headerlink\" title=\"3.6 不再需要的事件：用 removeEventListener 及时解绑避免内存泄漏\"></a>3.6 不再需要的事件：用 <code>removeEventListener</code> 及时解绑避免内存泄漏</h3><p>如果元素被删除（比如单页应用切换组件），但事件监听器没解绑，浏览器会一直持有这个函数和元素的引用，导致内存泄漏。一定要在合适的时机解绑。</p>\n<h4 id=\"正确示例：组件销毁时解绑\"><a href=\"#正确示例：组件销毁时解绑\" class=\"headerlink\" title=\"正确示例：组件销毁时解绑\"></a>正确示例：组件销毁时解绑</h4><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ListComponent</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 绑定this，避免函数内this指向错误</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">handleClick</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">handleClick</span>.<span class=\"title function_\">bind</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">container</span> = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'list-container'</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">container</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">handleClick</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">handleClick</span>(<span class=\"params\">event</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 处理点击逻辑</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 组件销毁时调用，解绑事件</span></span><br><span class=\"line\">  <span class=\"title function_\">destroy</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">container</span>.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">handleClick</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 切换组件时，销毁旧组件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> oldList = <span class=\"keyword\">new</span> <span class=\"title class_\">ListComponent</span>();</span><br><span class=\"line\">oldList.<span class=\"title function_\">destroy</span>(); <span class=\"comment\">// 解绑事件，避免内存泄漏</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><ol>\n<li><p>匿名函数无法移除，要使用具名函数</p>\n</li>\n<li><p>解绑时要和绑定的函数、参数完全一致<br>比如绑定的时候用了 <code>capture: true</code>，解绑时也要加，否则解不掉：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 绑定：加了 capture: true</span></span><br><span class=\"line\">element.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, handleClick, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解绑：必须也加 capture: true，否则无效</span></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">'click'</span>, handleClick, <span class=\"literal\">true</span>);</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h3 id=\"3-7-事件选择原则\"><a href=\"#3-7-事件选择原则\" class=\"headerlink\" title=\"3.7 事件选择原则\"></a>3.7 事件选择原则</h3><ul>\n<li><strong>优先使用不会冒泡的事件</strong>：如 <code>mouseenter/mouseleave</code> 替代 <code>mouseover/mouseout</code><blockquote>\n<p>这样可以减少事件处理函数被意外触发的可能性，同时也能减少事件传播带来的性能开销（尽管在现代浏览器中这种开销通常很小）。但要注意，它们不能用于事件委托（因为不冒泡），所以使用场景是直接绑定到目标元素。</p>\n</blockquote>\n</li>\n<li><strong>移动端优先指针事件</strong>：<code>pointerdown</code> 替代 <code>mousedown/touchstart</code><blockquote>\n<p>使用<code>pointerdown</code>等事件可以同时支持多种输入方式，避免为鼠标和触摸分别写两套事件逻辑。这有助于代码维护和减少重复。</p>\n</blockquote>\n</li>\n<li><strong>焦点事件使用冒泡版本</strong>：<code>focusin/focusout</code> 替代 <code>focus/blur</code><blockquote>\n<p>因为<code>focus</code>和<code>blur</code>事件不冒泡，所以当我们需要在祖先元素上监听焦点变化（例如做表单验证）时，使用冒泡版本的<code>focusin</code>和<code>focusout</code>可以方便地实现事件委托（仅需将事件绑定在表单上），而不必在每个可聚焦元素上单独绑定事件。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"四、实战问题：常见坑与解决方案\"><a href=\"#四、实战问题：常见坑与解决方案\" class=\"headerlink\" title=\"四、实战问题：常见坑与解决方案\"></a>四、实战问题：常见坑与解决方案</h2><h3 id=\"4-1-滚动事件触发太频繁，页面卡顿\"><a href=\"#4-1-滚动事件触发太频繁，页面卡顿\" class=\"headerlink\" title=\"4.1 滚动事件触发太频繁，页面卡顿\"></a>4.1 滚动事件触发太频繁，页面卡顿</h3><p><strong>问题</strong>：<code>scroll</code> 事件每秒触发几十次，处理函数里有 DOM 操作（比如修改样式、计算位置），导致主线程忙不过来，页面卡。<br><strong>解决方案</strong>：</p>\n<ol>\n<li>用节流控制执行频率（比如每隔 100ms 执行一次）；</li>\n<li>复杂计算用 <code>requestAnimationFrame</code> 包裹，让浏览器在重绘时执行，避免掉帧；</li>\n<li>能用 <code>IntersectionObserver</code> 替代的场景，尽量不用滚动事件（比如 “元素进入视口时加载”）。</li>\n</ol>\n<p>优化后的滚动事件处理：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> throttledScroll = <span class=\"title function_\">throttle</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  <span class=\"comment\">// 用 requestAnimationFrame 确保在重绘时执行</span></span><br><span class=\"line\">  <span class=\"title function_\">requestAnimationFrame</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 处理DOM操作</span></span><br><span class=\"line\">    <span class=\"title function_\">updateNavPosition</span>();</span><br><span class=\"line\">  });</span><br><span class=\"line\">}, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'scroll'</span>, throttledScroll, { <span class=\"attr\">passive</span>: <span class=\"literal\">true</span> });</span><br></pre></td></tr></tbody></table></figure>\n\n<p>不使用滚动事件，而是使用<code>IntersectionObserver</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> observer = <span class=\"keyword\">new</span> <span class=\"title class_\">IntersectionObserver</span>(<span class=\"function\">(<span class=\"params\">entries</span>) =&gt;</span> {</span><br><span class=\"line\">  entries.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">entry</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entry.<span class=\"property\">isIntersecting</span>) {</span><br><span class=\"line\">      <span class=\"comment\">// 元素进入视口</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  });</span><br><span class=\"line\">});</span><br><span class=\"line\">observer.<span class=\"title function_\">observe</span>(element);</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-2-移动端点击有-300ms-延迟\"><a href=\"#4-2-移动端点击有-300ms-延迟\" class=\"headerlink\" title=\"4.2 移动端点击有 300ms 延迟\"></a>4.2 移动端点击有 300ms 延迟</h3><p><strong>问题</strong>：早期移动端浏览器为了判断用户是否双击缩放，会在点击后延迟 300ms 再触发 <code>click</code> 事件，导致按钮点击反应慢。</p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li>加 viewport meta 标签，禁用缩放（推荐，简单有效）；<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0, user-scalable=no\"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>\n<li>用 <code>touchstart</code>/<code>touchend</code> 替代 <code>click</code>（需要处理触摸穿透问题）；</li>\n<li>旧项目可用 FastClick 库（现在大部分现代浏览器已优化，但兼容旧设备时可能需要）。<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">if</span> (<span class=\"string\">'addEventListener'</span> <span class=\"keyword\">in</span> <span class=\"variable language_\">document</span>) {</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"string\">'DOMContentLoaded'</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"function\">() =&gt;</span> {</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"title class_\">FastClick</span>.<span class=\"title function_\">attach</span>(<span class=\"variable language_\">document</span>.<span class=\"property\">body</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">      },</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"literal\">false</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">    );</span></span><br><span class=\"line\"><span class=\"language-javascript\">  }</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h3 id=\"4-3-事件冒泡导致父元素事件误触发\"><a href=\"#4-3-事件冒泡导致父元素事件误触发\" class=\"headerlink\" title=\"4.3 事件冒泡导致父元素事件误触发\"></a>4.3 事件冒泡导致父元素事件误触发</h3><p><strong>问题</strong>：点击子元素时，父元素的同类型事件也会触发（比如子按钮和父容器都绑了 <code>click</code> 事件）。</p>\n<p><strong>解决方案</strong>：在子元素的事件处理函数里调用 <code>stopPropagation()</code>，阻止事件继续冒泡。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子元素事件：阻止冒泡，父元素事件不触发</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'.child-btn'</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  event.<span class=\"title function_\">stopPropagation</span>(); <span class=\"comment\">// 阻止事件冒泡到父元素</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'子元素被点击'</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父元素事件：子元素点击时不会触发</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'.parent-container'</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'父元素被点击'</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-4-单页应用切换组件，事件监听器没解绑\"><a href=\"#4-4-单页应用切换组件，事件监听器没解绑\" class=\"headerlink\" title=\"4.4 单页应用切换组件，事件监听器没解绑\"></a>4.4 单页应用切换组件，事件监听器没解绑</h3><p><strong>问题</strong>：单页应用（SPA）切换组件时，旧组件的事件监听器没解绑，导致内存泄漏，甚至出现 “幽灵点击”（切换后旧组件的事件还在触发）。</p>\n<p><strong>解决方案</strong>：</p>\n<ol>\n<li><p>组件销毁时手动解绑事件（如前面 3.6 的示例）；</p>\n</li>\n<li><p>用 <code>AbortController</code> 批量解绑（现代浏览器推荐）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案2：用 AbortController 批量解绑</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> controller = <span class=\"keyword\">new</span> <span class=\"title class_\">AbortController</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> signal = controller.<span class=\"property\">signal</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 绑定多个事件，都用同一个 signal</span></span><br><span class=\"line\">element1.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, handleClick1, { signal });</span><br><span class=\"line\">element2.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'scroll'</span>, handleScroll2, { signal });</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组件销毁时，调用 abort() 批量解绑所有事件</span></span><br><span class=\"line\">controller.<span class=\"title function_\">abort</span>();</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<h2 id=\"五、现代事件处理技巧：更高效的玩法\"><a href=\"#五、现代事件处理技巧：更高效的玩法\" class=\"headerlink\" title=\"五、现代事件处理技巧：更高效的玩法\"></a>五、现代事件处理技巧：更高效的玩法</h2><h3 id=\"5-1-事件总线（Event-Bus）：非关联组件通信\"><a href=\"#5-1-事件总线（Event-Bus）：非关联组件通信\" class=\"headerlink\" title=\"5.1 事件总线（Event Bus）：非关联组件通信\"></a>5.1 事件总线（Event Bus）：非关联组件通信</h3><p>如果两个组件没有直接关系（比如兄弟组件、跨层级组件），可以用 “事件总线” 传递消息，不用一层层传 props 或用全局状态。</p>\n<h4 id=\"简单实现事件总线\"><a href=\"#简单实现事件总线\" class=\"headerlink\" title=\"简单实现事件总线\"></a>简单实现事件总线</h4><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">EventBus</span> = {</span><br><span class=\"line\">  <span class=\"comment\">// 存储事件：key是事件名，value是回调函数数组</span></span><br><span class=\"line\">  <span class=\"attr\">events</span>: {},</span><br><span class=\"line\">  <span class=\"comment\">// 触发事件：传事件名和数据</span></span><br><span class=\"line\">  <span class=\"title function_\">emit</span>(<span class=\"params\">eventName, data</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName]) {</span><br><span class=\"line\">      <span class=\"comment\">// 执行所有绑定的回调</span></span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName].<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">cb</span>) =&gt;</span> <span class=\"title function_\">cb</span>(data));</span><br><span class=\"line\">    }</span><br><span class=\"line\">  },</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 绑定事件：传事件名和回调</span></span><br><span class=\"line\">  <span class=\"title function_\">on</span>(<span class=\"params\">eventName, callback</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName]) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName] = [];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName].<span class=\"title function_\">push</span>(callback);</span><br><span class=\"line\">  },</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 解绑事件（可选）</span></span><br><span class=\"line\">  <span class=\"title function_\">off</span>(<span class=\"params\">eventName, callback</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName]) {</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName] = <span class=\"variable language_\">this</span>.<span class=\"property\">events</span>[eventName].<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">cb</span>) =&gt;</span> cb !== callback);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组件A：触发事件</span></span><br><span class=\"line\"><span class=\"title class_\">EventBus</span>.<span class=\"title function_\">emit</span>(<span class=\"string\">'user-login'</span>, { <span class=\"attr\">username</span>: <span class=\"string\">'test'</span> });</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组件B：监听事件</span></span><br><span class=\"line\"><span class=\"title class_\">EventBus</span>.<span class=\"title function_\">on</span>(<span class=\"string\">'user-login'</span>, <span class=\"function\">(<span class=\"params\">userInfo</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`用户<span class=\"subst\">${userInfo.username}</span>登录了。`</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-2-AbortController：现代事件管理\"><a href=\"#5-2-AbortController：现代事件管理\" class=\"headerlink\" title=\"5.2 AbortController：现代事件管理\"></a>5.2 AbortController：现代事件管理</h3><p>前面提到过 <code>AbortController</code> 能批量解绑事件，它还能配合 fetch、定时器等使用，是现代浏览器推荐的 “资源管理” 方案。</p>\n<h4 id=\"用-AbortController-取消-fetch-请求\"><a href=\"#用-AbortController-取消-fetch-请求\" class=\"headerlink\" title=\"用 AbortController 取消 fetch 请求\"></a>用 AbortController 取消 fetch 请求</h4><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> controller = <span class=\"keyword\">new</span> <span class=\"title class_\">AbortController</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> signal = controller.<span class=\"property\">signal</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发起fetch请求，传signal</span></span><br><span class=\"line\"><span class=\"title function_\">fetch</span>(<span class=\"string\">'/api/data'</span>, { signal })</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> res.<span class=\"title function_\">json</span>())</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err.<span class=\"property\">name</span> === <span class=\"string\">'AbortError'</span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'请求被取消了'</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  });</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3秒后取消请求（比如用户点击“取消”按钮）</span></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> controller.<span class=\"title function_\">abort</span>(), <span class=\"number\">3000</span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"最后小测验\"><a href=\"#最后小测验\" class=\"headerlink\" title=\"最后小测验\"></a>最后小测验</h2><p>当用户点击一个按钮时，事件流的哪个阶段最先触发？<br>A) 目标阶段<br>B) 冒泡阶段<br>C) 捕获阶段</p>\n<p><strong>答案</strong>：C) 捕获阶段（事件从 <code>window</code> 向下传递到目标元素，先经过捕获阶段，再到目标阶段，最后是冒泡阶段）</p>\n<hr>\n<p>事件系统是前端交互的核心，掌握它不仅能写出流畅的交互，还能避免很多隐藏的性能问题。建议大家在实际项目中多尝试优化技巧，比如用事件委托替代多监听器、用 <code>passive</code> 提升滚动流畅度 —— 这些小改动能让页面体验提升一大截！</p>\n",
            "tags": [
                "JavaScript",
                "性能优化"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/prototype-chain/",
            "url": "http://toukoxu.github.io/archives/prototype-chain/",
            "title": "原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心",
            "date_published": "2021-05-02T12:46:25.000Z",
            "content_html": "<blockquote>\n<p>原型链是 JavaScript 面向对象的 “底层逻辑”—— 它让对象能 “继承” 其他对象的属性和方法，而 ES6 的 <code>class</code> 只是这套逻辑的 “语法糖”。今天从原型链的本质讲到 Class 的应用，帮你彻底搞懂 JS 继承到底是怎么回事。</p>\n</blockquote>\n<h2 id=\"一、原型链：JS-对象继承的“底层骨架”\"><a href=\"#一、原型链：JS-对象继承的“底层骨架”\" class=\"headerlink\" title=\"一、原型链：JS 对象继承的“底层骨架”\"></a>一、原型链：JS 对象继承的 “底层骨架”</h2><h3 id=\"1-1-什么是原型链？\"><a href=\"#1-1-什么是原型链？\" class=\"headerlink\" title=\"1.1 什么是原型链？\"></a>1.1 什么是原型链？</h3><p>简单说，<strong>原型链是 JS 实现继承的核心机制</strong>：每个对象都有一个隐藏的 “原型”（<code>[[Prototype]]</code>，可通过 <code>Object.getPrototypeOf()</code> 访问），这个原型本身也是一个对象，它也有自己的原型 —— 这样层层向上，就形成了一条 “原型链”。</p>\n<p>当你访问一个对象的属性时，如果当前对象没有这个属性，JS 会自动沿着原型链向上查找，直到找到属性或走到链的尽头（<code>null</code>）。</p>\n<p>看个直观的例子：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父对象：动物，有一个共享属性 eats</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> animal = { <span class=\"attr\">eats</span>: <span class=\"literal\">true</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子对象：兔子，有自己的属性 jumps</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> rabbit = { <span class=\"attr\">jumps</span>: <span class=\"literal\">true</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把 rabbit 的原型设为 animal（让兔子继承动物的属性）</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">setPrototypeOf</span>(rabbit, animal);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在兔子能访问动物的 eats 属性了</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rabbit.<span class=\"property\">eats</span>); <span class=\"comment\">// true（从原型链上找到的）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"1-2-原型链的三个核心概念\"><a href=\"#1-2-原型链的三个核心概念\" class=\"headerlink\" title=\"1.2 原型链的三个核心概念\"></a>1.2 原型链的三个核心概念</h3><p>要理解原型链，必须分清这三个容易混淆的概念：</p>\n<ol>\n<li><strong><code>prototype</code></strong>：只有<strong>函数</strong>才有这个属性，它是一个对象，存储着 “该函数创建的实例要继承的属性和方法”（比如 <code>Person.prototype</code> 里的方法，会被所有 <code>new Person()</code> 出来的实例继承）。</li>\n<li><strong><code>[[Prototype]]</code></strong>：所有对象（包括函数）都有的隐藏属性，指向该对象的 “原型对象”（可通过 <code>Object.getPrototypeOf(obj)</code> 访问，旧版的 <code>__proto__</code> 已不推荐使用）。</li>\n<li><strong><code>constructor</code></strong>：原型对象上的属性，指向 “创建该原型对应的实例的构造函数”（比如 <code>Person.prototype.constructor === Person</code>）。</li>\n</ol>\n<p>它们的关系可以用一张图表示：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  graph LR\nA[\"实例对象（如 new Person()）\"] --&gt;|\"[[Prototype]]\"| B[\"构造函数的 prototype（Person.prototype）\"]\nB --&gt;|\"[[Prototype]]\"| C[\"Object.prototype（所有对象的最终原型）\"]\nC --&gt;|\"[[Prototype]]\"| D[\"null（原型链的终点）\"]\nB --&gt;|constructor| E[\"构造函数（Person）\"]\n  </pre></div>\n\n<h2 id=\"二、原型链是怎么“造”出来的？\"><a href=\"#二、原型链是怎么“造”出来的？\" class=\"headerlink\" title=\"二、原型链是怎么“造”出来的？\"></a>二、原型链是怎么 “造” 出来的？</h2><h3 id=\"2-1-用构造函数创建对象：原型链的常见来源\"><a href=\"#2-1-用构造函数创建对象：原型链的常见来源\" class=\"headerlink\" title=\"2.1 用构造函数创建对象：原型链的常见来源\"></a>2.1 用构造函数创建对象：原型链的常见来源</h3><p>我们平时用 <code>new 构造函数()</code> 创建对象时，原型链会自动生成。比如：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 定义构造函数（用来创建“人”实例）</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 实例独有的属性：每个实例的 name 都不同</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在构造函数的 prototype 上定义共享方法（所有实例共用）</span></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayHello</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`你好，我是<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span>`</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 用 new 创建实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> alice = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">'Alice'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 验证原型关系</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(alice) === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// true（实例的原型是构造函数的 prototype）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>); <span class=\"comment\">// true（原型的构造函数指向原函数）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"2-2-new-操作符的底层逻辑\"><a href=\"#2-2-new-操作符的底层逻辑\" class=\"headerlink\" title=\"2.2 new 操作符的底层逻辑\"></a>2.2 <code>new</code> 操作符的底层逻辑</h3><p>你可能好奇：<code>new</code> 到底做了什么，能让实例和原型链关联起来？其实它只干了四件事：</p>\n<ol>\n<li>创建一个空对象（<code>{}</code>）；</li>\n<li>把这个空对象的原型，设为构造函数的 <code>prototype</code>；</li>\n<li>执行构造函数，把 <code>this</code> 指向这个空对象（给对象加属性）；</li>\n<li>如果构造函数没有返回其他对象，就返回这个新对象（否则返回构造函数的返回值）。</li>\n</ol>\n<p>我们可以手动模拟一个 <code>new</code> 操作符，更直观地看到这个过程：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myNew</span>(<span class=\"params\">constructor, ...args</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 1. 创建空对象，并把它的原型设为构造函数的 prototype</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(constructor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 执行构造函数，this 指向新对象</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = constructor.<span class=\"title function_\">apply</span>(obj, args);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 返回结果：如果构造函数返回了对象，就用它；否则用新对象</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span> ? result : obj;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用自定义的 myNew 创建实例，和原生 new 效果一样</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bob = <span class=\"title function_\">myNew</span>(<span class=\"title class_\">Person</span>, <span class=\"string\">'Bob'</span>);</span><br><span class=\"line\">bob.<span class=\"title function_\">sayHello</span>(); <span class=\"comment\">// 你好，我是Bob</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"三、原型链的“查找规则”：属性是怎么找到的？\"><a href=\"#三、原型链的“查找规则”：属性是怎么找到的？\" class=\"headerlink\" title=\"三、原型链的“查找规则”：属性是怎么找到的？\"></a>三、原型链的 “查找规则”：属性是怎么找到的？</h2><h3 id=\"3-1-属性查找的完整流程\"><a href=\"#3-1-属性查找的完整流程\" class=\"headerlink\" title=\"3.1 属性查找的完整流程\"></a>3.1 属性查找的完整流程</h3><p>当你访问 <code>obj.prop</code> 时，JS 会按以下步骤查找：</p>\n<ol>\n<li>先检查 <code>obj</code> 自身有没有 <code>prop</code>（通过 <code>obj.hasOwnProperty('prop')</code> 可判断）；</li>\n<li>如果没有，就找 <code>obj</code> 的原型（<code>Object.getPrototypeOf(obj)</code>），检查原型有没有 <code>prop</code>；</li>\n<li>如果原型也没有，就找原型的原型，以此类推；</li>\n<li>直到找到 <code>prop</code> 并返回，或者走到原型链尽头（<code>null</code>），返回 <code>undefined</code>。</li>\n</ol>\n<p>看个例子理解这个流程：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 定义构造函数 Animal</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Animal</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name; <span class=\"comment\">// 实例独有的属性</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在 Animal.prototype 上定义共享方法</span></span><br><span class=\"line\"><span class=\"title class_\">Animal</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">eat</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span> 在吃东西`</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 创建实例 cat</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> cat = <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>(<span class=\"string\">'喵星人'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 调用 cat.eat()，查找流程：</span></span><br><span class=\"line\"><span class=\"comment\">// ① 检查 cat 自身：没有 eat 方法 → ② 查 cat 的原型（Animal.prototype）→ 找到 eat 方法，执行</span></span><br><span class=\"line\">cat.<span class=\"title function_\">eat</span>(); <span class=\"comment\">// 喵星人 在吃东西</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"3-2-原型链的终点：null\"><a href=\"#3-2-原型链的终点：null\" class=\"headerlink\" title=\"3.2 原型链的终点：null\"></a>3.2 原型链的终点：<code>null</code></h3><p>所有原型链的最终尽头都是 <code>null</code>—— 因为 <code>Object.prototype</code> 的原型就是 <code>null</code>，它是 “所有对象的最终原型”（除了用 <code>Object.create(null)</code> 创建的 “纯净对象”）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cat = <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>(<span class=\"string\">'喵星人'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 顺着原型链往上找：</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(cat)); <span class=\"comment\">// Animal.prototype（第一层）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(<span class=\"title class_\">Animal</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>)); <span class=\"comment\">// Object.prototype（第二层）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>)); <span class=\"comment\">// null（第三层，终点）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(<span class=\"literal\">null</span>)); <span class=\"comment\">// 报错（null 没有原型）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这也解释了为什么所有对象都能调用 <code>toString()</code>、<code>hasOwnProperty()</code> 等方法 —— 这些方法其实定义在 <code>Object.prototype</code> 上，所有对象都能通过原型链找到它们。</p>\n<h2 id=\"四、原型链的“动态特性”：改原型会影响实例吗？\"><a href=\"#四、原型链的“动态特性”：改原型会影响实例吗？\" class=\"headerlink\" title=\"四、原型链的“动态特性”：改原型会影响实例吗？\"></a>四、原型链的 “动态特性”：改原型会影响实例吗？</h2><h3 id=\"4-1-动态修改原型：已创建的实例也会受影响\"><a href=\"#4-1-动态修改原型：已创建的实例也会受影响\" class=\"headerlink\" title=\"4.1 动态修改原型：已创建的实例也会受影响\"></a>4.1 动态修改原型：已创建的实例也会受影响</h3><p>JS 的原型是 “活的”—— 即使实例已经创建，后续给原型添加的属性 / 方法，实例也能访问到：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Dog</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\"><span class=\"comment\">// 创建实例 dog1（此时 Dog.prototype 上还没有 bark 方法）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dog1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后续给 Dog.prototype 添加 bark 方法</span></span><br><span class=\"line\"><span class=\"title class_\">Dog</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">bark</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'汪汪！'</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// dog1 能调用到新添加的 bark 方法</span></span><br><span class=\"line\">dog1.<span class=\"title function_\">bark</span>(); <span class=\"comment\">// 汪汪！</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这是因为实例访问的是 “原型的引用”，而不是 “原型的副本”—— 原型变了，所有指向它的实例都会跟着变。</p>\n<h3 id=\"4-2-重写原型：旧实例不受影响\"><a href=\"#4-2-重写原型：旧实例不受影响\" class=\"headerlink\" title=\"4.2 重写原型：旧实例不受影响\"></a>4.2 重写原型：旧实例不受影响</h3><p>但如果是 “完全重写原型”（而不是修改原型的属性），情况就不一样了：重写后的原型是一个新对象，只有重写后创建的实例会用新原型，之前的旧实例还是指向原来的原型。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Cat</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\"><span class=\"comment\">// 旧实例：创建于原型重写前</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> cat1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 完全重写 Cat.prototype（新对象）</span></span><br><span class=\"line\"><span class=\"title class_\">Cat</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = {</span><br><span class=\"line\">  <span class=\"title function_\">meow</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'喵喵~'</span>);</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新实例：创建于原型重写后</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> cat2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">cat1.<span class=\"title function_\">meow</span>(); <span class=\"comment\">// 报错（cat1 的原型还是原来的空对象，没有 meow 方法）</span></span><br><span class=\"line\">cat2.<span class=\"title function_\">meow</span>(); <span class=\"comment\">// 喵喵~（cat2 的原型是新对象，有 meow 方法）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"五、ES6-Class：原型链的“语法糖”\"><a href=\"#五、ES6-Class：原型链的“语法糖”\" class=\"headerlink\" title=\"五、ES6 Class：原型链的“语法糖”\"></a>五、ES6 Class：原型链的 “语法糖”</h2><h3 id=\"5-1-Class-本质：还是原型继承\"><a href=\"#5-1-Class-本质：还是原型继承\" class=\"headerlink\" title=\"5.1 Class 本质：还是原型继承\"></a>5.1 Class 本质：还是原型继承</h3><p>ES6 引入的 <code>class</code> 语法，看起来像其他语言的 “类”，但底层还是基于原型链实现的 —— 它只是把原型继承的写法变得更简洁、更易读，没有改变 JS 的底层逻辑。</p>\n<p>比如下面两段代码，功能完全一样：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写法1：ES6 Class</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> {</span><br><span class=\"line\">  <span class=\"comment\">// 构造函数：对应原来的构造函数</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实例方法：会被添加到 Animal.prototype 上</span></span><br><span class=\"line\">  <span class=\"title function_\">eat</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span> 在吃东西`</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法2：ES5 原型继承（和上面完全等价）</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Animal</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Animal</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">eat</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span> 在吃东西`</span>);</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-2-Class-继承：extends-怎么工作？\"><a href=\"#5-2-Class-继承：extends-怎么工作？\" class=\"headerlink\" title=\"5.2 Class 继承：extends 怎么工作？\"></a>5.2 Class 继承：<code>extends</code> 怎么工作？</h3><p>Class 的 <code>extends</code> 关键字，本质是帮我们自动搭建了原型链。比如让 <code>Rabbit</code> 继承 <code>Animal</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子类 Rabbit 继承父类 Animal</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rabbit</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Animal</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name, speed</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// super()：调用父类的 constructor，相当于 Animal.call(this, name)</span></span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(name);</span><br><span class=\"line\">    <span class=\"comment\">// 子类独有的属性</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">speed</span> = speed;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 子类独有的方法（添加到 Rabbit.prototype 上）</span></span><br><span class=\"line\">  <span class=\"title function_\">jump</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span> 跳得很快，速度<span class=\"subst\">${<span class=\"variable language_\">this</span>.speed}</span>`</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建子类实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bunny = <span class=\"keyword\">new</span> <span class=\"title class_\">Rabbit</span>(<span class=\"string\">'小兔'</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 验证继承关系</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bunny <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Rabbit</span>); <span class=\"comment\">// true（是 Rabbit 的实例）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bunny <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Animal</span>); <span class=\"comment\">// true（也是 Animal 的实例，因为继承）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bunny <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span>); <span class=\"comment\">// true（最终继承自 Object）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用继承的方法和自己的方法</span></span><br><span class=\"line\">bunny.<span class=\"title function_\">eat</span>(); <span class=\"comment\">// 小兔 在吃东西（继承自 Animal）</span></span><br><span class=\"line\">bunny.<span class=\"title function_\">jump</span>(); <span class=\"comment\">// 小兔 跳得很快，速度10（自己的方法）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>extends</code> 做的核心事情：把 <code>Rabbit.prototype</code> 的原型，设为 <code>Animal.prototype</code>，从而搭建起 “<code>bunny</code> → <code>Rabbit.prototype</code> → <code>Animal.prototype</code> → <code>Object.prototype</code> → <code>null</code>” 的原型链。</p>\n<h2 id=\"六、原型链的实际用途：这些场景会用到\"><a href=\"#六、原型链的实际用途：这些场景会用到\" class=\"headerlink\" title=\"六、原型链的实际用途：这些场景会用到\"></a>六、原型链的实际用途：这些场景会用到</h2><h3 id=\"6-1-共享方法：节省内存\"><a href=\"#6-1-共享方法：节省内存\" class=\"headerlink\" title=\"6.1 共享方法：节省内存\"></a>6.1 共享方法：节省内存</h3><p>如果多个实例需要用同一个方法，把方法放在原型上（而不是每个实例都定义一次），能大幅节省内存 —— 因为所有实例共享同一个方法引用。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">User</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name; <span class=\"comment\">// 每个实例独有的属性</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有 User 实例共享 sayHi 方法</span></span><br><span class=\"line\"><span class=\"title class_\">User</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayHi</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`你好，<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span>`</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user1 = <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">'Alice'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> user2 = <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">'Bob'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 验证：两个实例的 sayHi 是同一个函数</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(user1.<span class=\"property\">sayHi</span> === user2.<span class=\"property\">sayHi</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果把 <code>sayHi</code> 写在构造函数里（<code>this.sayHi = function() {}</code>），每个实例都会有一个独立的函数副本，内存占用会翻倍。</p>\n<h3 id=\"6-2-实现自定义继承（ES5-写法）\"><a href=\"#6-2-实现自定义继承（ES5-写法）\" class=\"headerlink\" title=\"6.2 实现自定义继承（ES5 写法）\"></a>6.2 实现自定义继承（ES5 写法）</h3><p>在 Class 出现前，我们用原型链手动实现继承。比如让 <code>Circle</code> 继承 <code>Shape</code>：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类：图形</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Shape</span>(<span class=\"params\">color</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">color</span> = color;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父类的共享方法</span></span><br><span class=\"line\"><span class=\"title class_\">Shape</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">getColor</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">color</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类：圆形</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Circle</span>(<span class=\"params\">radius, color</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 1. 调用父类构造函数，继承父类的属性（color）</span></span><br><span class=\"line\">  <span class=\"title class_\">Shape</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, color);</span><br><span class=\"line\">  <span class=\"comment\">// 2. 子类独有的属性</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">radius</span> = radius;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 搭建原型链：让 Circle.prototype 继承 Shape.prototype</span></span><br><span class=\"line\"><span class=\"title class_\">Circle</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"title class_\">Shape</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\"><span class=\"comment\">// 4. 修复 constructor 指向（因为上面一步把 Circle.prototype 换成了新对象，constructor 会指向 Shape）</span></span><br><span class=\"line\"><span class=\"title class_\">Circle</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> = <span class=\"title class_\">Circle</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 子类的共享方法</span></span><br><span class=\"line\"><span class=\"title class_\">Circle</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">getArea</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * <span class=\"variable language_\">this</span>.<span class=\"property\">radius</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用子类</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> redCircle = <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>(<span class=\"number\">5</span>, <span class=\"string\">'red'</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(redCircle.<span class=\"title function_\">getColor</span>()); <span class=\"comment\">// red（继承自 Shape）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(redCircle.<span class=\"title function_\">getArea</span>()); <span class=\"comment\">// 78.539...（自己的方法）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"6-3-扩展内置对象（谨慎使用）\"><a href=\"#6-3-扩展内置对象（谨慎使用）\" class=\"headerlink\" title=\"6.3 扩展内置对象（谨慎使用）\"></a>6.3 扩展内置对象（谨慎使用）</h3><p>我们可以给内置对象的原型添加方法，让所有该类型的对象都能使用。比如给数组加一个 <code>sum</code> 方法：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给 Array.prototype 加 sum 方法，所有数组都能调用</span></span><br><span class=\"line\"><span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sum</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">total, num</span>) =&gt;</span> total + num, <span class=\"number\">0</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(numbers.<span class=\"title function_\">sum</span>()); <span class=\"comment\">// 10</span></span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote>\n<p>⚠️ 注意：扩展内置原型有风险！可能和其他库的方法重名（比如别人也给数组加了 <code>sum</code> 方法），导致代码冲突。非必要不推荐用。</p>\n</blockquote>\n<div class=\"note warning flat\"><p><strong>注意：</strong> 扩展内置原型有风险！可能和其他库的方法重名（比如别人也给数组加了 `sum` 方法），导致代码冲突。非必要不推荐用。</p></div>\n\n<h2 id=\"七、原型链的坑：这些问题要注意\"><a href=\"#七、原型链的坑：这些问题要注意\" class=\"headerlink\" title=\"七、原型链的坑：这些问题要注意\"></a>七、原型链的坑：这些问题要注意</h2><h3 id=\"7-1-原型污染：修改内置原型影响所有对象\"><a href=\"#7-1-原型污染：修改内置原型影响所有对象\" class=\"headerlink\" title=\"7.1 原型污染：修改内置原型影响所有对象\"></a>7.1 原型污染：修改内置原型影响所有对象</h3><p>如果恶意代码（或不小心）修改了 <code>Object.prototype</code>，所有对象都会受到影响 —— 这就是 “原型污染”。比如：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不小心给 Object.prototype 加了一个 hack 方法</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">hack</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'所有对象都会有这个方法！'</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 即使是新建的空对象，也会有 hack 方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> emptyObj = {};</span><br><span class=\"line\">emptyObj.<span class=\"title function_\">hack</span>(); <span class=\"comment\">// 所有对象都会有这个方法！</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>解决方案</strong>：用 <code>Object.create(null)</code> 创建 “纯净对象”—— 这种对象没有原型（<code>[[Prototype]]</code> 是 <code>null</code>），不会继承 <code>Object.prototype</code> 的属性，也就不会被污染：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pureObj = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(pureObj.<span class=\"property\">hack</span>); <span class=\"comment\">// undefined（不受原型污染影响）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"7-2-实例属性“遮蔽”原型属性\"><a href=\"#7-2-实例属性“遮蔽”原型属性\" class=\"headerlink\" title=\"7.2 实例属性“遮蔽”原型属性\"></a>7.2 实例属性 “遮蔽” 原型属性</h3><p>如果实例有一个和原型同名的属性，实例属性会 “覆盖” 原型属性（这叫 “属性遮蔽”）：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\"><span class=\"comment\">// 原型上的 name 属性</span></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">name</span> = <span class=\"string\">'原型默认名'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实例上的 name 属性（和原型同名）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">'实例自定义名'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 访问时会优先用实例的属性</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person.<span class=\"property\">name</span>); <span class=\"comment\">// 实例自定义名</span></span><br><span class=\"line\"><span class=\"comment\">// 要访问原型的属性，需要手动找原型</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(person).<span class=\"property\">name</span>); <span class=\"comment\">// 原型默认名</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"7-3-循环引用：导致栈溢出\"><a href=\"#7-3-循环引用：导致栈溢出\" class=\"headerlink\" title=\"7.3 循环引用：导致栈溢出\"></a>7.3 循环引用：导致栈溢出</h3><p>如果两个构造函数的原型互相指向对方，会形成 “循环原型链”，创建实例时会报错：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">A</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">B</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// A 的原型指向 B 的实例</span></span><br><span class=\"line\">A.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title function_\">B</span>();</span><br><span class=\"line\"><span class=\"comment\">// B 的原型指向 A 的实例 → 循环引用！</span></span><br><span class=\"line\">B.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title function_\">A</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试创建实例：会触发无限递归，栈溢出</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> <span class=\"title function_\">A</span>();</span><br><span class=\"line\">} <span class=\"keyword\">catch</span> (e) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(e.<span class=\"property\">message</span>); <span class=\"comment\">// Maximum call stack size exceeded</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"八、原型链最佳实践：写代码更安全\"><a href=\"#八、原型链最佳实践：写代码更安全\" class=\"headerlink\" title=\"八、原型链最佳实践：写代码更安全\"></a>八、原型链最佳实践：写代码更安全</h2><ol>\n<li><p><strong>优先用 Class 语法</strong>：<code>class</code> 和 <code>extends</code> 比 ES5 手动改原型更清晰，不容易出错，比如：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> {}</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rabbit</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Animal</span> {}</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p><strong>不用 <code>__proto__</code>，用标准方法操作原型</strong>：</p>\n<ul>\n<li>查原型：<code>Object.getPrototypeOf(obj)</code>（替代 <code>obj.__proto__</code>）</li>\n<li>改原型：<code>Object.setPrototypeOf(obj, newProto)</code>（替代 <code>obj.__proto__ = newProto</code>）</li>\n<li>创建带原型的对象：<code>Object.create(proto)</code>（比 <code>new</code> 更灵活）</li>\n</ul>\n</li>\n<li><p><strong>属性和方法分开放</strong>：构造函数里定义 “实例独有的属性”，原型上定义 “所有实例共享的方法”—— 符合内存高效利用的原则：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name; <span class=\"comment\">// 实例独有属性</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {}; <span class=\"comment\">// 共享方法</span></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p><strong>避免修改内置原型</strong>：除非有绝对必要，否则不要给 <code>Array.prototype</code>、<code>Object.prototype</code> 等加方法，防止冲突。</p>\n</li>\n</ol>\n<h2 id=\"最后小测验\"><a href=\"#最后小测验\" class=\"headerlink\" title=\"最后小测验\"></a>最后小测验</h2><p>看看你有没有掌握原型链的核心逻辑，下面代码会输出什么？</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\"><span class=\"keyword\">const</span> f1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Foo</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(f1 <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(f1) === <span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>答案</strong>：<code>true</code>、<code>true</code>、<code>true</code></p>\n<ul>\n<li><code>f1</code> 是 <code>Foo</code> 的实例，<code>Foo.prototype</code> 继承自 <code>Object.prototype</code>，所以 <code>f1 instanceof Object</code> 为 <code>true</code>；</li>\n<li><code>Foo.prototype</code> 是一个普通对象，继承自 <code>Object.prototype</code>，所以 <code>Foo.prototype instanceof Object</code> 为 <code>true</code>；</li>\n<li><code>new Foo()</code> 创建的实例，原型就是 <code>Foo.prototype</code>，所以第三个判断为 <code>true</code>。</li>\n</ul>\n<hr>\n<p>原型链虽然是 JS 的 “底层概念”，但理解它能帮你避开很多隐藏的坑（比如原型污染、属性遮蔽），也能让你更懂 Class 的本质 —— 不是 “新的继承方式”，只是原型链的优雅包装。掌握这些，你对 JS 面向对象的理解会更上一层楼～</p>\n",
            "tags": [
                "JavaScript",
                "性能优化",
                "ES6"
            ]
        },
        {
            "id": "http://toukoxu.github.io/archives/scope-chain/",
            "url": "http://toukoxu.github.io/archives/scope-chain/",
            "title": "作用域链（Scope Chain）：JS 变量查找的 “路线图”",
            "date_published": "2021-03-16T12:46:25.000Z",
            "content_html": "<blockquote>\n<p><strong>作用域链是 JavaScript 查找变量的核心机制</strong> —— 当代码需要访问一个变量时，JS 引擎会沿着 “当前作用域 → 父作用域 → 全局作用域” 的顺序层层查找，这条查找路径就像一张 “路线图”，指引引擎找到目标变量。</p>\n</blockquote>\n<h2 id=\"一、作用域链的本质：静态的查找路径\"><a href=\"#一、作用域链的本质：静态的查找路径\" class=\"headerlink\" title=\"一、作用域链的本质：静态的查找路径\"></a>一、作用域链的本质：静态的查找路径</h2><h3 id=\"1-1-核心概念：从“作用域”到“作用域链”\"><a href=\"#1-1-核心概念：从“作用域”到“作用域链”\" class=\"headerlink\" title=\"1.1 核心概念：从“作用域”到“作用域链”\"></a>1.1 核心概念：从 “作用域” 到 “作用域链”</h3><p>首先要明确：<strong>作用域是变量的 “可访问范围”</strong>（比如函数内部的变量只能在函数内访问），而 “作用域链” 是多个嵌套作用域组成的 “查找链条”。</p>\n<p>比如函数嵌套场景，内部函数会形成包含父函数作用域、祖父函数作用域的链条，最终指向全局作用域：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  graph LR\nA[当前作用域（如 inner 函数）] --&gt; B[父作用域（如 outer 函数）]\nB --&gt; C[祖父作用域（更外层函数）]\nC --&gt; D[...]\nD --&gt; E[全局作用域]\n  </pre></div>\n\n<h3 id=\"1-2-关键特性：作用域链“定义时确定，而非调用时”\"><a href=\"#1-2-关键特性：作用域链“定义时确定，而非调用时”\" class=\"headerlink\" title=\"1.2 关键特性：作用域链“定义时确定，而非调用时”\"></a>1.2 关键特性：作用域链 “定义时确定，而非调用时”</h3><p>这是理解作用域链的核心 —— 函数的作用域链在<strong>函数定义的那一刻就固定了</strong>，和函数什么时候调用、在哪里调用无关。这个特性也是闭包（👉 <a href=\"/archives/closure/\" title=\"闭包（Closure）：JavaScript 里的“记忆小助手”\">闭包（Closure）：JavaScript 里的 “记忆小助手”</a>）能 “记住外部变量” 的底层原因。</p>\n<p>看个例子验证：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">outer</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> outerVar = <span class=\"string\">'我是外层变量'</span>; <span class=\"comment\">// 父作用域的变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// inner 函数在 outer 内部定义，此时就确定了作用域链：inner → outer → 全局</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">inner</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(outerVar); <span class=\"comment\">// 能访问 outerVar，因为作用域链包含 outer 作用域</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> inner; <span class=\"comment\">// 返回 inner 函数（此时 inner 已携带作用域链）</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 outer，拿到 inner 函数（此时 outer 已执行完，但 inner 的作用域链还在）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> innerFunc = <span class=\"title function_\">outer</span>();</span><br><span class=\"line\"><span class=\"title function_\">innerFunc</span>(); <span class=\"comment\">// 输出“我是外层变量”（inner 按定义时的作用域链找到了 outerVar）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<div class=\"note warning flat\"><p><strong>重点：</strong> 作用域链是 “静态” 的 —— 函数定义时就确定，不会因调用位置变化而改变。</p>\n</div>\n\n<h2 id=\"二、作用域链的组成：变量查找的层级结构\"><a href=\"#二、作用域链的组成：变量查找的层级结构\" class=\"headerlink\" title=\"二、作用域链的组成：变量查找的层级结构\"></a>二、作用域链的组成：变量查找的层级结构</h2><p>作用域链由 “嵌套的作用域” 按顺序组成，通常分为以下几层，查找时严格遵循 “从内到外” 的顺序：</p>\n<table>\n<thead>\n<tr>\n<th>层级</th>\n<th>作用域类型</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1️⃣</td>\n<td>局部作用域</td>\n<td>当前执行代码的作用域（如函数内部、<code>if</code>/<code>for</code> 块内）</td>\n<td>函数内用 <code>let</code> 声明的变量</td>\n</tr>\n<tr>\n<td>2️⃣</td>\n<td>父级作用域</td>\n<td>包含当前作用域的外层作用域（如嵌套函数的父函数）</td>\n<td>父函数内的变量</td>\n</tr>\n<tr>\n<td>…</td>\n<td>更多嵌套父级</td>\n<td>层层向外的作用域（如祖父函数、曾祖父函数）</td>\n<td>更外层函数的变量</td>\n</tr>\n<tr>\n<td>🌍</td>\n<td>全局作用域</td>\n<td>最顶层作用域（浏览器中是 <code>window</code>，Node.js 中是 <code>global</code>）</td>\n<td>直接在脚本顶层声明的变量</td>\n</tr>\n</tbody></table>\n<h3 id=\"实际查找过程：按链条顺序查找\"><a href=\"#实际查找过程：按链条顺序查找\" class=\"headerlink\" title=\"实际查找过程：按链条顺序查找\"></a>实际查找过程：按链条顺序查找</h3><p>看一段代码，直观感受变量查找的步骤：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局作用域的变量 🌍</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> globalVar = <span class=\"string\">'我是全局变量'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">outer</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// outer 作用域的变量（父作用域）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> outerVar = <span class=\"string\">'我是外层变量'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">inner</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"comment\">// inner 作用域的变量（当前作用域）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> innerVar = <span class=\"string\">'我是内层变量'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 变量查找过程：</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(innerVar); <span class=\"comment\">// 1. 先查当前作用域 → 找到，直接使用</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(outerVar); <span class=\"comment\">// 2. 当前作用域没有 → 查父作用域（outer）→ 找到</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globalVar); <span class=\"comment\">// 3. 父作用域没有 → 查全局作用域 → 找到</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(notExistVar); <span class=\"comment\">// 4. 全局作用域也没有 → 抛出 ReferenceError</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">inner</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">outer</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"三、作用域链-vs-执行上下文：别搞混的两个概念\"><a href=\"#三、作用域链-vs-执行上下文：别搞混的两个概念\" class=\"headerlink\" title=\"三、作用域链 vs 执行上下文：别搞混的两个概念\"></a>三、作用域链 vs 执行上下文：别搞混的两个概念</h2><p>很多人会把 “作用域链” 和 “执行上下文” 弄混，其实它们是完全不同的概念 —— 一个是 “静态查找路径”，一个是 “动态执行环境”。</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>作用域链</th>\n<th>执行上下文</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>创建时机</strong></td>\n<td>函数<strong>定义时</strong>（静态固定）</td>\n<td>函数<strong>调用时</strong>（动态创建）</td>\n</tr>\n<tr>\n<td><strong>核心内容</strong></td>\n<td>变量的查找顺序（路径）</td>\n<td>当前执行的代码、<code>this</code> 指向、变量对象等</td>\n</tr>\n<tr>\n<td><strong>是否变化</strong></td>\n<td>不变化（定义后固定）</td>\n<td>每次调用都创建新的执行上下文（动态变化）</td>\n</tr>\n<tr>\n<td><strong>生命周期</strong></td>\n<td>和函数生命周期一致（函数存在则链存在）</td>\n<td>函数执行期间存在，执行完后被销毁</td>\n</tr>\n</tbody></table>\n<p>简单说：<strong>作用域链决定 “变量能在哪里找到”</strong>，而<strong>执行上下文决定 “代码当前如何执行”</strong>。执行上下文会包含作用域链，但作用域链本身是独立的静态结构。</p>\n<h2 id=\"四、ES6-块级作用域：让作用域链更精细\"><a href=\"#四、ES6-块级作用域：让作用域链更精细\" class=\"headerlink\" title=\"四、ES6 块级作用域：让作用域链更精细\"></a>四、ES6 块级作用域：让作用域链更精细</h2><p>ES6 之前，JS 只有 “函数作用域” 和 “全局作用域”，<code>var</code> 声明的变量会 “穿透”<code>if</code>、<code>for</code> 等块级结构。ES6 引入的 <code>let</code>/<code>const</code> 解决了这个问题，带来了 “块级作用域”—— 变量只在 <code>{}</code> 包裹的块内有效，也会加入作用域链。</p>\n<h3 id=\"4-1-块级作用域的影响：变量不再“穿透”\"><a href=\"#4-1-块级作用域的影响：变量不再“穿透”\" class=\"headerlink\" title=\"4.1 块级作用域的影响：变量不再“穿透”\"></a>4.1 块级作用域的影响：变量不再 “穿透”</h3><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"keyword\">let</span> blockVar = <span class=\"string\">'我只在块内有效'</span>; <span class=\"comment\">// let 声明的块级变量</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> funcVar = <span class=\"string\">'我在函数内有效（穿透块）'</span>; <span class=\"comment\">// var 声明的函数级变量</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(funcVar); <span class=\"comment\">// 输出“我在函数内有效（穿透块）”（var 不支持块级）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(blockVar); <span class=\"comment\">// 报错 ReferenceError（let 限制在块内，作用域链找不到）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"4-2-块级作用域的查找逻辑\"><a href=\"#4-2-块级作用域的查找逻辑\" class=\"headerlink\" title=\"4.2 块级作用域的查找逻辑\"></a>4.2 块级作用域的查找逻辑</h3><p>块级作用域会成为作用域链的一环，查找时同样遵循 “从内到外”：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">blockExample</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> topVar = <span class=\"string\">'顶层变量（函数内）'</span>; <span class=\"comment\">// 函数作用域的变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">let</span> innerVar = <span class=\"string\">'块内变量'</span>; <span class=\"comment\">// 块级作用域的变量</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(topVar); <span class=\"comment\">// ✅ 块级作用域 → 函数作用域，找到 topVar</span></span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(innerVar); <span class=\"comment\">// ❌ 函数作用域无法向下查找块级作用域，报错</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">blockExample</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"五、作用域链的实战技巧：优化与封装\"><a href=\"#五、作用域链的实战技巧：优化与封装\" class=\"headerlink\" title=\"五、作用域链的实战技巧：优化与封装\"></a>五、作用域链的实战技巧：优化与封装</h2><h3 id=\"5-1-性能优化：减少作用域链查找次数\"><a href=\"#5-1-性能优化：减少作用域链查找次数\" class=\"headerlink\" title=\"5.1 性能优化：减少作用域链查找次数\"></a>5.1 性能优化：减少作用域链查找次数</h3><p>作用域链层级越深，查找变量的速度越慢。如果某个变量需要频繁访问（比如循环中），可以把它 “缓存” 到当前作用域，减少查找次数。在实际项目中，我经常会用到它来优化代码！</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 优化前：每次循环都要沿作用域链查找全局的 document（层级深，慢）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) {</span><br><span class=\"line\">  <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">`item-<span class=\"subst\">${i}</span>`</span>).<span class=\"property\">style</span>.<span class=\"property\">color</span> = <span class=\"string\">'red'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 优化后：把全局的 document 缓存到当前作用域（只查找一次，快）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doc = <span class=\"variable language_\">document</span>; <span class=\"comment\">// 一次查找全局作用域，缓存到当前作用域</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) {</span><br><span class=\"line\">  doc.<span class=\"title function_\">getElementById</span>(<span class=\"string\">`item-<span class=\"subst\">${i}</span>`</span>).<span class=\"property\">style</span>.<span class=\"property\">color</span> = <span class=\"string\">'red'</span>; <span class=\"comment\">// 直接访问当前作用域的 doc</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"5-2-模块模式：用作用域链实现“私有变量”\"><a href=\"#5-2-模块模式：用作用域链实现“私有变量”\" class=\"headerlink\" title=\"5.2 模块模式：用作用域链实现“私有变量”\"></a>5.2 模块模式：用作用域链实现 “私有变量”</h3><p>JS 没有原生的 “私有变量” 语法，但可以通过 “立即执行函数（IIFE）” 创建独立作用域，利用作用域链的 “隔离性” 实现私有变量封装（外部无法访问函数内部变量）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">CounterModule</span> = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 私有变量：只能在 IIFE 内部访问（作用域链限制）</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> privateCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 私有函数：同样只能内部访问</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">privateIncrement</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    privateCount++;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 暴露公共接口：外部只能通过这些方法操作私有变量</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> {</span><br><span class=\"line\">    <span class=\"attr\">increment</span>: <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"title function_\">privateIncrement</span>();</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'当前计数：'</span>, privateCount);</span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"attr\">reset</span>: <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      privateCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'计数已重置'</span>);</span><br><span class=\"line\">    },</span><br><span class=\"line\">  };</span><br><span class=\"line\">})();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用公共接口</span></span><br><span class=\"line\"><span class=\"title class_\">CounterModule</span>.<span class=\"title function_\">increment</span>(); <span class=\"comment\">// 输出“当前计数：1”</span></span><br><span class=\"line\"><span class=\"title class_\">CounterModule</span>.<span class=\"title function_\">increment</span>(); <span class=\"comment\">// 输出“当前计数：2”</span></span><br><span class=\"line\"><span class=\"title class_\">CounterModule</span>.<span class=\"title function_\">reset</span>(); <span class=\"comment\">// 输出“计数已重置”</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试访问私有变量：无法找到（作用域链不包含 IIFE 内部）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">CounterModule</span>.<span class=\"property\">privateCount</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"六、常见陷阱：避开作用域链的坑\"><a href=\"#六、常见陷阱：避开作用域链的坑\" class=\"headerlink\" title=\"六、常见陷阱：避开作用域链的坑\"></a>六、常见陷阱：避开作用域链的坑</h2><h3 id=\"6-1-循环中的变量问题（var-vs-let）\"><a href=\"#6-1-循环中的变量问题（var-vs-let）\" class=\"headerlink\" title=\"6.1 循环中的变量问题（var vs let）\"></a>6.1 循环中的变量问题（var vs let）</h3><p>ES6 之前用 <code>var</code> 声明循环变量，会因 <code>var</code> 没有块级作用域导致 “所有回调共享同一个变量”；用 <code>let</code> 则会为每次循环创建独立的块级作用域，解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 问题代码（var 无块级作用域）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) {</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 输出 3、3、3（所有回调共享全局的 i，循环结束后 i=3）</span></span><br><span class=\"line\">  }, <span class=\"number\">100</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解决方案1：用 let 创建块级作用域</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) {</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 输出 0、1、2（每次循环有独立的 i）</span></span><br><span class=\"line\">  }, <span class=\"number\">100</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解决方案2：ES5 兼容方案（立即执行函数创建作用域）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) {</span><br><span class=\"line\">  (<span class=\"keyword\">function</span> (<span class=\"params\">j</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// j 是每次循环的 i 的副本，存在独立作用域</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(j); <span class=\"comment\">// 输出 0、1、2</span></span><br><span class=\"line\">    }, <span class=\"number\">100</span>);</span><br><span class=\"line\">  })(i);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"6-2-变量遮蔽（Variable-Shadowing）\"><a href=\"#6-2-变量遮蔽（Variable-Shadowing）\" class=\"headerlink\" title=\"6.2 变量遮蔽（Variable Shadowing）\"></a>6.2 变量遮蔽（Variable Shadowing）</h3><p>如果内层作用域的变量名和外层作用域一致，内层变量会 “遮蔽” 外层变量（查找时找到内层变量后就停止，不会继续向上找）。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">'全局消息'</span>; <span class=\"comment\">// 外层变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">showMessage</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> message = <span class=\"string\">'局部消息'</span>; <span class=\"comment\">// 内层变量，遮蔽外层的 message</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message); <span class=\"comment\">// 输出“局部消息”（找到内层变量后停止查找）</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">showMessage</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(message); <span class=\"comment\">// 输出“全局消息”（外层变量未被影响）</span></span><br></pre></td></tr></tbody></table></figure>\n\n<div class=\"note warning flat\"><p><strong>注意：</strong> 遮蔽是 “暂时性” 的，只影响内层作用域的查找，不会修改外层变量。</p>\n</div>\n\n<h2 id=\"七、作用域链与内存管理：避免内存泄漏\"><a href=\"#七、作用域链与内存管理：避免内存泄漏\" class=\"headerlink\" title=\"七、作用域链与内存管理：避免内存泄漏\"></a>七、作用域链与内存管理：避免内存泄漏</h2><h3 id=\"7-1-作用域链与垃圾回收\"><a href=\"#7-1-作用域链与垃圾回收\" class=\"headerlink\" title=\"7.1 作用域链与垃圾回收\"></a>7.1 作用域链与垃圾回收</h3><p>JS 的垃圾回收机制（GC）会回收 “不再被引用的变量”。如果作用域链断裂（比如函数执行完后，没有闭包引用其内部变量），作用域内的变量就会被 GC 清理。</p>\n<p>流程如下：</p>\n<div class=\"mermaid-wrap\"><pre class=\"mermaid-src\" hidden=\"\">  graph TD\nA[变量不再被任何作用域引用] --&gt; B[作用域链对该变量的引用断开]\nB --&gt; C[GC 标记该变量为“可回收”]\nC --&gt; D[内存被释放]\n  </pre></div>\n\n<h3 id=\"7-2-常见内存泄漏场景\"><a href=\"#7-2-常见内存泄漏场景\" class=\"headerlink\" title=\"7.2 常见内存泄漏场景\"></a>7.2 常见内存泄漏场景</h3><h4 id=\"（1）意外创建全局变量\"><a href=\"#（1）意外创建全局变量\" class=\"headerlink\" title=\"（1）意外创建全局变量\"></a>（1）意外创建全局变量</h4><p>忘记用 <code>var</code>/<code>let</code>/<code>const</code> 声明变量，变量会自动成为全局变量，挂载到 <code>window</code> 上，作用域链一直包含它，导致无法回收：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createLeak</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 错误：忘记写 let，leak 成为全局变量</span></span><br><span class=\"line\">  leak = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"number\">1000000</span>).<span class=\"title function_\">fill</span>(<span class=\"string\">'大量数据'</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">createLeak</span>(); <span class=\"comment\">// 执行后，leak 一直存在于全局作用域，无法被 GC 回收</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"（2）闭包导致的内存泄漏\"><a href=\"#（2）闭包导致的内存泄漏\" class=\"headerlink\" title=\"（2）闭包导致的内存泄漏\"></a>（2）闭包导致的内存泄漏</h4><p>如果闭包长期被引用（比如挂载到全局），它引用的外层变量（即使很大）也会一直存在于作用域链中，无法回收：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createBigClosure</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 大数组：占用大量内存</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hugeArray = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"number\">1000000</span>).<span class=\"title function_\">fill</span>(<span class=\"string\">'我是大数据'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 闭包：引用了 hugeArray</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(hugeArray.<span class=\"property\">length</span>);</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 闭包被全局变量引用，导致 hugeArray 一直存在于作用域链</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> globalClosure = <span class=\"title function_\">createBigClosure</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote>\n<p>解决办法：不再需要闭包时，手动将其设为 <code>null</code>（<code>globalClosure = null</code>），断开引用，让 GC 能回收 <code>hugeArray</code>。</p>\n</blockquote>\n<hr>\n<p>作用域链是 JS 变量查找的 “底层规则”，理解它不仅能帮你避开 “变量找不到”“变量值不对” 的坑，还能让你更清晰地理解闭包、模块模式等高级特性。<br>记住核心：<strong>作用域链是静态的，定义时确定；查找时从内到外，找到即停</strong> —— 掌握这个规则，就能轻松驾驭 JS 的变量访问逻辑！</p>\n",
            "tags": [
                "JavaScript",
                "性能优化"
            ]
        }
    ]
}