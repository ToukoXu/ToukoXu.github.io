<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JS 事件系统完全指南与性能优化 | Touko</title><meta name="keywords" content="JavaScript,性能优化"><meta name="author" content="Touko"><meta name="copyright" content="Touko"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JS 事件系统完全指南与性能优化"><meta name="application-name" content="JS 事件系统完全指南与性能优化"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JS 事件系统完全指南与性能优化"><meta property="og:url" content="http://toukoxu.github.io/2022/02/01/event/index.html"><meta property="og:site_name" content="Touko"><meta property="og:description" content="在 JavaScript 的世界里，事件就像网页的“交互信号”——用户点击按钮、滚动页面、输入文字，都是通过事件让网页做出反应。今天我们从基础到进阶，把浏览器事件机制拆解开，再聊聊怎么用得更高效，避免常见的性能坑！  一、事件系统：网页的“交互逻辑骨架”1.1 事件流三阶段：从顶层到目标，再回到顶"><meta property="og:locale" content="zh"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/event.webp"><meta property="article:author" content="Touko"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/event.webp"><meta name="description" content="在 JavaScript 的世界里，事件就像网页的“交互信号”——用户点击按钮、滚动页面、输入文字，都是通过事件让网页做出反应。今天我们从基础到进阶，把浏览器事件机制拆解开，再聊聊怎么用得更高效，避免常见的性能坑！  一、事件系统：网页的“交互逻辑骨架”1.1 事件流三阶段：从顶层到目标，再回到顶"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://toukoxu.github.io/2022/02/01/event/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 科技爱好者","🔨 开发一条龙","🌌 Hello World 宇宙","⌨️ 键盘撸猫区","🐱 万物皆可rua"]},
  algolia: {"appId":"SVGIUL6D7W","apiKey":"aee53519dcfc6f122cfe52009938fc1c","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本文最后一次更新为","messageNext":"天前，文章中的某些内容可能已过时！"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Touko","link":"链接: ","source":"来源: Touko","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Touko',
  title: 'JS 事件系统完全指南与性能优化',
  postAI: '',
  pageFillDescription: '一、事件系统：网页的交互逻辑骨架, 1.1 事件流三阶段：从顶层到目标再回到顶层, 1.2 三种事件监听方式：哪种最实用？, 1.3 addEventListener详解：参数怎么用？, 基本语法, 关键参数说明, 二、常用事件类型：按场景分类整理, 先看事件的继承关系, 1. Event（基础事件）, 常用属性, 常用方法, 高频基础事件, 2. UIEvent（用户界面事件）, 2.1 MouseEvent（鼠标事件）, 2.1.1 WheelEvent（滚轮事件）, 2.1.2 DragEvent（拖放事件）, 2.1.3 PointerEvent（指针事件）, 2.2 KeyboardEvent（键盘事件）, 2.3 FocusEvent（焦点事件）, 2.4 TouchEvent（触摸事件）, 2.5 InputEvent（输入事件）, 3. AnimationEvent（动画事件）, 4. TransitionEvent（过渡事件）, 5. ClipboardEvent（剪贴板事件）, 6. CustomEvent（自定义事件）, 用法示例, 三、事件性能优化：避免卡顿、减少浪费, 3.1 高频事件：用防抖（debounce）和节流（throttle）控频率, 防抖（debounce）：连续触发只执行最后一次, 节流（throttle）：固定间隔执行一次, 3.2 多元素事件：用事件委托减少监听器, 反面示例：逐个绑定（低效）, 正面示例：事件委托（高效）, 额外优势：支持动态元素, 3.3 一次性事件：用 once true 自动解绑, 3.4 滚动x2F触摸事件：用 passive true 提升流畅度, 3.5 事件顺序控制：用 capture true 精确控制事件触发顺序（不是常规性能优化的手段）, 3.6 不再需要的事件：用 removeEventListener 及时解绑避免内存泄漏, 正确示例：组件销毁时解绑, 注意点, 3.7 事件选择原则, 四、实战问题：常见坑与解决方案, 4.1 滚动事件触发太频繁页面卡顿, 4.2 移动端点击有 300ms 延迟, 4.3 事件冒泡导致父元素事件误触发, 4.4 单页应用切换组件事件监听器没解绑, 五、现代事件处理技巧：更高效的玩法, 5.1 事件总线（Event Bus）：非关联组件通信, 简单实现事件总线, 5.2 AbortController：现代事件管理, 用 AbortController 取消 fetch 请求, 最后小测验在的世界里事件就像网页的交互信号用户点击按钮滚动页面输入文字都是通过事件让网页做出反应今天我们从基础到进阶把浏览器事件机制拆解开再聊聊怎么用得更高效避免常见的性能坑一事件系统网页的交互逻辑骨架事件流三阶段从顶层到目标再回到顶层事件触发后不是直接定位到目标元素而是会经历捕获目标冒泡三个阶段就像水流先向下流到目标再向上回流捕获阶段目标阶段冒泡阶段捕获阶段事件从开始顺着树向下传递直到目标元素的父级比如点击按钮时先经过再到按钮的父元素目标阶段事件终于到达触发的目标元素比如刚才的按钮冒泡阶段事件从目标元素开始顺着树向上回流回到按钮父三种事件监听方式哪种最实用日常开发中绑定事件主要有三种方式各有优劣我整理成了表格方式示例优点缺点属性绑定写起来快适合简单和混在一起代码难维护无法绑定多个处理函数属性绑定比属性清晰不用混写一个事件只能绑一个函数后面的会覆盖前面的推荐支持绑多个函数能控制事件阶段可手动移除需要手动解绑否则可能内存泄漏实际开发里我几乎只用它的灵活性和控制力是另外两种方式比不了的尤其是复杂项目里多监听器阶段控制这些功能很关键详解参数怎么用基本语法它有三种调用形式核心是控制事件的触发规则基础版事件类型处理函数旧版阶段控制加个布尔值控制捕获冒泡新版选项控制更灵活的配置推荐关键参数说明布尔值旧版控制事件在哪个阶段触发是捕获阶段默认是冒泡阶段和新版功能完全一样对象新版能精细控制事件行为常用选项如下选项类型默认值作用决定事件在哪个阶段触发冒泡阶段捕获阶段时函数只执行一次执行完自动解绑比如点击后失效的按钮时告诉浏览器这个函数不会调用能提升滚动触摸等高频事件的性能配合使用调用就能批量解绑事件二常用事件类型按场景分类整理浏览器事件类型非常多我附上关键属性和用法不用死记需要时查就行先看事件的继承关系所有事件都基于这个基类再衍生出不同场景的事件比如鼠标事件键盘事件等关系如下基础事件所有事件的祖宗提供最基础的属性和方法比如判断事件是否冒泡阻止默认行为等常用属性事件类型如实际触发事件的元素比如点击按钮就是按钮始终为绑定事件的元素比如给父容器绑事件点击子元素时是父容器布尔值判断事件是否会冒泡布尔值判断事件能否用阻止默认行为事件当前阶段事件发生的时间戳事件是否由用户触发还是脚本创建是否已阻止默认行为常用方法阻止默认行为比如阻止表单提交链接跳转可以使用来检查该事件是否支持取消阻止事件继续冒泡或捕获比如点击子元素后父元素的事件不触发阻止其他监听器执行高频基础事件事件触发时机常用场景解析完成不用等图片加载页面初始化逻辑比如绑定事件渲染列表整个页面图片等加载完成处理图片相关逻辑比如获取图片尺寸元素或页面滚动时滚动加载导航栏吸顶窗口或元素大小改变时响应式布局调整比如窗口缩小后重排内容表单点击提交按钮或按回车时表单验证阻止默认提交后用提交用户界面事件继承自处理与浏览器相关的事件特有属性关联的窗口对象事件详情如点击次数鼠标事件继承自处理所有鼠标相关事件比如点击移动滚轮操作都属于这类特有属性屏幕坐标视口坐标文档坐标屏幕坐标目标元素坐标按下的鼠标按钮左键中键右键按下的多个按钮相关元素如时的来源元素具体事件类型事件类型触发时机是否冒泡注意点鼠标按下并释放通常是左键双击会触发两次双击鼠标响应速度比慢慎用鼠标按下释放区分按下和释放的状态比如拖拽开始结束鼠标移动触发频率高需要节流优化鼠标进入离开元素不冒泡子元素不会触发比如鼠标从父元素进子元素不会触发父元素的鼠标进入离开元素或子元素冒泡子元素会触发比如鼠标从父元素进子元素父元素会触发右键菜单滚轮事件继承自处理滚轮触控板滚动事件特有属性水平滚动量像素垂直滚动量像素轴滚动量设备滚动单位像素行页具体事件类型事件类型触发时机注意点滚轮滚动控制滚动方向和速度替代旧的事件拖放事件继承自处理拖放事件特有属性在拖放交互期间传输的数据具体事件类型事件类型触发时机拖动元素含选择的文本下同开始拖动元素拖动操作结束释放鼠标按钮或按下退出键元素拖动到有效放置目标上每几百毫秒拖动的元素进入放置目标拖动的元素离开放置目标在放置目标上放置元素指针事件继承自统一鼠标触摸触控笔事件特有属性唯一指针接触区域尺寸压力值设备类型是否为主指针具体事件类型事件类型触发时机指针按下指针释放指针移动指针进入元素指针离开元素指针进入元素指针离开元素指针中断元素启用捕获后触发捕获被释放后触发键盘事件继承自处理键盘输入事件比如快捷键输入验证等特有属性按键的实际内容比如按是或按回车是按键的物理位置比如按是不管是否按位置不变按键位置标准左侧右侧数字键盘布尔值判断是否是长按重复触发布尔值判断是否在输入法输入中比如中文输入时避免误触发修饰键状态方法检查特定修饰键状态具体事件类型事件触发时机是否冒泡常用场景按下任意键包括功能键监听快捷键比如保存释放按键时取消快捷键状态比如松开后停止批量操作注意事件已过时尽量用替代它支持所有按键类型焦点事件继承自处理元素焦点变化比如表单输入时的交互特有属性相关元素如失去焦点时获得焦点的元素具体事件类型事件类型触发时机是否冒泡注意点元素获得失去焦点不冒泡无法用事件委托元素获得失去焦点冒泡推荐用它做事件委托比如表单所有输入框的焦点处理触摸事件继承自处理触摸屏设备交互特有属性当前所有触摸点当前元素上的触摸点本次事件相关的触摸点具体事件类型事件类型触发时机触摸开始触摸移动触摸结束触摸中断输入事件继承自处理用户输入事件比如实时监听输入框文本域的内容变化比事件更灵敏需要失去焦点才触发特有属性插入的字符拖放或插入删除的数据更改的类型或具体事件类型事件类型触发时机常用场景用户输入实时搜索提示输入字数统计动画事件继承自处理动画相关事件特有属性动画名称动画已运行时间秒关联的伪元素如具体事件类型事件类型触发时机动画开始动画结束动画重复播放动画被取消过渡事件继承自处理过渡效果相关事件特有属性发生过渡的属性过渡已运行时间秒关联的伪元素具体事件类型事件类型触发时机过渡创建时过渡实际开始时过渡完成时过渡被取消时剪贴板事件继承自用于处理剪切板相关信息的事件特有属性受剪贴板操作影响的数据具体事件类型事件类型触发时机复制元素的内容剪切元素的内容将内容粘贴到元素中自定义事件继承自用于创建自定义事件特有属性自定义数据方法初始化自定义事件用法示例创建自定义事件事件名配置可传自定义数据自定义数据通过访问是否冒泡是否可阻止默认行为绑定事件监听收到数据输出触发事件三事件性能优化避免卡顿减少浪费事件处理很容易出性能问题比如滚动拖拽这类高频事件处理不好会让页面卡顿分享几个我实战中验证过的优化技巧高频事件用防抖和节流控频率像这类事件触发频率非常高比如滚动时每秒触发几十次直接执行处理函数会占用大量主线程导致页面卡顿这时候需要用防抖或节流控制执行次数防抖连续触发只执行最后一次比如窗口时用户拖动窗口的过程中不执行等用户停手后再执行一次避免频繁计算防抖最后的胜利者连续触发只执行最后一次用闭包保存定时器每次触发都清空之前的定时器重新计时等毫秒后执行用法窗口时等稳定后再执行窗口大小稳定了执行调整逻辑节流固定间隔执行一次比如滚动加载时不管滚动多快每隔只执行一次避免请求发送太频繁上次执行时间距离上次执行超过才执行更新上次执行时间用法滚动时每隔执行一次滚动中按固定间隔执行多元素事件用事件委托减少监听器如果有很多相同元素需要绑定事件比如列表里的删除按钮一个个绑定会创建大量监听器浪费内存这时候用事件委托把监听器绑在父元素上通过判断是否点击目标元素反面示例逐个绑定低效给每个绑事件元素多的时候很卡正面示例事件委托高效只给父容器绑一个事件不管有多少子元素都能处理判断点击的是不是额外优势支持动态元素如果列表是动态生成的比如加载后新增的项逐个绑定的事件会失效但事件委托能自动处理因为监听器在父容器上新元素只要符合选择器点击就能触发性能秘诀对动态内容使用事件委托是高性能应用的关键一次性事件用自动解绑有些事件只需要执行一次比如点击后弹出提示之后再点无效不用手动解绑加个选项执行完会自动移除监听器可以使用匿名函数自动在调用后删除再点不会触发这是只弹一次的提示滚动触摸事件用提升流畅度浏览器在处理这类事件时会先检查函数是否调用如果有会阻塞滚动导致卡顿如果你的函数不会阻止默认行为加告诉浏览器不用等检查了直接执行能显著提升滚动流畅度滚动事件加提升流畅度滚动中不阻止默认行为注意如果加了再调用会报错因为浏览器已经认定你不会阻止默认行为了事件顺序控制用精确控制事件触发顺序不是常规性能优化的手段在某些特定场景下捕获阶段可能更早地处理事件从而能够阻止事件进一步传播阻止所有后续监听器在捕获阶段早期检查不再需要的事件用及时解绑避免内存泄漏如果元素被删除比如单页应用切换组件但事件监听器没解绑浏览器会一直持有这个函数和元素的引用导致内存泄漏一定要在合适的时机解绑正确示例组件销毁时解绑绑定避免函数内指向错误处理点击逻辑组件销毁时调用解绑事件切换组件时销毁旧组件解绑事件避免内存泄漏注意点匿名函数无法移除要使用具名函数解绑时要和绑定的函数参数完全一致比如绑定的时候用了解绑时也要加否则解不掉绑定加了解绑必须也加否则无效事件选择原则优先使用不会冒泡的事件如替代这样可以减少事件处理函数被意外触发的可能性同时也能减少事件传播带来的性能开销尽管在现代浏览器中这种开销通常很小但要注意它们不能用于事件委托因为不冒泡所以使用场景是直接绑定到目标元素移动端优先指针事件替代使用等事件可以同时支持多种输入方式避免为鼠标和触摸分别写两套事件逻辑这有助于代码维护和减少重复焦点事件使用冒泡版本替代因为和事件不冒泡所以当我们需要在祖先元素上监听焦点变化例如做表单验证时使用冒泡版本的和可以方便地实现事件委托仅需将事件绑定在表单上而不必在每个可聚焦元素上单独绑定事件四实战问题常见坑与解决方案滚动事件触发太频繁页面卡顿问题事件每秒触发几十次处理函数里有操作比如修改样式计算位置导致主线程忙不过来页面卡解决方案用节流控制执行频率比如每隔执行一次复杂计算用包裹让浏览器在重绘时执行避免掉帧能用替代的场景尽量不用滚动事件比如元素进入视口时加载优化后的滚动事件处理用确保在重绘时执行处理操作不使用滚动事件而是使用元素进入视口移动端点击有延迟问题早期移动端浏览器为了判断用户是否双击缩放会在点击后延迟再触发事件导致按钮点击反应慢解决方案加标签禁用缩放推荐简单有效用替代需要处理触摸穿透问题旧项目可用库现在大部分现代浏览器已优化但兼容旧设备时可能需要事件冒泡导致父元素事件误触发问题点击子元素时父元素的同类型事件也会触发比如子按钮和父容器都绑了事件解决方案在子元素的事件处理函数里调用阻止事件继续冒泡子元素事件阻止冒泡父元素事件不触发阻止事件冒泡到父元素子元素被点击父元素事件子元素点击时不会触发父元素被点击单页应用切换组件事件监听器没解绑问题单页应用切换组件时旧组件的事件监听器没解绑导致内存泄漏甚至出现幽灵点击切换后旧组件的事件还在触发解决方案组件销毁时手动解绑事件如前面的示例用批量解绑现代浏览器推荐方案用批量解绑绑定多个事件都用同一个组件销毁时调用批量解绑所有事件五现代事件处理技巧更高效的玩法事件总线非关联组件通信如果两个组件没有直接关系比如兄弟组件跨层级组件可以用事件总线传递消息不用一层层传或用全局状态简单实现事件总线存储事件是事件名是回调函数数组触发事件传事件名和数据执行所有绑定的回调绑定事件传事件名和回调解绑事件可选组件触发事件组件监听事件用户登录了现代事件管理前面提到过能批量解绑事件它还能配合定时器等使用是现代浏览器推荐的资源管理方案用取消请求发起请求传请求被取消了秒后取消请求比如用户点击取消按钮最后小测验当用户点击一个按钮时事件流的哪个阶段最先触发目标阶段冒泡阶段捕获阶段答案捕获阶段事件从向下传递到目标元素先经过捕获阶段再到目标阶段最后是冒泡阶段事件系统是前端交互的核心掌握它不仅能写出流畅的交互还能避免很多隐藏的性能问题建议大家在实际项目中多尝试优化技巧比如用事件委托替代多监听器用提升滚动流畅度这些小改动能让页面体验提升一大截',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-01 20:46:25',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link href="https://fonts.cdnfonts.com/css/shina-baby" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/site/loading.webp"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Touko</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/wechat.webp" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/wechat.webp"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/alipay.webp" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/alipay.webp"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/ES2017-ES8/" style="font-size: 1.05rem;">ES2017(ES8)<sup>1</sup></a><a href="/tags/ES6/" style="font-size: 1.05rem;">ES6<sup>6</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>10</sup></a><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 1.05rem;">性能优化<sup>6</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">August 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">July 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">June 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">February 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">May 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/04/"><span class="card-archive-list-date">April 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/03/"><span class="card-archive-list-date">March 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JavaScript/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JavaScript</span></a><a class="article-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>性能优化</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JS 事件系统完全指南与性能优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-02-01T12:46:25.000Z" title="发表于 2022-02-01 20:46:25">2022-02-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2022-02-01T12:46:25.000Z" title="更新于 2022-02-01 20:46:25">2022-02-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">6.4k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为上海"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>上海</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/event.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://toukoxu.github.io/2022/02/01/event/"><header><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a><a href="/tags/JavaScript/" tabindex="-1" itemprop="url">JavaScript</a><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" tabindex="-1" itemprop="url">性能优化</a><h1 id="CrawlerTitle" itemprop="name headline">JS 事件系统完全指南与性能优化</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Touko</span><time itemprop="dateCreated datePublished" datetime="2022-02-01T12:46:25.000Z" title="发表于 2022-02-01 20:46:25">2022-02-01</time><time itemprop="dateCreated datePublished" datetime="2022-02-01T12:46:25.000Z" title="更新于 2022-02-01 20:46:25">2022-02-01</time></header><blockquote>
<p>在 JavaScript 的世界里，事件就像网页的“交互信号”——用户点击按钮、滚动页面、输入文字，都是通过事件让网页做出反应。今天我们从基础到进阶，把浏览器事件机制拆解开，再聊聊怎么用得更高效，避免常见的性能坑！</p>
</blockquote>
<h2 id="一、事件系统：网页的“交互逻辑骨架”"><a href="#一、事件系统：网页的“交互逻辑骨架”" class="headerlink" title="一、事件系统：网页的“交互逻辑骨架”"></a>一、事件系统：网页的“交互逻辑骨架”</h2><h3 id="1-1-事件流三阶段：从顶层到目标，再回到顶层"><a href="#1-1-事件流三阶段：从顶层到目标，再回到顶层" class="headerlink" title="1.1 事件流三阶段：从顶层到目标，再回到顶层"></a>1.1 事件流三阶段：从顶层到目标，再回到顶层</h3><p>事件触发后，不是直接定位到目标元素，而是会经历“捕获 → 目标 → 冒泡”三个阶段，就像水流先向下流到目标，再向上回流：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  graph LR
A[捕获阶段] --&gt; B[目标阶段] --&gt; C[冒泡阶段]
style A fill:#4CAF50,stroke:#388E3C
style B fill:#2196F3,stroke:#1976D2
style C fill:#FF9800,stroke:#F57C00
  </pre></div>

<ul>
<li><strong>捕获阶段 (Capture Phase)</strong>：事件从 <code>window</code> 开始，顺着 DOM 树向下传递，直到目标元素的父级（比如点击按钮时，先经过 <code>body</code>、<code>div</code>，再到按钮的父元素）</li>
<li><strong>目标阶段 (Target Phase)</strong>：事件终于到达触发的目标元素（比如刚才的按钮）</li>
<li><strong>冒泡阶段 (Bubble Phase)</strong>：事件从目标元素开始，顺着 DOM 树向上“回流”，回到 <code>window</code>（按钮 → 父 <code>div</code>→<code>body</code>→<code>window</code>）</li>
</ul>
<h3 id="1-2-三种事件监听方式：哪种最实用？"><a href="#1-2-三种事件监听方式：哪种最实用？" class="headerlink" title="1.2 三种事件监听方式：哪种最实用？"></a>1.2 三种事件监听方式：哪种最实用？</h3><p>日常开发中，绑定事件主要有三种方式，各有优劣，我整理成了表格：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>示例</th>
<th>👍 优点</th>
<th>👎 缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HTML 属性绑定</strong></td>
<td><code>&lt;button onclick=&quot;handleClick()&quot;&gt;</code></td>
<td>写起来快，适合简单 demo</td>
<td>HTML 和 JS 混在一起，代码难维护；无法绑定多个处理函数</td>
</tr>
<tr>
<td><strong>DOM 属性绑定</strong></td>
<td><code>btn.onclick = handleClick</code></td>
<td>比 HTML 属性清晰，不用混写</td>
<td>一个事件只能绑一个函数，后面的会覆盖前面的</td>
</tr>
<tr>
<td><strong><code>addEventListener</code></strong></td>
<td><code>btn.addEventListener(&#39;click&#39;, handleClick)</code></td>
<td>🏆 推荐！支持绑多个函数；能控制事件阶段；可手动移除</td>
<td>需要手动解绑，否则可能内存泄漏</td>
</tr>
</tbody></table>
<blockquote>
<p>实际开发里，我几乎只用 <code>addEventListener</code>——它的灵活性和控制力是另外两种方式比不了的，尤其是复杂项目里，多监听器、阶段控制这些功能很关键。</p>
</blockquote>
<h3 id="1-3-addEventListener详解：参数怎么用？"><a href="#1-3-addEventListener详解：参数怎么用？" class="headerlink" title="1.3 addEventListener详解：参数怎么用？"></a>1.3 <code>addEventListener</code>详解：参数怎么用？</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>它有三种调用形式，核心是控制事件的触发规则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 基础版：事件类型 + 处理函数</span></span><br><span class="line"><span class="title function_">addEventListener</span>(type, listener);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 旧版阶段控制：加个布尔值控制捕获/冒泡</span></span><br><span class="line"><span class="title function_">addEventListener</span>(type, listener, useCapture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 新版选项控制：更灵活的配置（推荐）</span></span><br><span class="line"><span class="title function_">addEventListener</span>(type, listener, options);</span><br></pre></td></tr></table></figure>

<h4 id="关键参数说明"><a href="#关键参数说明" class="headerlink" title="关键参数说明"></a>关键参数说明</h4><ul>
<li><p><strong><code>useCapture</code>（布尔值，旧版）</strong>：<br>控制事件在哪个阶段触发。<code>true</code> 是捕获阶段，<code>false</code>（默认）是冒泡阶段，和新版 <code>options.capture</code> 功能完全一样。</p>
</li>
<li><p><strong><code>options</code>（对象，新版）</strong>：<br>能精细控制事件行为，常用选项如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>类型</th>
<th>默认值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>capture</code></td>
<td>Boolean</td>
<td><code>false</code></td>
<td>决定事件在哪个阶段触发：<code>false</code>（冒泡阶段）、<code>true</code>（捕获阶段）</td>
</tr>
<tr>
<td><code>once</code></td>
<td>Boolean</td>
<td><code>false</code></td>
<td><code>true</code> 时，函数只执行一次，执行完自动解绑（比如“点击后失效”的按钮）</td>
</tr>
<tr>
<td><code>passive</code></td>
<td>Boolean</td>
<td><code>false</code></td>
<td><code>true</code> 时，告诉浏览器“这个函数不会调用 <code>preventDefault()</code>”，能提升滚动、触摸等高频事件的性能</td>
</tr>
<tr>
<td><code>signal</code></td>
<td>AbortSignal</td>
<td>-</td>
<td>配合 <code>AbortController</code> 使用，调用 <code>abort()</code> 就能批量解绑事件</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="二、常用事件类型：按场景分类整理"><a href="#二、常用事件类型：按场景分类整理" class="headerlink" title="二、常用事件类型：按场景分类整理"></a>二、常用事件类型：按场景分类整理</h2><p>浏览器事件类型非常多，我附上关键属性和用法，不用死记，需要时查就行。</p>
<h3 id="先看事件的继承关系"><a href="#先看事件的继承关系" class="headerlink" title="先看事件的继承关系"></a>先看事件的继承关系</h3><p>所有事件都基于 <code>Event</code> 这个“基类”，再衍生出不同场景的事件，比如鼠标事件、键盘事件等，关系如下：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  classDiagram
class Event {
&lt;&lt;interface&gt;&gt;
+type: string
+bubbles: boolean
+cancelable: boolean
+target: EventTarget
+currentTarget: EventTarget
+eventPhase: number
+timeStamp: DOMHighResTimeStamp
+isTrusted: boolean
+defaultPrevented: boolean
+composed: boolean
+preventDefault() void
+stopPropagation() void
+stopImmediatePropagation() void
+composedPath() EventTarget[]
}

Event &lt;|-- UIEvent
Event &lt;|-- AnimationEvent
Event &lt;|-- TransitionEvent
Event &lt;|-- ClipboardEvent
Event &lt;|-- CustomEvent
Event &lt;|-- ProgressEvent
Event &lt;|-- StorageEvent
Event &lt;|-- MessageEvent
Event &lt;|-- ToggleEvent
Event &lt;|-- SubmitEvent

class UIEvent {
+view: WindowProxy
+detail: number
+sourceCapabilities: InputDeviceCapabilities
}

UIEvent &lt;|-- MouseEvent
UIEvent &lt;|-- KeyboardEvent
UIEvent &lt;|-- FocusEvent
UIEvent &lt;|-- TouchEvent
UIEvent &lt;|-- InputEvent

class MouseEvent {
+screenX: number
+screenY: number
+clientX: number
+clientY: number
+pageX: number
+pageY: number
+offsetX: number
+offsetY: number
+button: number
+buttons: number
+relatedTarget: EventTarget
+altKey: boolean
+ctrlKey: boolean
+shiftKey: boolean
+metaKey: boolean
+getModifierState(key: string) boolean
}

MouseEvent &lt;|-- PointerEvent
MouseEvent &lt;|-- DragEvent
MouseEvent &lt;|-- WheelEvent

class PointerEvent {
+pointerId: number
+width: number
+height: number
+pressure: number
+tangentialPressure: number
+tiltX: number
+tiltY: number
+twist: number
+pointerType: string
+isPrimary: boolean
}

class WheelEvent {
+deltaX: number
+deltaY: number
+deltaZ: number
+deltaMode: number
}

class KeyboardEvent {
+key: string
+code: string
+location: number
+repeat: boolean
+isComposing: boolean
+getModifierState(key: string) boolean
}

class FocusEvent {
+relatedTarget: EventTarget
}

class TouchEvent {
+touches: TouchList
+targetTouches: TouchList
+changedTouches: TouchList
+altKey: boolean
+ctrlKey: boolean
+shiftKey: boolean
+metaKey: boolean
}

class AnimationEvent {
+animationName: string
+elapsedTime: number
+pseudoElement: string
}

class TransitionEvent {
+propertyName: string
+elapsedTime: number
+pseudoElement: string
}

class CustomEvent {
+detail: any
+initCustomEvent() void
}

class InputEvent {
+data: string
+isComposing: boolean
+inputType: string
}

class ClipboardEvent {
+clipboardData: DataTransfer
}

class ProgressEvent {
+lengthComputable: boolean
+loaded: number
+total: number
}

class StorageEvent {
+key: string
+oldValue: any
+newValue: any
+url: string
+storageArea: Storage
}

class MessageEvent {
+data: any
+origin: string
+lastEventId: string
+source: WindowProxy
+ports: MessagePort[]
}

class ToggleEvent {
+newState: string
+oldState: string
}

class DragEvent {
+dataTransfer: DataTransfer
}
  </pre></div>

<h3 id="1-Event（基础事件）"><a href="#1-Event（基础事件）" class="headerlink" title="1. Event（基础事件）"></a>1. Event（基础事件）</h3><p>所有事件的“祖宗”，提供最基础的属性和方法，比如判断事件是否冒泡、阻止默认行为等。</p>
<h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><ul>
<li><code>type</code>：事件类型（如 “click”）</li>
<li><code>target</code>：实际触发事件的元素（比如点击按钮，<code>target</code> 就是按钮）</li>
<li><code>currentTarget</code>：始终为绑定事件的元素（比如给父容器绑事件，点击子元素时，<code>currentTarget</code> 是父容器）</li>
<li><code>bubbles</code>：布尔值，判断事件是否会冒泡</li>
<li><code>cancelable</code>：布尔值，判断事件能否用 <code>preventDefault()</code> 阻止默认行为</li>
<li><code>eventPhase</code>：事件当前阶段（0&#x3D;NONE, 1&#x3D;CAPTURING, 2&#x3D;AT_TARGET, 3&#x3D;BUBBLING）</li>
<li><code>timeStamp</code>：事件发生的时间戳</li>
<li><code>isTrusted</code>：事件是否由用户触发（true）还是脚本创建（false）</li>
<li><code>defaultPrevented</code>：是否已阻止默认行为</li>
</ul>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><code>preventDefault()</code>：阻止默认行为（比如阻止表单提交、链接跳转），可以使用<code>Event.cancelable</code>来检查该事件是否支持取消</li>
<li><code>stopPropagation()</code>：阻止事件继续冒泡或捕获（比如点击子元素后，父元素的事件不触发）</li>
<li><code>stopImmediatePropagation()</code>：阻止其他监听器执行</li>
</ul>
<h4 id="高频基础事件"><a href="#高频基础事件" class="headerlink" title="高频基础事件"></a>高频基础事件</h4><table>
<thead>
<tr>
<th>事件</th>
<th>触发时机</th>
<th>常用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>DOMContentLoaded</code></td>
<td>DOM 解析完成（不用等图片、CSS 加载）</td>
<td>页面初始化逻辑（比如绑定事件、渲染列表）</td>
</tr>
<tr>
<td><code>load</code></td>
<td>整个页面（图片、CSS 等）加载完成</td>
<td>处理图片相关逻辑（比如获取图片尺寸）</td>
</tr>
<tr>
<td><code>scroll</code></td>
<td>元素或页面滚动时</td>
<td>滚动加载、导航栏吸顶</td>
</tr>
<tr>
<td><code>resize</code></td>
<td>窗口或元素大小改变时</td>
<td>响应式布局调整（比如窗口缩小后重排内容）</td>
</tr>
<tr>
<td><code>submit</code></td>
<td>表单点击提交按钮或按回车时</td>
<td>表单验证、阻止默认提交后用 AJAX 提交</td>
</tr>
</tbody></table>
<h3 id="2-UIEvent（用户界面事件）"><a href="#2-UIEvent（用户界面事件）" class="headerlink" title="2. UIEvent（用户界面事件）"></a>2. UIEvent（用户界面事件）</h3><p>继承自<strong>Event</strong>，处理与浏览器 UI 相关的事件。</p>
<p>特有属性：</p>
<ul>
<li><code>view</code>：关联的窗口对象</li>
<li><code>detail</code>：事件详情（如点击次数）</li>
</ul>
<h4 id="2-1-MouseEvent（鼠标事件）"><a href="#2-1-MouseEvent（鼠标事件）" class="headerlink" title="2.1 MouseEvent（鼠标事件）"></a>2.1 MouseEvent（鼠标事件）</h4><p>继承自<strong>UIEvent</strong>，处理所有鼠标相关事件，比如点击、移动、滚轮操作都属于这类。</p>
<p>特有属性：</p>
<ul>
<li><code>screenX</code>, <code>screenY</code>：屏幕坐标</li>
<li><code>clientX</code>, <code>clientY</code>：视口坐标</li>
<li><code>pageX</code>, <code>pageY</code>：文档坐标</li>
<li><code>screenX</code>, <code>screenY</code>：屏幕坐标</li>
<li><code>offsetX</code>, <code>offsetY</code>：目标元素坐标</li>
<li><code>button</code>：按下的鼠标按钮（0&#x3D;左键, 1&#x3D;中键, 2&#x3D;右键）</li>
<li><code>buttons</code>：按下的多个按钮</li>
<li><code>relatedTarget</code>：相关元素（如 mouseover 时的来源元素）</li>
</ul>
<p>具体事件类型：</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>触发时机</th>
<th>是否冒泡</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td><code>click</code></td>
<td>鼠标按下并释放（通常是左键）</td>
<td>✅</td>
<td>双击会触发两次 <code>click</code></td>
</tr>
<tr>
<td><code>dblclick</code></td>
<td>双击鼠标</td>
<td>✅</td>
<td>响应速度比 <code>click</code> 慢，慎用</td>
</tr>
<tr>
<td><code>mousedown</code>&#x2F;<code>mouseup</code></td>
<td>鼠标按下&#x2F;释放</td>
<td>✅</td>
<td>区分按下和释放的状态（比如拖拽开始&#x2F;结束）</td>
</tr>
<tr>
<td><code>mousemove</code></td>
<td>鼠标移动</td>
<td>✅</td>
<td>触发频率高，需要节流优化</td>
</tr>
<tr>
<td><code>mouseenter</code>&#x2F;<code>mouseleave</code></td>
<td>鼠标进入&#x2F;离开元素</td>
<td>❌</td>
<td>不冒泡，子元素不会触发（比如鼠标从父元素进子元素，不会触发父元素的 <code>mouseleave</code>）</td>
</tr>
<tr>
<td><code>mouseover</code>&#x2F;<code>mouseout</code></td>
<td>鼠标进入&#x2F;离开元素或子元素</td>
<td>✅</td>
<td>冒泡，子元素会触发（比如鼠标从父元素进子元素，父元素会触发 <code>mouseout</code>）</td>
</tr>
<tr>
<td><code>contextmenu</code></td>
<td>右键菜单</td>
<td>✅</td>
<td></td>
</tr>
</tbody></table>
<h5 id="2-1-1-WheelEvent（滚轮事件）"><a href="#2-1-1-WheelEvent（滚轮事件）" class="headerlink" title="2.1.1 WheelEvent（滚轮事件）"></a>2.1.1 WheelEvent（滚轮事件）</h5><p>继承自<strong>MouseEvent</strong>，处理滚轮&#x2F;触控板滚动事件。</p>
<p>特有属性：</p>
<ul>
<li><code>deltaX</code>：水平滚动量（像素）</li>
<li><code>deltaY</code>：垂直滚动量（像素）</li>
<li><code>deltaZ</code>：Z 轴滚动量（3D 设备）</li>
<li><code>deltaMode</code>：滚动单位（0&#x3D;像素, 1&#x3D;行, 2&#x3D;页）</li>
</ul>
<p>具体事件类型：</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>触发时机</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td><code>wheel</code></td>
<td>滚轮滚动</td>
<td>控制滚动方向和速度（替代旧的 <code>mousewheel</code> 事件）</td>
</tr>
</tbody></table>
<h5 id="2-1-2-DragEvent（拖放事件）"><a href="#2-1-2-DragEvent（拖放事件）" class="headerlink" title="2.1.2 DragEvent（拖放事件）"></a>2.1.2 DragEvent（拖放事件）</h5><p>继承自<strong>MouseEvent</strong>，处理拖放事件。</p>
<p>特有属性：</p>
<ul>
<li><code>dataTransfer</code>：在拖放交互期间传输的数据</li>
</ul>
<p>具体事件类型：</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td><code>drag</code></td>
<td>拖动元素（含选择的文本，下同）</td>
</tr>
<tr>
<td><code>dragstart</code>, <code>dragend</code></td>
<td>开始拖动元素, 拖动操作结束（释放鼠标按钮或按下退出键）</td>
</tr>
<tr>
<td><code>dragover</code></td>
<td>元素拖动到有效放置目标上（每几百毫秒）</td>
</tr>
<tr>
<td><code>dragenter</code>, <code>dragleave</code></td>
<td>拖动的元素进入放置目标, 拖动的元素离开放置目标</td>
</tr>
<tr>
<td><code>drop</code></td>
<td>在放置目标上放置元素</td>
</tr>
</tbody></table>
<h5 id="2-1-3-PointerEvent（指针事件）"><a href="#2-1-3-PointerEvent（指针事件）" class="headerlink" title="2.1.3 PointerEvent（指针事件）"></a>2.1.3 PointerEvent（指针事件）</h5><p>继承自<strong>MouseEvent</strong>，统一鼠标、触摸、触控笔事件。</p>
<p>特有属性：</p>
<ul>
<li><code>pointerId</code>：唯一指针 ID</li>
<li><code>width</code>, <code>height</code>：接触区域尺寸</li>
<li><code>pressure</code>：压力值（0-1）</li>
<li><code>pointerType</code>：设备类型（”mouse”, “pen”, “touch”）</li>
<li><code>isPrimary</code>：是否为主指针</li>
</ul>
<p>具体事件类型：</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td><code>pointerdown</code>, <code>pointerup</code></td>
<td>指针按下, 指针释放</td>
</tr>
<tr>
<td><code>pointermove</code></td>
<td>指针移动</td>
</tr>
<tr>
<td><code>pointerover</code>, <code>pointerout</code></td>
<td>指针进入元素, 指针离开元素</td>
</tr>
<tr>
<td><code>pointerenter</code>, <code>pointerleave</code></td>
<td>指针进入元素, 指针离开元素</td>
</tr>
<tr>
<td><code>pointercancel</code></td>
<td>指针中断</td>
</tr>
<tr>
<td><code>gotpointercapture</code>, <code>lostpointercapture</code></td>
<td>元素启用捕获后触发, 捕获被释放后触发</td>
</tr>
</tbody></table>
<h4 id="2-2-KeyboardEvent（键盘事件）"><a href="#2-2-KeyboardEvent（键盘事件）" class="headerlink" title="2.2 KeyboardEvent（键盘事件）"></a>2.2 KeyboardEvent（键盘事件）</h4><p>继承自<strong>UIEvent</strong>，处理键盘输入事件，比如快捷键、输入验证等。</p>
<p>特有属性：</p>
<ul>
<li><code>key</code>：按键的实际内容（比如按“A”是 <code>&quot;a&quot;</code> 或 <code>&quot;A&quot;</code>，按回车是 <code>&quot;Enter&quot;</code>）</li>
<li><code>code</code>：按键的物理位置（比如按“A”是 <code>&quot;KeyA&quot;</code>，不管是否按 Shift，位置不变）</li>
<li><code>location</code>：按键位置（0&#x3D;标准, 1&#x3D;左侧, 2&#x3D;右侧, 3&#x3D;数字键盘）</li>
<li><code>repeat</code>：布尔值，判断是否是长按重复触发</li>
<li><code>isComposing</code>：布尔值，判断是否在输入法输入中（比如中文输入时避免误触发）</li>
<li>修饰键状态：<code>altKey</code>, <code>ctrlKey</code>, <code>shiftKey</code>, <code>metaKey</code></li>
</ul>
<p>方法：</p>
<ul>
<li><code>getModifierState(key)</code>：检查特定修饰键状态</li>
</ul>
<p>具体事件类型：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发时机</th>
<th>是否冒泡</th>
<th>常用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>keydown</code></td>
<td>按下任意键（包括功能键）</td>
<td>✅</td>
<td>监听快捷键（比如 Ctrl+S 保存）</td>
</tr>
<tr>
<td><code>keyup</code></td>
<td>释放按键时</td>
<td>✅</td>
<td>取消快捷键状态（比如松开 Ctrl 后停止批量操作）</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：<code>keypress</code> 事件已过时，尽量用 <code>keydown</code> 替代，它支持所有按键类型。</p>
</blockquote>
<h4 id="2-3-FocusEvent（焦点事件）"><a href="#2-3-FocusEvent（焦点事件）" class="headerlink" title="2.3 FocusEvent（焦点事件）"></a>2.3 FocusEvent（焦点事件）</h4><p>继承自<strong>UIEvent</strong>，处理元素焦点变化，比如表单输入时的交互。</p>
<p>特有属性：</p>
<ul>
<li><code>relatedTarget</code>：相关元素（如失去焦点时获得焦点的元素）</li>
</ul>
<p>具体事件类型：</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>触发时机</th>
<th>是否冒泡</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td><code>focus</code>&#x2F;<code>blur</code></td>
<td>元素获得&#x2F;失去焦点</td>
<td>❌</td>
<td>不冒泡，无法用事件委托</td>
</tr>
<tr>
<td><code>focusin</code>&#x2F;<code>focusout</code></td>
<td>元素获得&#x2F;失去焦点</td>
<td>✅</td>
<td>冒泡，推荐用它做事件委托（比如表单所有输入框的焦点处理）</td>
</tr>
</tbody></table>
<h4 id="2-4-TouchEvent（触摸事件）"><a href="#2-4-TouchEvent（触摸事件）" class="headerlink" title="2.4 TouchEvent（触摸事件）"></a>2.4 TouchEvent（触摸事件）</h4><p>继承自<strong>UIEvent</strong>，处理触摸屏设备交互。</p>
<p>特有属性：</p>
<ul>
<li><code>touches</code>：当前所有触摸点</li>
<li><code>targetTouches</code>：当前元素上的触摸点</li>
<li><code>changedTouches</code>：本次事件相关的触摸点</li>
</ul>
<p>具体事件类型：</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td><code>touchstart</code></td>
<td>触摸开始</td>
</tr>
<tr>
<td><code>touchmove</code></td>
<td>触摸移动</td>
</tr>
<tr>
<td><code>touchend</code></td>
<td>触摸结束</td>
</tr>
<tr>
<td><code>touchcancel</code></td>
<td>触摸中断</td>
</tr>
</tbody></table>
<h4 id="2-5-InputEvent（输入事件）"><a href="#2-5-InputEvent（输入事件）" class="headerlink" title="2.5 InputEvent（输入事件）"></a>2.5 InputEvent（输入事件）</h4><p>继承自<strong>UIEvent</strong>，处理用户输入事件，比如实时监听输入框、文本域的内容变化，比 <code>change</code> 事件更灵敏（<code>change</code> 需要失去焦点才触发）。</p>
<p>特有属性：</p>
<ul>
<li><code>data</code>：插入的字符</li>
<li><code>dataTransfer</code>：拖放或插入&#x2F;删除的数据</li>
<li><code>inputType</code>：更改的类型（<code>inserting</code>或<code>deleting</code>）</li>
</ul>
<p>具体事件类型：</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>触发时机</th>
<th>常用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>input</code></td>
<td>用户输入</td>
<td>实时搜索提示、输入字数统计</td>
</tr>
</tbody></table>
<h3 id="3-AnimationEvent（动画事件）"><a href="#3-AnimationEvent（动画事件）" class="headerlink" title="3. AnimationEvent（动画事件）"></a>3. AnimationEvent（动画事件）</h3><p>继承自<strong>Event</strong>，处理 CSS 动画相关事件。</p>
<p>特有属性：</p>
<ul>
<li><code>animationName</code>：动画名称</li>
<li><code>elapsedTime</code>：动画已运行时间（秒）</li>
<li><code>pseudoElement</code>：关联的伪元素（如 “::before”）</li>
</ul>
<p>具体事件类型：</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td><code>animationstart</code>, <code>animationend</code></td>
<td>动画开始, 动画结束</td>
</tr>
<tr>
<td><code>animationiteration</code></td>
<td>动画重复播放</td>
</tr>
<tr>
<td><code>animationcancel</code></td>
<td>动画被取消</td>
</tr>
</tbody></table>
<h3 id="4-TransitionEvent（过渡事件）"><a href="#4-TransitionEvent（过渡事件）" class="headerlink" title="4. TransitionEvent（过渡事件）"></a>4. TransitionEvent（过渡事件）</h3><p>继承自<strong>Event</strong>，处理 CSS 过渡效果相关事件。</p>
<p>特有属性：</p>
<ul>
<li><code>propertyName</code>：发生过渡的 CSS 属性</li>
<li><code>elapsedTime</code>：过渡已运行时间（秒）</li>
<li><code>pseudoElement</code>：关联的伪元素</li>
</ul>
<p>具体事件类型：</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td><code>transitionrun</code></td>
<td>过渡创建时</td>
</tr>
<tr>
<td><code>transitionstart</code></td>
<td>过渡实际开始时</td>
</tr>
<tr>
<td><code>transitionend</code></td>
<td>过渡完成时</td>
</tr>
<tr>
<td><code>transitioncancel</code></td>
<td>过渡被取消时</td>
</tr>
</tbody></table>
<h3 id="5-ClipboardEvent（剪贴板事件）"><a href="#5-ClipboardEvent（剪贴板事件）" class="headerlink" title="5. ClipboardEvent（剪贴板事件）"></a>5. ClipboardEvent（剪贴板事件）</h3><p>继承自<strong>Event</strong>，用于处理剪切板相关信息的事件。</p>
<p>特有属性：</p>
<ul>
<li><code>clipboardData</code>：受剪贴板操作影响的数据</li>
</ul>
<p>具体事件类型：</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td><code>copy</code></td>
<td>复制元素的内容</td>
</tr>
<tr>
<td><code>cut</code></td>
<td>剪切元素的内容</td>
</tr>
<tr>
<td><code>paste</code></td>
<td>将内容粘贴到元素中</td>
</tr>
</tbody></table>
<h3 id="6-CustomEvent（自定义事件）"><a href="#6-CustomEvent（自定义事件）" class="headerlink" title="6. CustomEvent（自定义事件）"></a>6. CustomEvent（自定义事件）</h3><p>继承自<strong>Event</strong>，用于创建自定义事件。</p>
<p>特有属性：</p>
<ul>
<li><code>detail</code>：自定义数据</li>
</ul>
<p>方法：</p>
<ul>
<li><code>initCustomEvent()</code>：初始化自定义事件</li>
</ul>
<h4 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建自定义事件：事件名 + 配置（可传自定义数据）</span></span><br><span class="line"><span class="keyword">const</span> dataLoadedEvent = <span class="keyword">new</span> <span class="title class_">CustomEvent</span>(<span class="string">&#x27;data-loaded&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">detail</span>: &#123; <span class="attr">list</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;, <span class="comment">// 自定义数据，通过 event.detail 访问</span></span><br><span class="line">  <span class="attr">bubbles</span>: <span class="literal">true</span>, <span class="comment">// 是否冒泡</span></span><br><span class="line">  <span class="attr">cancelable</span>: <span class="literal">true</span>, <span class="comment">// 是否可阻止默认行为</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定事件监听</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;data-loaded&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到数据：&#x27;</span>, event.<span class="property">detail</span>.<span class="property">list</span>); <span class="comment">// 输出 [1,2,3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 触发事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(dataLoadedEvent);</span><br></pre></td></tr></table></figure>

<h2 id="三、事件性能优化：避免卡顿、减少浪费"><a href="#三、事件性能优化：避免卡顿、减少浪费" class="headerlink" title="三、事件性能优化：避免卡顿、减少浪费"></a>三、事件性能优化：避免卡顿、减少浪费</h2><p>事件处理很容易出性能问题，比如滚动、拖拽这类高频事件，处理不好会让页面卡顿。分享几个我实战中验证过的优化技巧：</p>
<h3 id="3-1-高频事件：用防抖（debounce）和节流（throttle）控频率"><a href="#3-1-高频事件：用防抖（debounce）和节流（throttle）控频率" class="headerlink" title="3.1 高频事件：用防抖（debounce）和节流（throttle）控频率"></a>3.1 高频事件：用防抖（debounce）和节流（throttle）控频率</h3><p>像 <code>scroll</code>、<code>mousemove</code>、<code>resize</code> 这类事件，触发频率非常高（比如滚动时每秒触发几十次），直接执行处理函数会占用大量主线程，导致页面卡顿。这时候需要用“防抖”或“节流”控制执行次数。</p>
<h4 id="防抖（debounce）：连续触发只执行最后一次"><a href="#防抖（debounce）：连续触发只执行最后一次" class="headerlink" title="防抖（debounce）：连续触发只执行最后一次"></a>防抖（debounce）：连续触发只执行最后一次</h4><p>比如窗口 resize 时，用户拖动窗口的过程中不执行，等用户停手后再执行一次，避免频繁计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖：最后的胜利者（连续触发只执行最后一次）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer; <span class="comment">// 用闭包保存定时器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 每次触发都清空之前的定时器</span></span><br><span class="line">    <span class="comment">// 重新计时，等 delay 毫秒后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args), delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：窗口 resize 时，等 200ms 稳定后再执行</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;resize&#x27;</span>,</span><br><span class="line">  <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;窗口大小稳定了，执行调整逻辑&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">200</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="节流（throttle）：固定间隔执行一次"><a href="#节流（throttle）：固定间隔执行一次" class="headerlink" title="节流（throttle）：固定间隔执行一次"></a>节流（throttle）：固定间隔执行一次</h4><p>比如滚动加载时，不管滚动多快，每隔 100ms 只执行一次，避免请求发送太频繁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>; <span class="comment">// 上次执行时间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="comment">// 距离上次执行超过 interval 才执行</span></span><br><span class="line">    <span class="keyword">if</span> (now - lastTime &gt;= interval) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      lastTime = now; <span class="comment">// 更新上次执行时间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法：滚动时每隔 100ms 执行一次</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;scroll&#x27;</span>,</span><br><span class="line">  <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;滚动中，按固定间隔执行&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-多元素事件：用事件委托减少监听器"><a href="#3-2-多元素事件：用事件委托减少监听器" class="headerlink" title="3.2 多元素事件：用事件委托减少监听器"></a>3.2 多元素事件：用事件委托减少监听器</h3><p>如果有很多相同元素需要绑定事件（比如列表里的删除按钮），一个个绑定会创建大量监听器，浪费内存。这时候用“事件委托”，把监听器绑在父元素上，通过 <code>event.target</code> 判断是否点击目标元素。</p>
<h4 id="反面示例：逐个绑定（低效）"><a href="#反面示例：逐个绑定（低效）" class="headerlink" title="反面示例：逐个绑定（低效）"></a>反面示例：逐个绑定（低效）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给每个 .remove-btn 绑事件，元素多的时候很卡</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.remove-btn&#x27;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">btn</span>) =&gt;</span> &#123;</span><br><span class="line">  btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    btn.<span class="property">parentElement</span>.<span class="title function_">remove</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="正面示例：事件委托（高效）"><a href="#正面示例：事件委托（高效）" class="headerlink" title="正面示例：事件委托（高效）"></a>正面示例：事件委托（高效）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只给父容器绑一个事件，不管有多少子元素都能处理</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list-container&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断点击的是不是 .remove-btn</span></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="title function_">matches</span>(<span class="string">&#x27;.remove-btn&#x27;</span>)) &#123;</span><br><span class="line">    event.<span class="property">target</span>.<span class="property">parentElement</span>.<span class="title function_">remove</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="额外优势：支持动态元素"><a href="#额外优势：支持动态元素" class="headerlink" title="额外优势：支持动态元素"></a>额外优势：支持动态元素</h4><p>如果列表是动态生成的（比如 AJAX 加载后新增的项），逐个绑定的事件会失效，但事件委托能自动处理——因为监听器在父容器上，新元素只要符合选择器，点击就能触发。</p>
<div class="note success flat"><p><strong>性能秘诀：</strong> 对<mark>动态内容</mark>使用<mark>事件委托</mark>是高性能Web应用的关键！</p></div>

<h3 id="3-3-一次性事件：用-once-true-自动解绑"><a href="#3-3-一次性事件：用-once-true-自动解绑" class="headerlink" title="3.3 一次性事件：用 once: true 自动解绑"></a>3.3 一次性事件：用 <code>once: true</code> 自动解绑</h3><p>有些事件只需要执行一次（比如“点击后弹出提示，之后再点无效”），不用手动解绑，加个 <code>once: true</code> 选项，执行完会自动移除监听器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用匿名函数，自动在调用后删除，再点不会触发</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.tips-btn&#x27;</span>).<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;这是只弹一次的提示&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-滚动-触摸事件：用-passive-true-提升流畅度"><a href="#3-4-滚动-触摸事件：用-passive-true-提升流畅度" class="headerlink" title="3.4 滚动&#x2F;触摸事件：用 passive: true 提升流畅度"></a>3.4 滚动&#x2F;触摸事件：用 <code>passive: true</code> 提升流畅度</h3><p>浏览器在处理 <code>scroll</code>、<code>touchmove</code> 这类事件时，会先检查函数是否调用 <code>preventDefault()</code>，如果有，会阻塞滚动，导致卡顿。如果你的函数不会阻止默认行为，加 <code>passive: true</code> 告诉浏览器“不用等检查了，直接执行”，能显著提升滚动流畅度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动事件加 passive: true，提升流畅度</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;scroll&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;滚动中，不阻止默认行为&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果加了 <code>passive: true</code>，再调用 <code>preventDefault()</code> 会报错，因为浏览器已经认定你不会阻止默认行为了。</p>
</blockquote>
<h3 id="3-5-事件顺序控制：用-capture-true-精确控制事件触发顺序（不是常规性能优化的手段）"><a href="#3-5-事件顺序控制：用-capture-true-精确控制事件触发顺序（不是常规性能优化的手段）" class="headerlink" title="3.5 事件顺序控制：用 capture: true 精确控制事件触发顺序（不是常规性能优化的手段）"></a>3.5 事件顺序控制：用 <code>capture: true</code> 精确控制事件触发顺序（不是常规性能优化的手段）</h3><p>在某些特定场景下，捕获阶段可能更早地处理事件，从而能够阻止事件进一步传播。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">target</span>.<span class="title function_">matches</span>(<span class="string">&#x27;.should-block&#x27;</span>)) &#123;</span><br><span class="line">      e.<span class="title function_">stopPropagation</span>(); <span class="comment">// 阻止所有后续监听器</span></span><br><span class="line">      e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">capture</span>: <span class="literal">true</span> &#125; <span class="comment">// 在捕获阶段早期检查</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="3-6-不再需要的事件：用-removeEventListener-及时解绑避免内存泄漏"><a href="#3-6-不再需要的事件：用-removeEventListener-及时解绑避免内存泄漏" class="headerlink" title="3.6 不再需要的事件：用 removeEventListener 及时解绑避免内存泄漏"></a>3.6 不再需要的事件：用 <code>removeEventListener</code> 及时解绑避免内存泄漏</h3><p>如果元素被删除（比如单页应用切换组件），但事件监听器没解绑，浏览器会一直持有这个函数和元素的引用，导致内存泄漏。一定要在合适的时机解绑。</p>
<h4 id="正确示例：组件销毁时解绑"><a href="#正确示例：组件销毁时解绑" class="headerlink" title="正确示例：组件销毁时解绑"></a>正确示例：组件销毁时解绑</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListComponent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 绑定this，避免函数内this指向错误</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list-container&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleClick</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理点击逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件销毁时调用，解绑事件</span></span><br><span class="line">  <span class="title function_">destroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleClick</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换组件时，销毁旧组件</span></span><br><span class="line"><span class="keyword">const</span> oldList = <span class="keyword">new</span> <span class="title class_">ListComponent</span>();</span><br><span class="line">oldList.<span class="title function_">destroy</span>(); <span class="comment">// 解绑事件，避免内存泄漏</span></span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol>
<li><p>匿名函数无法移除，要使用具名函数</p>
</li>
<li><p>解绑时要和绑定的函数、参数完全一致<br>比如绑定的时候用了 <code>capture: true</code>，解绑时也要加，否则解不掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定：加了 capture: true</span></span><br><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑：必须也加 capture: true，否则无效</span></span><br><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-7-事件选择原则"><a href="#3-7-事件选择原则" class="headerlink" title="3.7 事件选择原则"></a>3.7 事件选择原则</h3><ul>
<li><strong>优先使用不会冒泡的事件</strong>：如 <code>mouseenter/mouseleave</code> 替代 <code>mouseover/mouseout</code><blockquote>
<p>这样可以减少事件处理函数被意外触发的可能性，同时也能减少事件传播带来的性能开销（尽管在现代浏览器中这种开销通常很小）。但要注意，它们不能用于事件委托（因为不冒泡），所以使用场景是直接绑定到目标元素。</p>
</blockquote>
</li>
<li><strong>移动端优先指针事件</strong>：<code>pointerdown</code> 替代 <code>mousedown/touchstart</code><blockquote>
<p>使用<code>pointerdown</code>等事件可以同时支持多种输入方式，避免为鼠标和触摸分别写两套事件逻辑。这有助于代码维护和减少重复。</p>
</blockquote>
</li>
<li><strong>焦点事件使用冒泡版本</strong>：<code>focusin/focusout</code> 替代 <code>focus/blur</code><blockquote>
<p>因为<code>focus</code>和<code>blur</code>事件不冒泡，所以当我们需要在祖先元素上监听焦点变化（例如做表单验证）时，使用冒泡版本的<code>focusin</code>和<code>focusout</code>可以方便地实现事件委托（仅需将事件绑定在表单上），而不必在每个可聚焦元素上单独绑定事件。</p>
</blockquote>
</li>
</ul>
<h2 id="四、实战问题：常见坑与解决方案"><a href="#四、实战问题：常见坑与解决方案" class="headerlink" title="四、实战问题：常见坑与解决方案"></a>四、实战问题：常见坑与解决方案</h2><h3 id="4-1-滚动事件触发太频繁，页面卡顿"><a href="#4-1-滚动事件触发太频繁，页面卡顿" class="headerlink" title="4.1 滚动事件触发太频繁，页面卡顿"></a>4.1 滚动事件触发太频繁，页面卡顿</h3><p><strong>问题</strong>：<code>scroll</code> 事件每秒触发几十次，处理函数里有 DOM 操作（比如修改样式、计算位置），导致主线程忙不过来，页面卡。<br><strong>解决方案</strong>：</p>
<ol>
<li>用节流控制执行频率（比如每隔 100ms 执行一次）；</li>
<li>复杂计算用 <code>requestAnimationFrame</code> 包裹，让浏览器在重绘时执行，避免掉帧；</li>
<li>能用 <code>IntersectionObserver</code> 替代的场景，尽量不用滚动事件（比如“元素进入视口时加载”）。</li>
</ol>
<p>优化后的滚动事件处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throttledScroll = <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用 requestAnimationFrame 确保在重绘时执行</span></span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理DOM操作</span></span><br><span class="line">    <span class="title function_">updateNavPosition</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, throttledScroll, &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>不使用滚动事件，而是使用<code>IntersectionObserver</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      <span class="comment">// 元素进入视口</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">observer.<span class="title function_">observe</span>(element);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-移动端点击有-300ms-延迟"><a href="#4-2-移动端点击有-300ms-延迟" class="headerlink" title="4.2 移动端点击有 300ms 延迟"></a>4.2 移动端点击有 300ms 延迟</h3><p><strong>问题</strong>：早期移动端浏览器为了判断用户是否双击缩放，会在点击后延迟 300ms 再触发 <code>click</code> 事件，导致按钮点击反应慢。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>加 viewport meta 标签，禁用缩放（推荐，简单有效）；<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>用 <code>touchstart</code>&#x2F;<code>touchend</code> 替代 <code>click</code>（需要处理触摸穿透问题）；</li>
<li>旧项目可用 FastClick 库（现在大部分现代浏览器已优化，但兼容旧设备时可能需要）。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (<span class="string">&#x27;addEventListener&#x27;</span> <span class="keyword">in</span> <span class="variable language_">document</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&#x27;DOMContentLoaded&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">FastClick</span>.<span class="title function_">attach</span>(<span class="variable language_">document</span>.<span class="property">body</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">    );</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-3-事件冒泡导致父元素事件误触发"><a href="#4-3-事件冒泡导致父元素事件误触发" class="headerlink" title="4.3 事件冒泡导致父元素事件误触发"></a>4.3 事件冒泡导致父元素事件误触发</h3><p><strong>问题</strong>：点击子元素时，父元素的同类型事件也会触发（比如子按钮和父容器都绑了 <code>click</code> 事件）。</p>
<p><strong>解决方案</strong>：在子元素的事件处理函数里调用 <code>stopPropagation()</code>，阻止事件继续冒泡。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子元素事件：阻止冒泡，父元素事件不触发</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.child-btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>(); <span class="comment">// 阻止事件冒泡到父元素</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子元素被点击&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父元素事件：子元素点击时不会触发</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.parent-container&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;父元素被点击&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-4-单页应用切换组件，事件监听器没解绑"><a href="#4-4-单页应用切换组件，事件监听器没解绑" class="headerlink" title="4.4 单页应用切换组件，事件监听器没解绑"></a>4.4 单页应用切换组件，事件监听器没解绑</h3><p><strong>问题</strong>：单页应用（SPA）切换组件时，旧组件的事件监听器没解绑，导致内存泄漏，甚至出现“幽灵点击”（切换后旧组件的事件还在触发）。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><p>组件销毁时手动解绑事件（如前面 3.6 的示例）；</p>
</li>
<li><p>用 <code>AbortController</code> 批量解绑（现代浏览器推荐）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案2：用 AbortController 批量解绑</span></span><br><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">const</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定多个事件，都用同一个 signal</span></span><br><span class="line">element1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick1, &#123; signal &#125;);</span><br><span class="line">element2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, handleScroll2, &#123; signal &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件销毁时，调用 abort() 批量解绑所有事件</span></span><br><span class="line">controller.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="五、现代事件处理技巧：更高效的玩法"><a href="#五、现代事件处理技巧：更高效的玩法" class="headerlink" title="五、现代事件处理技巧：更高效的玩法"></a>五、现代事件处理技巧：更高效的玩法</h2><h3 id="5-1-事件总线（Event-Bus）：非关联组件通信"><a href="#5-1-事件总线（Event-Bus）：非关联组件通信" class="headerlink" title="5.1 事件总线（Event Bus）：非关联组件通信"></a>5.1 事件总线（Event Bus）：非关联组件通信</h3><p>如果两个组件没有直接关系（比如兄弟组件、跨层级组件），可以用“事件总线”传递消息，不用一层层传 props 或用全局状态。</p>
<h4 id="简单实现事件总线"><a href="#简单实现事件总线" class="headerlink" title="简单实现事件总线"></a>简单实现事件总线</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventBus</span> = &#123;</span><br><span class="line">  <span class="comment">// 存储事件：key是事件名，value是回调函数数组</span></span><br><span class="line">  <span class="attr">events</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 触发事件：传事件名和数据</span></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">eventName, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[eventName]) &#123;</span><br><span class="line">      <span class="comment">// 执行所有绑定的回调</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[eventName].<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> <span class="title function_">cb</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定事件：传事件名和回调</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[eventName] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[eventName].<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解绑事件（可选）</span></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">eventName, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[eventName] = <span class="variable language_">this</span>.<span class="property">events</span>[eventName].<span class="title function_">filter</span>(</span><br><span class="line">        <span class="function">(<span class="params">cb</span>) =&gt;</span> cb !== callback</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件A：触发事件</span></span><br><span class="line"><span class="title class_">EventBus</span>.<span class="title function_">emit</span>(<span class="string">&#x27;user-login&#x27;</span>, &#123; <span class="attr">username</span>: <span class="string">&#x27;test&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件B：监听事件</span></span><br><span class="line"><span class="title class_">EventBus</span>.<span class="title function_">on</span>(<span class="string">&#x27;user-login&#x27;</span>, <span class="function">(<span class="params">userInfo</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`用户<span class="subst">$&#123;userInfo.username&#125;</span>登录了。`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-2-AbortController：现代事件管理"><a href="#5-2-AbortController：现代事件管理" class="headerlink" title="5.2 AbortController：现代事件管理"></a>5.2 AbortController：现代事件管理</h3><p>前面提到过 <code>AbortController</code> 能批量解绑事件，它还能配合 fetch、定时器等使用，是现代浏览器推荐的“资源管理”方案。</p>
<h4 id="用-AbortController-取消-fetch-请求"><a href="#用-AbortController-取消-fetch-请求" class="headerlink" title="用 AbortController 取消 fetch 请求"></a>用 AbortController 取消 fetch 请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">const</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起fetch请求，传signal</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/data&#x27;</span>, &#123; signal &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.<span class="property">name</span> === <span class="string">&#x27;AbortError&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求被取消了&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3秒后取消请求（比如用户点击“取消”按钮）</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> controller.<span class="title function_">abort</span>(), <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="最后小测验"><a href="#最后小测验" class="headerlink" title="最后小测验"></a>最后小测验</h2><p>当用户点击一个按钮时，事件流的哪个阶段最先触发？<br>A) 目标阶段<br>B) 冒泡阶段<br>C) 捕获阶段</p>
<p><strong>答案</strong>：C) 捕获阶段（事件从 <code>window</code> 向下传递到目标元素，先经过捕获阶段，再到目标阶段，最后是冒泡阶段）</p>
<hr>
<p>事件系统是前端交互的核心，掌握它不仅能写出流畅的交互，还能避免很多隐藏的性能问题。建议大家在实际项目中多尝试优化技巧，比如用事件委托替代多监听器、用 <code>passive</code> 提升滚动流畅度——这些小改动能让页面体验提升一大截！</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/site/avatar.webp" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/site/avatar.webp" title="头像" alt="头像"></a><div class="post-copyright__author_name">Touko</div><div class="post-copyright__author_desc">🐾猫爪按日出, 按出彩虹糖🌈</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://toukoxu.github.io/2022/02/01/event/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://toukoxu.github.io/2022/02/01/event/')">JS 事件系统完全指南与性能优化</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/wechat.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/wechat.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/alipay.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/alipay.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://toukoxu.github.io/2022/02/01/event/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://toukoxu.github.io" target="_blank">Touko</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>前端<span class="categoryesPageCount">10</span></a><a class="post-meta__box__categoryes" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>学习笔记<span class="categoryesPageCount">10</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JavaScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JavaScript<span class="tagsPageCount">10</span></a><a class="post-meta__box__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>性能优化<span class="tagsPageCount">6</span></a></div></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/02/prototype-chain/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/prototype-chain.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/14/iterator/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/iterator.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">迭代器（Iterator）与解构：JS 数据遍历与拆箱的实用指南</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/07/13/async&await/" title="Async&#x2F;Await：用同步的方式写异步，真香！"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/async.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-07-13</div><div class="title">Async&#x2F;Await：用同步的方式写异步，真香！</div></div></a></div><div><a href="/2021/05/02/prototype-chain/" title="原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/prototype-chain.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-05-02</div><div class="title">原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心</div></div></a></div><div><a href="/2024/06/23/message-channel/" title="MessageChannel 详解：浏览器中的“点对点双向通信管道”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/message-channel.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-23</div><div class="title">MessageChannel 详解：浏览器中的“点对点双向通信管道”</div></div></a></div><div><a href="/2021/03/16/scope-chain/" title="作用域链（Scope Chain）：JS 变量查找的“路线图”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/scope-chain.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-03-16</div><div class="title">作用域链（Scope Chain）：JS 变量查找的“路线图”</div></div></a></div><div><a href="/2024/08/15/proxy/" title="代理（Proxy）：ES6 元编程的“对象拦截器”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/proxy.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-08-15</div><div class="title">代理（Proxy）：ES6 元编程的“对象拦截器”</div></div></a></div><div><a href="/2024/06/14/iterator/" title="迭代器（Iterator）与解构：JS 数据遍历与拆箱的实用指南"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/iterator.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-14</div><div class="title">迭代器（Iterator）与解构：JS 数据遍历与拆箱的实用指南</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/site/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/emoji/sparkles.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">欢迎来到我的<b style="color:#fff">编程小天地</b>！这里有可爱的<b style="color:#fff">编程知识点</b>，致力于把复杂的概念变得<b style="color:#fff">简单可爱</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">一起探索，让代码生活更精彩！</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Touko</h1><div class="author-info__desc">🐾猫爪按日出, 按出彩虹糖🌈</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/ToukoXu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">😊 欢迎来看我的博客鸭~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9A%E7%BD%91%E9%A1%B5%E7%9A%84%E2%80%9C%E4%BA%A4%E4%BA%92%E9%80%BB%E8%BE%91%E9%AA%A8%E6%9E%B6%E2%80%9D"><span class="toc-number">1.</span> <span class="toc-text">一、事件系统：网页的“交互逻辑骨架”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9A%E4%BB%8E%E9%A1%B6%E5%B1%82%E5%88%B0%E7%9B%AE%E6%A0%87%EF%BC%8C%E5%86%8D%E5%9B%9E%E5%88%B0%E9%A1%B6%E5%B1%82"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 事件流三阶段：从顶层到目标，再回到顶层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%93%AA%E7%A7%8D%E6%9C%80%E5%AE%9E%E7%94%A8%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 三种事件监听方式：哪种最实用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-addEventListener%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%8F%82%E6%95%B0%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 addEventListener详解：参数怎么用？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.2.</span> <span class="toc-text">关键参数说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%9A%E6%8C%89%E5%9C%BA%E6%99%AF%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">二、常用事件类型：按场景分类整理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E7%9C%8B%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.</span> <span class="toc-text">先看事件的继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Event%EF%BC%88%E5%9F%BA%E7%A1%80%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">1. Event（基础事件）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">2.2.1.</span> <span class="toc-text">常用属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">高频基础事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-UIEvent%EF%BC%88%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">2. UIEvent（用户界面事件）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-MouseEvent%EF%BC%88%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.1 MouseEvent（鼠标事件）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-WheelEvent%EF%BC%88%E6%BB%9A%E8%BD%AE%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">2.1.1 WheelEvent（滚轮事件）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2-DragEvent%EF%BC%88%E6%8B%96%E6%94%BE%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">2.1.2 DragEvent（拖放事件）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3-PointerEvent%EF%BC%88%E6%8C%87%E9%92%88%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">2.1.3 PointerEvent（指针事件）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-KeyboardEvent%EF%BC%88%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.2 KeyboardEvent（键盘事件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-FocusEvent%EF%BC%88%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3 FocusEvent（焦点事件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-TouchEvent%EF%BC%88%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.4 TouchEvent（触摸事件）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-InputEvent%EF%BC%88%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.3.5.</span> <span class="toc-text">2.5 InputEvent（输入事件）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-AnimationEvent%EF%BC%88%E5%8A%A8%E7%94%BB%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">3. AnimationEvent（动画事件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-TransitionEvent%EF%BC%88%E8%BF%87%E6%B8%A1%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">4. TransitionEvent（过渡事件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-ClipboardEvent%EF%BC%88%E5%89%AA%E8%B4%B4%E6%9D%BF%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">5. ClipboardEvent（剪贴板事件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-CustomEvent%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">6. CustomEvent（自定义事件）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.7.1.</span> <span class="toc-text">用法示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8B%E4%BB%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E9%81%BF%E5%85%8D%E5%8D%A1%E9%A1%BF%E3%80%81%E5%87%8F%E5%B0%91%E6%B5%AA%E8%B4%B9"><span class="toc-number">3.</span> <span class="toc-text">三、事件性能优化：避免卡顿、减少浪费</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%AB%98%E9%A2%91%E4%BA%8B%E4%BB%B6%EF%BC%9A%E7%94%A8%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89%E6%8E%A7%E9%A2%91%E7%8E%87"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 高频事件：用防抖（debounce）和节流（throttle）控频率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89%EF%BC%9A%E8%BF%9E%E7%BB%AD%E8%A7%A6%E5%8F%91%E5%8F%AA%E6%89%A7%E8%A1%8C%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1"><span class="toc-number">3.1.1.</span> <span class="toc-text">防抖（debounce）：连续触发只执行最后一次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89%EF%BC%9A%E5%9B%BA%E5%AE%9A%E9%97%B4%E9%9A%94%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1"><span class="toc-number">3.1.2.</span> <span class="toc-text">节流（throttle）：固定间隔执行一次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%A4%9A%E5%85%83%E7%B4%A0%E4%BA%8B%E4%BB%B6%EF%BC%9A%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E5%87%8F%E5%B0%91%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 多元素事件：用事件委托减少监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E9%9D%A2%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%80%90%E4%B8%AA%E7%BB%91%E5%AE%9A%EF%BC%88%E4%BD%8E%E6%95%88%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">反面示例：逐个绑定（低效）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E9%9D%A2%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E9%AB%98%E6%95%88%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">正面示例：事件委托（高效）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E4%BC%98%E5%8A%BF%EF%BC%9A%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E5%85%83%E7%B4%A0"><span class="toc-number">3.2.3.</span> <span class="toc-text">额外优势：支持动态元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BA%8B%E4%BB%B6%EF%BC%9A%E7%94%A8-once-true-%E8%87%AA%E5%8A%A8%E8%A7%A3%E7%BB%91"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 一次性事件：用 once: true 自动解绑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%BB%9A%E5%8A%A8-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%EF%BC%9A%E7%94%A8-passive-true-%E6%8F%90%E5%8D%87%E6%B5%81%E7%95%85%E5%BA%A6"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 滚动&#x2F;触摸事件：用 passive: true 提升流畅度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E4%BA%8B%E4%BB%B6%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%EF%BC%9A%E7%94%A8-capture-true-%E7%B2%BE%E7%A1%AE%E6%8E%A7%E5%88%B6%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E9%A1%BA%E5%BA%8F%EF%BC%88%E4%B8%8D%E6%98%AF%E5%B8%B8%E8%A7%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%89%8B%E6%AE%B5%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 事件顺序控制：用 capture: true 精确控制事件触发顺序（不是常规性能优化的手段）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E4%B8%8D%E5%86%8D%E9%9C%80%E8%A6%81%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%9A%E7%94%A8-removeEventListener-%E5%8F%8A%E6%97%B6%E8%A7%A3%E7%BB%91%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 不再需要的事件：用 removeEventListener 及时解绑避免内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BB%84%E4%BB%B6%E9%94%80%E6%AF%81%E6%97%B6%E8%A7%A3%E7%BB%91"><span class="toc-number">3.6.1.</span> <span class="toc-text">正确示例：组件销毁时解绑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">3.6.2.</span> <span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E4%BA%8B%E4%BB%B6%E9%80%89%E6%8B%A9%E5%8E%9F%E5%88%99"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 事件选择原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E6%88%98%E9%97%AE%E9%A2%98%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%9D%91%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.</span> <span class="toc-text">四、实战问题：常见坑与解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E5%A4%AA%E9%A2%91%E7%B9%81%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%8D%A1%E9%A1%BF"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 滚动事件触发太频繁，页面卡顿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%82%B9%E5%87%BB%E6%9C%89-300ms-%E5%BB%B6%E8%BF%9F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 移动端点击有 300ms 延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%AF%BC%E8%87%B4%E7%88%B6%E5%85%83%E7%B4%A0%E4%BA%8B%E4%BB%B6%E8%AF%AF%E8%A7%A6%E5%8F%91"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 事件冒泡导致父元素事件误触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%88%87%E6%8D%A2%E7%BB%84%E4%BB%B6%EF%BC%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%E6%B2%A1%E8%A7%A3%E7%BB%91"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 单页应用切换组件，事件监听器没解绑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%8E%B0%E4%BB%A3%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7%EF%BC%9A%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E7%8E%A9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">五、现代事件处理技巧：更高效的玩法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%EF%BC%88Event-Bus%EF%BC%89%EF%BC%9A%E9%9D%9E%E5%85%B3%E8%81%94%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 事件总线（Event Bus）：非关联组件通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="toc-number">5.1.1.</span> <span class="toc-text">简单实现事件总线</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-AbortController%EF%BC%9A%E7%8E%B0%E4%BB%A3%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 AbortController：现代事件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8-AbortController-%E5%8F%96%E6%B6%88-fetch-%E8%AF%B7%E6%B1%82"><span class="toc-number">5.2.1.</span> <span class="toc-text">用 AbortController 取消 fetch 请求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E5%B0%8F%E6%B5%8B%E9%AA%8C"><span class="toc-number">6.</span> <span class="toc-text">最后小测验</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/15/proxy/" title="代理（Proxy）：ES6 元编程的“对象拦截器”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/proxy.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代理（Proxy）：ES6 元编程的“对象拦截器”"/></a><div class="content"><a class="title" href="/2024/08/15/proxy/" title="代理（Proxy）：ES6 元编程的“对象拦截器”">代理（Proxy）：ES6 元编程的“对象拦截器”</a><time datetime="2024-08-15T12:46:25.000Z" title="发表于 2024-08-15 20:46:25">2024-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/14/reflect/" title="Reflect：ES6 标准化对象操作的“工具库”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/reflect.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Reflect：ES6 标准化对象操作的“工具库”"/></a><div class="content"><a class="title" href="/2024/08/14/reflect/" title="Reflect：ES6 标准化对象操作的“工具库”">Reflect：ES6 标准化对象操作的“工具库”</a><time datetime="2024-08-14T12:46:25.000Z" title="发表于 2024-08-14 20:46:25">2024-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/13/async&amp;await/" title="Async/Await：用同步的方式写异步，真香！"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/async.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Async/Await：用同步的方式写异步，真香！"/></a><div class="content"><a class="title" href="/2024/07/13/async&amp;await/" title="Async/Await：用同步的方式写异步，真香！">Async/Await：用同步的方式写异步，真香！</a><time datetime="2024-07-13T12:46:25.000Z" title="发表于 2024-07-13 20:46:25">2024-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/11/generator/" title="生成器函数与 yield：掌控函数执行的“暂停键”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/generator.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="生成器函数与 yield：掌控函数执行的“暂停键”"/></a><div class="content"><a class="title" href="/2024/07/11/generator/" title="生成器函数与 yield：掌控函数执行的“暂停键”">生成器函数与 yield：掌控函数执行的“暂停键”</a><time datetime="2024-07-11T12:46:25.000Z" title="发表于 2024-07-11 20:46:25">2024-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/23/message-channel/" title="MessageChannel 详解：浏览器中的“点对点双向通信管道”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/message-channel.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessageChannel 详解：浏览器中的“点对点双向通信管道”"/></a><div class="content"><a class="title" href="/2024/06/23/message-channel/" title="MessageChannel 详解：浏览器中的“点对点双向通信管道”">MessageChannel 详解：浏览器中的“点对点双向通信管道”</a><time datetime="2024-06-23T12:46:25.000Z" title="发表于 2024-06-23 20:46:25">2024-06-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Touko" target="_blank">Touko</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["生活明朗&#44; 万物可爱&#44; 人间值得&#44; 未来可期."]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/ES2017-ES8/" style="font-size: 0.88rem;">ES2017(ES8)<sup>1</sup></a><a href="/tags/ES6/" style="font-size: 0.88rem;">ES6<sup>6</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem; font-weight: 500; color: var(--anzhiyu-lighttext)">JavaScript<sup>10</sup></a><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 0.88rem;">性能优化<sup>6</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"><a class="tag-list" href="/tags/JavaScript" title="JavaScript">JavaScript</a><a class="tag-list" href="/tags/Vue" title="Vue">Vue</a></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.2/dist/svg-pan-zoom.min.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [`叮！可爱加载中... `, `🐱`];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `%c ${ascll[0]} %c${ascll[1]}`,
      "color:white; background-color:#f0ad4e",
      ''
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "你正在访问 Touko 的博客.",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
          const svgElement = document.getElementById(mermaidID)
          const viewBox = svgElement.getAttribute('viewBox')
          const viewBoxValues = viewBox.split(/[\s,]+/)
          window.svgPanZoom ? svgPanZoom(svgElement, { contain: true, controlIconsEnabled: true }) : ''
          const width = Number(getComputedStyle(svgElement).getPropertyValue('width').slice(0, -2))
          svgElement.setAttribute('height', `${viewBoxValues[3] * width / viewBoxValues[2]}px`)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'BsIRp7GQE8IZ5fkI0JRj8Vys-gzGzoHsz',
      appKey: 'vla82YKrFnfwtuQfgoaDnzu9',
      avatar: 'mp',
      serverURLs: 'https://bsirp7gq.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://bsirp7gq.lc-cn-n1-shared.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'BsIRp7GQE8IZ5fkI0JRj8Vys-gzGzoHsz',
        "X-LC-Key": 'vla82YKrFnfwtuQfgoaDnzu9',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@touko.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>