<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Reflect：ES6 标准化对象操作的“工具库” | Touko</title><meta name="keywords" content="JavaScript,ES6"><meta name="author" content="Touko"><meta name="copyright" content="Touko"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Reflect：ES6 标准化对象操作的“工具库”"><meta name="application-name" content="Reflect：ES6 标准化对象操作的“工具库”"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Reflect：ES6 标准化对象操作的“工具库”"><meta property="og:url" content="http://toukoxu.github.io/2024/08/14/reflect/index.html"><meta property="og:site_name" content="Touko"><meta property="og:description" content="Reflect 是 ES6 新增的内置对象，核心作用是提供一套统一、函数式的对象操作 API。它的方法与 Proxy 拦截器一一对应，既能替代传统的对象操作方式（如 delete、in），又能解决旧语法的不一致问题，是元编程和 Proxy 配合的“最佳搭档”。  关联知识可以将 Proxy 和 R"><meta property="og:locale" content="zh"><meta property="og:image" content="http://toukoxu.github.io/img/cover/reflect.png"><meta property="article:author" content="Touko"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://toukoxu.github.io/img/cover/reflect.png"><meta name="description" content="Reflect 是 ES6 新增的内置对象，核心作用是提供一套统一、函数式的对象操作 API。它的方法与 Proxy 拦截器一一对应，既能替代传统的对象操作方式（如 delete、in），又能解决旧语法的不一致问题，是元编程和 Proxy 配合的“最佳搭档”。  关联知识可以将 Proxy 和 R"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://toukoxu.github.io/2024/08/14/reflect/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 科技爱好者","🔨 开发一条龙","🌌 Hello World 宇宙","⌨️ 键盘撸猫区","🐱 万物皆可rua"]},
  algolia: {"appId":"SVGIUL6D7W","apiKey":"aee53519dcfc6f122cfe52009938fc1c","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本文最后一次更新为","messageNext":"天前，文章中的某些内容可能已过时！"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Touko","link":"链接: ","source":"来源: Touko","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Touko',
  title: 'Reflect：ES6 标准化对象操作的“工具库”',
  postAI: '',
  pageFillDescription: '关联知识, 一、为什么需要 Reflect？—— 解决旧语法的痛点, 二、Reflect 的核心特性, 三、Reflect 的 13 个静态方法：按场景分类, 3.1 基本操作：读、写、判断、删属性, 3.2 原型操作：获取x2F设置原型, 3.3 属性定义：定义x2F获取属性描述符, 3.4 其他方法（元编程常用）, 四、Reflect 与 Proxy：天生一对, 4.1 对应关系：拦截器与 Reflect 方法一一匹配, 4.2 实战示例：Proxy 中用 Reflect 保持默认行为, 五、Reflect 的核心优势：解决传统操作的痛点, 5.1 统一错误处理：用布尔值判断结果不用 tryx2Fcatch, 5.2 正确传递 this：解决 receiver 问题, 5.3 支持函数式编程：可组合、可复用, 六、Reflect 的实际应用场景, 6.1 配合 Proxy 实现响应式（如 Vue3）, 6.2 安全的对象操作：避免抛错, 6.3 实现多继承（通过代理+Reflect）, 七、最佳实践与注意事项, 7.1 什么时候用 Reflect？, 7.2 什么时候不用 Reflect？, 7.3 浏览器兼容性是新增的内置对象核心作用是提供一套统一函数式的对象操作它的方法与拦截器一一对应既能替代传统的对象操作方式如又能解决旧语法的不一致问题是元编程和配合的最佳搭档关联知识可以将和合并在一起学习站内地址代理元编程的对象拦截器一为什么需要解决旧语法的痛点在出现前操作对象的方式很零散存在三个明显问题操作形式不统一有的是关键字如有的是上的方法如风格混乱错误处理不一致有的操作失败会抛出错误如遇到不可扩展对象有的返回布尔值如处理逻辑复杂绑定问题传统操作如无法正确传递上下文在代理或继承场景下容易出错正是为解决这些问题而生它把所有对象操作都封装成函数式方法统一了调用形式错误处理和上下文传递二的核心特性与一一对应的个静态方法正好对应的种拦截器如对应的拦截器是实现默认行为的标准工具函数式操作所有对象操作包括读写删判断属性等都通过函数调用完成支持函数式编程如组合柯里化统一返回值大部分方法返回布尔值表示成功表示失败避免了传统操作有的抛错有的返回值的混乱正确传递方法支持参数能在继承或代理场景下正确绑定解决传统的丢失问题三的个静态方法按场景分类的方法一共有个我将它们分了几类日常开发中高频使用的是基本操作类其他类多用于元编程场景基本操作读写判断删属性最常用的四类方法对应日常的属性操作方法描述传统等价操作示例读取对象属性读设置对象属性设判断属性是否存在判断删除对象属性删原型操作获取设置原型对应和但返回值更合理布尔值表示成功失败方法描述传统等价操作示例获取对象的原型同设置对象的原型返回表示成功属性定义定义获取属性描述符对应和返回布尔值表示操作结果方法描述传统等价操作示例定义属性含描述符获取属性描述符其他方法元编程常用这些方法多用于底层对象控制日常开发中较少直接使用方法描述传统等价操作判断对象是否可扩展能否加新属性阻止对象扩展获取对象所有自身属性含调用函数类似调用构造函数类似四与天生一对的最大价值在于与配合使用拦截对象操作后通过能安全地执行默认操作避免破坏对象的原生行为如绑定继承关系对应关系拦截器与方法一一匹配的每一种拦截器都能通过对应的方法实现默认行为它们是一一对应的实战示例中用保持默认行为比如拦截对象的和操作在自定义逻辑后用执行默认的读写行为拦截器监控属性读写自定义逻辑打印读取日志正在读取属性用执行默认读操作正确传递自定义逻辑验证必须是正数年龄不能为负数用执行默认写操作返回布尔值表示成功测试触发拦截逻辑同时保持默认行为打印正在读取属性输出成功设置无错误抛出错误年龄不能为负数如果不用直接用或会丢失上下文比如在继承场景下指向错误五的核心优势解决传统操作的痛点统一错误处理用布尔值判断结果不用传统的失败时会抛出错误需要用处理而直接返回布尔值逻辑更简洁让对象不可扩展不能加新属性传统方式失败抛错需定义成功定义失败会执行这里对象不可扩展方式返回布尔值直接判断定义成功定义失败会执行这里更简洁正确传递解决问题在代理或继承场景下传统的会导致指向错误而支持参数能正确绑定应该指向调用者用代理错误方式会让指向正确方式传递指向调用者子对象继承代理子对象自己的错误方式输出指向正确方式输出指向符合继承逻辑支持函数式编程可组合可复用的方法都是函数能像其他函数一样组合使用比如批量执行操作并判断结果定义一组操作批量设置属性执行所有操作判断是否全部成功所有属性设置成功部分操作失败六的实际应用场景配合实现响应式如的响应式系统中拦截属性读写后通过执行默认操作同时收集依赖或触发更新收集依赖响应式核心默认读操作触发更新响应式核心安全的对象操作避免抛错在工具库或框架中需要安全操作对象即使失败也不崩溃用比传统方法更合适安全设置对象属性的工具函数先判断对象是否可扩展再设置属性对象不可扩展无法设置属性测试不可扩展对象冻结对象不可扩展不可修改输出警告返回不抛错实现多继承通过代理不支持原生多继承但通过和可以模拟多原型查找多继承实现让对象拥有多个原型的方法按顺序在多个原型中查找属性定义三个能力对象吃饭走路游泳创建多继承对象吃饭来自走路来自游泳来自七最佳实践与注意事项什么时候用与配合时必须用执行默认操作避免绑定错误需要安全操作对象时比如不确定对象是否可扩展是否有该属性用避免抛错函数式编程场景需要组合复用对象操作时的函数式更合适元编程开发比如实现框架工具库需要统一对象操作方式时什么时候不用简单属性读写日常写或比更简洁没必要画蛇添足性能极度敏感的代码虽然性能与原生操作接近但极端场景下如每秒百万次操作原生语法略快浏览器兼容性不支持浏览器现代浏览器和均支持如果需要兼容旧环境需用方法替代如替代看似简单却是元编程的基石之一它统一了对象操作的标准让能安全地拦截行为也让复杂的对象控制逻辑更简洁更可维护掌握不仅能更好地理解等框架的底层还能在开发工具库或复杂系统时写出更健壮的代码',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-15 20:46:25',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link href="https://fonts.cdnfonts.com/css/shina-baby" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/loading.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Touko</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="/img/wechat.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/img/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/ES2017-ES8/" style="font-size: 1.05rem;">ES2017(ES8)<sup>1</sup></a><a href="/tags/ES6/" style="font-size: 1.05rem;">ES6<sup>6</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>10</sup></a><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 1.05rem;">性能优化<sup>6</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">August 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">July 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">June 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">February 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">May 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/04/"><span class="card-archive-list-date">April 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/03/"><span class="card-archive-list-date">March 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JavaScript/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JavaScript</span></a><a class="article-meta__tags" href="/tags/ES6/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>ES6</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Reflect：ES6 标准化对象操作的“工具库”</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-08-14T12:46:25.000Z" title="发表于 2024-08-14 20:46:25">2024-08-14</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-08-15T12:46:25.000Z" title="更新于 2024-08-15 20:46:25">2024-08-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">2.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为上海"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>上海</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/cover/reflect.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://toukoxu.github.io/2024/08/14/reflect/"><header><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a><a href="/tags/JavaScript/" tabindex="-1" itemprop="url">JavaScript</a><a href="/tags/ES6/" tabindex="-1" itemprop="url">ES6</a><h1 id="CrawlerTitle" itemprop="name headline">Reflect：ES6 标准化对象操作的“工具库”</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Touko</span><time itemprop="dateCreated datePublished" datetime="2024-08-14T12:46:25.000Z" title="发表于 2024-08-14 20:46:25">2024-08-14</time><time itemprop="dateCreated datePublished" datetime="2024-08-15T12:46:25.000Z" title="更新于 2024-08-15 20:46:25">2024-08-15</time></header><blockquote>
<p><strong>Reflect</strong> 是 ES6 新增的内置对象，核心作用是<strong>提供一套统一、函数式的对象操作 API</strong>。它的方法与 Proxy 拦截器一一对应，既能替代传统的对象操作方式（如 <code>delete</code>、<code>in</code>），又能解决旧语法的不一致问题，是元编程和 Proxy 配合的“最佳搭档”。</p>
</blockquote>
<h2 id="关联知识"><a href="#关联知识" class="headerlink" title="关联知识"></a>关联知识</h2><p>可以将 Proxy 和 Reflect 合并在一起学习～</p>
<div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="/2024/08/15/proxy">
    <div class="tag-link-tips">站内地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(/img/512.png)">
          <i class="anzhiyufont anzhiyu-icon-link" style="display: none"></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">代理（Proxy）：ES6 元编程的“对象拦截器”</div>
            <div class="tag-link-sitename"> Touko</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<h2 id="一、为什么需要-Reflect？——-解决旧语法的痛点"><a href="#一、为什么需要-Reflect？——-解决旧语法的痛点" class="headerlink" title="一、为什么需要 Reflect？—— 解决旧语法的痛点"></a>一、为什么需要 Reflect？—— 解决旧语法的痛点</h2><p>在 Reflect 出现前，JavaScript 操作对象的方式很“零散”，存在三个明显问题：</p>
<ol>
<li><strong>操作形式不统一</strong>：有的是关键字（如 <code>delete obj.prop</code>、<code>prop in obj</code>），有的是 <code>Object</code> 上的方法（如 <code>Object.keys(obj)</code>、<code>Object.defineProperty()</code>），风格混乱。</li>
<li><strong>错误处理不一致</strong>：有的操作失败会抛出错误（如 <code>Object.defineProperty</code> 遇到不可扩展对象），有的返回布尔值（如 <code>delete obj.prop</code>），处理逻辑复杂。</li>
<li><strong>this 绑定问题</strong>：传统操作（如 <code>target[prop]</code>）无法正确传递 <code>this</code> 上下文，在代理或继承场景下容易出错。</li>
</ol>
<p>Reflect 正是为解决这些问题而生——它把所有对象操作都封装成<strong>函数式方法</strong>，统一了调用形式、错误处理和上下文传递。</p>
<h2 id="二、Reflect-的核心特性"><a href="#二、Reflect-的核心特性" class="headerlink" title="二、Reflect 的核心特性"></a>二、Reflect 的核心特性</h2><ol>
<li><strong>与 Proxy 一一对应</strong>：Reflect 的 13 个静态方法，正好对应 Proxy 的 13 种拦截器（如 <code>Reflect.get</code> 对应 Proxy 的 <code>get</code> 拦截器），是 Proxy 实现默认行为的“标准工具”。</li>
<li><strong>函数式操作</strong>：所有对象操作（包括读、写、删、判断属性等）都通过函数调用完成，支持函数式编程（如组合、柯里化）。</li>
<li><strong>统一返回值</strong>：大部分方法返回布尔值（<code>true</code> 表示成功，<code>false</code> 表示失败），避免了传统操作“有的抛错、有的返回值”的混乱。</li>
<li><strong>正确传递 this</strong>：方法支持 <code>receiver</code> 参数，能在继承或代理场景下正确绑定 <code>this</code>（解决传统 <code>target[prop]</code> 的 <code>this</code> 丢失问题）。</li>
</ol>
<h2 id="三、Reflect-的-13-个静态方法：按场景分类"><a href="#三、Reflect-的-13-个静态方法：按场景分类" class="headerlink" title="三、Reflect 的 13 个静态方法：按场景分类"></a>三、Reflect 的 13 个静态方法：按场景分类</h2><p>Reflect 的方法一共有 13 个，我将它们分了几类，日常开发中高频使用的是“基本操作”类，其他类多用于元编程场景。</p>
<h3 id="3-1-基本操作：读、写、判断、删属性"><a href="#3-1-基本操作：读、写、判断、删属性" class="headerlink" title="3.1 基本操作：读、写、判断、删属性"></a>3.1 基本操作：读、写、判断、删属性</h3><p>最常用的四类方法，对应日常的属性操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>传统等价操作</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>Reflect.get(target, propKey[, receiver])</code></td>
<td>读取对象属性</td>
<td><code>target[propKey]</code></td>
<td><code>Reflect.get(user, &#39;name&#39;)</code>（读 <code>user.name</code>）</td>
</tr>
<tr>
<td><code>Reflect.set(target, propKey, value[, receiver])</code></td>
<td>设置对象属性</td>
<td><code>target[propKey] = value</code></td>
<td><code>Reflect.set(user, &#39;age&#39;, 30)</code>（设 <code>user.age = 30</code>）</td>
</tr>
<tr>
<td><code>Reflect.has(target, propKey)</code></td>
<td>判断属性是否存在</td>
<td><code>propKey in target</code></td>
<td><code>Reflect.has(user, &#39;id&#39;)</code>（判断 <code>&#39;id&#39; in user</code>）</td>
</tr>
<tr>
<td><code>Reflect.deleteProperty(target, propKey)</code></td>
<td>删除对象属性</td>
<td><code>delete target[propKey]</code></td>
<td><code>Reflect.deleteProperty(user, &#39;temp&#39;)</code>（删 <code>user.temp</code>）</td>
</tr>
</tbody></table>
<h3 id="3-2-原型操作：获取-设置原型"><a href="#3-2-原型操作：获取-设置原型" class="headerlink" title="3.2 原型操作：获取&#x2F;设置原型"></a>3.2 原型操作：获取&#x2F;设置原型</h3><p>对应 <code>Object.getPrototypeOf</code> 和 <code>Object.setPrototypeOf</code>，但返回值更合理（布尔值表示成功&#x2F;失败）：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>传统等价操作</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>Reflect.getPrototypeOf(target)</code></td>
<td>获取对象的原型</td>
<td><code>Object.getPrototypeOf(target)</code></td>
<td><code>Reflect.getPrototypeOf(user)</code>（同 <code>Object.getPrototypeOf(user)</code>）</td>
</tr>
<tr>
<td><code>Reflect.setPrototypeOf(target, proto)</code></td>
<td>设置对象的原型</td>
<td><code>Object.setPrototypeOf(target, proto)</code></td>
<td><code>Reflect.setPrototypeOf(user, protoObj)</code>（返回 <code>true</code> 表示成功）</td>
</tr>
</tbody></table>
<h3 id="3-3-属性定义：定义-获取属性描述符"><a href="#3-3-属性定义：定义-获取属性描述符" class="headerlink" title="3.3 属性定义：定义&#x2F;获取属性描述符"></a>3.3 属性定义：定义&#x2F;获取属性描述符</h3><p>对应 <code>Object.defineProperty</code> 和 <code>Object.getOwnPropertyDescriptor</code>，返回布尔值表示操作结果：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>传统等价操作</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>Reflect.defineProperty(target, propKey, desc)</code></td>
<td>定义属性（含描述符）</td>
<td><code>Object.defineProperty(target, propKey, desc)</code></td>
<td><code>Reflect.defineProperty(user, &#39;name&#39;, &#123; value: &#39;Alice&#39; &#125;)</code></td>
</tr>
<tr>
<td><code>Reflect.getOwnPropertyDescriptor(target, propKey)</code></td>
<td>获取属性描述符</td>
<td><code>Object.getOwnPropertyDescriptor(target, propKey)</code></td>
<td><code>Reflect.getOwnPropertyDescriptor(user, &#39;age&#39;)</code></td>
</tr>
</tbody></table>
<h3 id="3-4-其他方法（元编程常用）"><a href="#3-4-其他方法（元编程常用）" class="headerlink" title="3.4 其他方法（元编程常用）"></a>3.4 其他方法（元编程常用）</h3><p>这些方法多用于底层对象控制，日常开发中较少直接使用：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>传统等价操作</th>
</tr>
</thead>
<tbody><tr>
<td><code>Reflect.isExtensible(target)</code></td>
<td>判断对象是否可扩展（能否加新属性）</td>
<td><code>Object.isExtensible(target)</code></td>
</tr>
<tr>
<td><code>Reflect.preventExtensions(target)</code></td>
<td>阻止对象扩展</td>
<td><code>Object.preventExtensions(target)</code></td>
</tr>
<tr>
<td><code>Reflect.ownKeys(target)</code></td>
<td>获取对象所有自身属性（含 Symbol）</td>
<td><code>Object.getOwnPropertyNames() + Object.getOwnPropertySymbols()</code></td>
</tr>
<tr>
<td><code>Reflect.apply(target, thisArg, args)</code></td>
<td>调用函数（类似 <code>Function.prototype.apply</code>）</td>
<td><code>target.apply(thisArg, args)</code></td>
</tr>
<tr>
<td><code>Reflect.construct(target, args[, newTarget])</code></td>
<td>调用构造函数（类似 <code>new</code>）</td>
<td><code>new target(...args)</code></td>
</tr>
</tbody></table>
<h2 id="四、Reflect-与-Proxy：天生一对"><a href="#四、Reflect-与-Proxy：天生一对" class="headerlink" title="四、Reflect 与 Proxy：天生一对"></a>四、Reflect 与 Proxy：天生一对</h2><p>Reflect 的最大价值，在于与 Proxy 配合使用——Proxy 拦截对象操作后，通过 Reflect 能<strong>安全地执行默认操作</strong>，避免破坏对象的原生行为（如 <code>this</code> 绑定、继承关系）。</p>
<h3 id="4-1-对应关系：拦截器与-Reflect-方法一一匹配"><a href="#4-1-对应关系：拦截器与-Reflect-方法一一匹配" class="headerlink" title="4.1 对应关系：拦截器与 Reflect 方法一一匹配"></a>4.1 对应关系：拦截器与 Reflect 方法一一匹配</h3><p>Proxy 的每一种拦截器，都能通过对应的 Reflect 方法实现“默认行为”，它们是<strong>一一对应</strong>的。</p>
<h3 id="4-2-实战示例：Proxy-中用-Reflect-保持默认行为"><a href="#4-2-实战示例：Proxy-中用-Reflect-保持默认行为" class="headerlink" title="4.2 实战示例：Proxy 中用 Reflect 保持默认行为"></a>4.2 实战示例：Proxy 中用 Reflect 保持默认行为</h3><p>比如拦截对象的 <code>get</code> 和 <code>set</code> 操作，在自定义逻辑后，用 Reflect 执行默认的读写行为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy 拦截器：监控属性读写</span></span><br><span class="line"><span class="keyword">const</span> userProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// 自定义逻辑：打印读取日志</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`正在读取属性：<span class="subst">$&#123;propKey&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 Reflect.get 执行默认读操作（正确传递 this）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, propKey, value, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// 自定义逻辑：验证 age 必须是正数</span></span><br><span class="line">    <span class="keyword">if</span> (propKey === <span class="string">&#x27;age&#x27;</span> &amp;&amp; value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;年龄不能为负数！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 Reflect.set 执行默认写操作（返回布尔值表示成功）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propKey, value, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：触发拦截逻辑，同时保持默认行为</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userProxy.<span class="property">name</span>); <span class="comment">// 打印“正在读取属性：name”，输出“Alice”</span></span><br><span class="line">userProxy.<span class="property">age</span> = <span class="number">30</span>; <span class="comment">// 成功设置（无错误）</span></span><br><span class="line">userProxy.<span class="property">age</span> = -<span class="number">5</span>; <span class="comment">// 抛出错误：年龄不能为负数！</span></span><br></pre></td></tr></table></figure>

<p>如果不用 Reflect，直接用 <code>target[propKey]</code> 或 <code>target[propKey] = value</code>，会丢失 <code>receiver</code> 上下文（比如在继承场景下 <code>this</code> 指向错误）。</p>
<h2 id="五、Reflect-的核心优势：解决传统操作的痛点"><a href="#五、Reflect-的核心优势：解决传统操作的痛点" class="headerlink" title="五、Reflect 的核心优势：解决传统操作的痛点"></a>五、Reflect 的核心优势：解决传统操作的痛点</h2><h3 id="5-1-统一错误处理：用布尔值判断结果，不用-try-catch"><a href="#5-1-统一错误处理：用布尔值判断结果，不用-try-catch" class="headerlink" title="5.1 统一错误处理：用布尔值判断结果，不用 try&#x2F;catch"></a>5.1 统一错误处理：用布尔值判断结果，不用 try&#x2F;catch</h3><p>传统的 <code>Object.defineProperty</code> 失败时会抛出错误，需要用 <code>try/catch</code> 处理；而 <code>Reflect.defineProperty</code> 直接返回布尔值，逻辑更简洁：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(&#123;&#125;); <span class="comment">// 让对象不可扩展（不能加新属性）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式：失败抛错，需 try/catch</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;newProp&#x27;</span>, &#123; <span class="attr">value</span>: <span class="number">123</span> &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定义成功&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定义失败&#x27;</span>); <span class="comment">// 会执行这里（对象不可扩展）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect 方式：返回布尔值，直接判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;newProp&#x27;</span>, &#123; <span class="attr">value</span>: <span class="number">123</span> &#125;)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定义成功&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定义失败&#x27;</span>); <span class="comment">// 会执行这里（更简洁）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-正确传递-this：解决-receiver-问题"><a href="#5-2-正确传递-this：解决-receiver-问题" class="headerlink" title="5.2 正确传递 this：解决 receiver 问题"></a>5.2 正确传递 this：解决 receiver 问题</h3><p>在代理或继承场景下，传统的 <code>target[prop]</code> 会导致 <code>this</code> 指向错误，而 Reflect 支持 <code>receiver</code> 参数，能正确绑定 <code>this</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&#x27;Parent&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>; <span class="comment">// this 应该指向调用者</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 Proxy 代理 parent</span></span><br><span class="line"><span class="keyword">const</span> parentProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(parent, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">    <span class="comment">// 错误方式：target[propKey] 会让 this 指向 target（parent）</span></span><br><span class="line">    <span class="comment">// return target[propKey];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确方式：Reflect.get 传递 receiver（this 指向调用者）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子对象继承代理</span></span><br><span class="line"><span class="keyword">const</span> child = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: parentProxy,</span><br><span class="line">  <span class="attr">_name</span>: <span class="string">&#x27;Child&#x27;</span>, <span class="comment">// 子对象自己的 _name</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>);</span><br><span class="line"><span class="comment">// 错误方式输出 &quot;Parent&quot;（this 指向 parent）</span></span><br><span class="line"><span class="comment">// 正确方式输出 &quot;Child&quot;（this 指向 child，符合继承逻辑）</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-支持函数式编程：可组合、可复用"><a href="#5-3-支持函数式编程：可组合、可复用" class="headerlink" title="5.3 支持函数式编程：可组合、可复用"></a>5.3 支持函数式编程：可组合、可复用</h3><p>Reflect 的方法都是函数，能像其他函数一样组合使用，比如批量执行操作并判断结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一组操作：批量设置属性</span></span><br><span class="line"><span class="keyword">const</span> operations = [</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(obj, <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(obj, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(obj, <span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行所有操作，判断是否全部成功</span></span><br><span class="line"><span class="keyword">const</span> allSuccess = operations.<span class="title function_">every</span>(<span class="function">(<span class="params">op</span>) =&gt;</span> <span class="title function_">op</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (allSuccess) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有属性设置成功&#x27;</span>, obj); <span class="comment">// &#123; a:1, b:2, c:3 &#125;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;部分操作失败&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、Reflect-的实际应用场景"><a href="#六、Reflect-的实际应用场景" class="headerlink" title="六、Reflect 的实际应用场景"></a>六、Reflect 的实际应用场景</h2><h3 id="6-1-配合-Proxy-实现响应式（如-Vue3）"><a href="#6-1-配合-Proxy-实现响应式（如-Vue3）" class="headerlink" title="6.1 配合 Proxy 实现响应式（如 Vue3）"></a>6.1 配合 Proxy 实现响应式（如 Vue3）</h3><p>Vue3 的响应式系统中，Proxy 拦截属性读写后，通过 Reflect 执行默认操作，同时收集依赖或触发更新：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">      <span class="title function_">track</span>(target, propKey); <span class="comment">// 收集依赖（响应式核心）</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver); <span class="comment">// 默认读操作</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, propKey, value, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">      <span class="keyword">const</span> success = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propKey, value, receiver);</span><br><span class="line">      <span class="keyword">if</span> (success &amp;&amp; oldValue !== value) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, propKey); <span class="comment">// 触发更新（响应式核心）</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> success;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-安全的对象操作：避免抛错"><a href="#6-2-安全的对象操作：避免抛错" class="headerlink" title="6.2 安全的对象操作：避免抛错"></a>6.2 安全的对象操作：避免抛错</h3><p>在工具库或框架中，需要“安全操作对象”（即使失败也不崩溃），用 Reflect 比传统方法更合适：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全设置对象属性的工具函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">safeSet</span>(<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">  <span class="comment">// 先判断对象是否可扩展，再设置属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(obj, prop, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;对象不可扩展，无法设置属性&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：不可扩展对象</span></span><br><span class="line"><span class="keyword">const</span> frozenObj = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;); <span class="comment">// 冻结对象（不可扩展、不可修改）</span></span><br><span class="line"><span class="title function_">safeSet</span>(frozenObj, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>); <span class="comment">// 输出警告，返回 false（不抛错）</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-实现多继承（通过代理-Reflect）"><a href="#6-3-实现多继承（通过代理-Reflect）" class="headerlink" title="6.3 实现多继承（通过代理+Reflect）"></a>6.3 实现多继承（通过代理+Reflect）</h3><p>JavaScript 不支持原生多继承，但通过 Proxy 和 Reflect 可以模拟“多原型查找”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多继承实现：让对象拥有多个原型的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createMultiProto</span>(<span class="params">...prototypes</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">        <span class="comment">// 按顺序在多个原型中查找属性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> proto <span class="keyword">of</span> prototypes) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">has</span>(proto, propKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(proto, propKey, receiver);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义三个“能力”对象</span></span><br><span class="line"><span class="keyword">const</span> canEat = &#123; <span class="attr">eat</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;吃饭&#x27;</span>) &#125;;</span><br><span class="line"><span class="keyword">const</span> canWalk = &#123; <span class="attr">walk</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;走路&#x27;</span>) &#125;;</span><br><span class="line"><span class="keyword">const</span> canSwim = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;游泳&#x27;</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多继承对象</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="title function_">createMultiProto</span>(canEat, canWalk, canSwim);</span><br><span class="line">person.<span class="title function_">eat</span>(); <span class="comment">// 吃饭（来自 canEat）</span></span><br><span class="line">person.<span class="title function_">walk</span>(); <span class="comment">// 走路（来自 canWalk）</span></span><br><span class="line">person.<span class="title function_">swim</span>(); <span class="comment">// 游泳（来自 canSwim）</span></span><br></pre></td></tr></table></figure>

<h2 id="七、最佳实践与注意事项"><a href="#七、最佳实践与注意事项" class="headerlink" title="七、最佳实践与注意事项"></a>七、最佳实践与注意事项</h2><h3 id="7-1-什么时候用-Reflect？"><a href="#7-1-什么时候用-Reflect？" class="headerlink" title="7.1 什么时候用 Reflect？"></a>7.1 什么时候用 Reflect？</h3><ul>
<li><strong>与 Proxy 配合时</strong>：必须用 Reflect 执行默认操作，避免 <code>this</code> 绑定错误。</li>
<li><strong>需要安全操作对象时</strong>：比如不确定对象是否可扩展、是否有该属性，用 Reflect 避免抛错。</li>
<li><strong>函数式编程场景</strong>：需要组合、复用对象操作时，Reflect 的函数式 API 更合适。</li>
<li><strong>元编程开发</strong>：比如实现框架、工具库，需要统一对象操作方式时。</li>
</ul>
<h3 id="7-2-什么时候不用-Reflect？"><a href="#7-2-什么时候不用-Reflect？" class="headerlink" title="7.2 什么时候不用 Reflect？"></a>7.2 什么时候不用 Reflect？</h3><ul>
<li><strong>简单属性读写</strong>：日常写 <code>obj.prop</code> 或 <code>obj.prop = value</code> 比 <code>Reflect.get</code>&#x2F;<code>set</code> 更简洁，没必要画蛇添足。</li>
<li><strong>性能极度敏感的代码</strong>：虽然 Reflect 性能与原生操作接近，但极端场景下（如每秒百万次操作），原生语法略快。</li>
</ul>
<h3 id="7-3-浏览器兼容性"><a href="#7-3-浏览器兼容性" class="headerlink" title="7.3 浏览器兼容性"></a>7.3 浏览器兼容性</h3><p>Reflect 不支持 IE 浏览器，现代浏览器（Chrome 49+、Firefox 42+、Safari 10+、Edge 13+）和 Node.js 6.5+ 均支持。如果需要兼容旧环境，需用 <code>Object</code> 方法替代（如 <code>Object.getPrototypeOf</code> 替代 <code>Reflect.getPrototypeOf</code>）。</p>
<hr>
<p>Reflect 看似简单，却是 ES6 元编程的“基石”之一——它统一了对象操作的标准，让 Proxy 能安全地拦截行为，也让复杂的对象控制逻辑更简洁、更可维护。掌握 Reflect，不仅能更好地理解 Vue3 等框架的底层，还能在开发工具库或复杂系统时，写出更健壮的代码～</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Touko</div><div class="post-copyright__author_desc">🐾猫爪按日出, 按出彩虹糖🌈</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://toukoxu.github.io/2024/08/14/reflect/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://toukoxu.github.io/2024/08/14/reflect/')">Reflect：ES6 标准化对象操作的“工具库”</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://toukoxu.github.io/2024/08/14/reflect/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://toukoxu.github.io" target="_blank">Touko</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>前端<span class="categoryesPageCount">10</span></a><a class="post-meta__box__categoryes" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>学习笔记<span class="categoryesPageCount">10</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JavaScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JavaScript<span class="tagsPageCount">10</span></a><a class="post-meta__box__tags" href="/tags/ES6/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>ES6<span class="tagsPageCount">6</span></a></div></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/13/async&amp;await/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/async.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Async/Await：用同步的方式写异步，真香！</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/15/proxy/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/proxy.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">代理（Proxy）：ES6 元编程的“对象拦截器”</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2021/04/03/closure/" title="闭包（Closure）：JavaScript 里的“记忆小助手”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/closure.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-04-03</div><div class="title">闭包（Closure）：JavaScript 里的“记忆小助手”</div></div></a></div><div><a href="/2024/07/11/generator/" title="生成器函数与 yield：掌控函数执行的“暂停键”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/generator.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-07-11</div><div class="title">生成器函数与 yield：掌控函数执行的“暂停键”</div></div></a></div><div><a href="/2024/06/14/iterator/" title="迭代器（Iterator）与解构：JS 数据遍历与拆箱的实用指南"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/iterator.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-14</div><div class="title">迭代器（Iterator）与解构：JS 数据遍历与拆箱的实用指南</div></div></a></div><div><a href="/2021/05/02/prototype-chain/" title="原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/prototype-chain.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-05-02</div><div class="title">原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心</div></div></a></div><div><a href="/2024/08/15/proxy/" title="代理（Proxy）：ES6 元编程的“对象拦截器”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/proxy.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-08-15</div><div class="title">代理（Proxy）：ES6 元编程的“对象拦截器”</div></div></a></div><div><a href="/2024/07/13/async&await/" title="Async&#x2F;Await：用同步的方式写异步，真香！"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/async.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-07-13</div><div class="title">Async&#x2F;Await：用同步的方式写异步，真香！</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/sparkles.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">欢迎来到我的<b style="color:#fff">编程小天地</b>！这里有可爱的<b style="color:#fff">编程知识点</b>，致力于把复杂的概念变得<b style="color:#fff">简单可爱</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">一起探索，让代码生活更精彩！</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Touko</h1><div class="author-info__desc">🐾猫爪按日出, 按出彩虹糖🌈</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/ToukoXu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">😊 欢迎来看我的博客鸭~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">关联知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Reflect%EF%BC%9F%E2%80%94%E2%80%94-%E8%A7%A3%E5%86%B3%E6%97%A7%E8%AF%AD%E6%B3%95%E7%9A%84%E7%97%9B%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">一、为什么需要 Reflect？—— 解决旧语法的痛点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Reflect-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">二、Reflect 的核心特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Reflect-%E7%9A%84-13-%E4%B8%AA%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A%E6%8C%89%E5%9C%BA%E6%99%AF%E5%88%86%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">三、Reflect 的 13 个静态方法：按场景分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%9A%E8%AF%BB%E3%80%81%E5%86%99%E3%80%81%E5%88%A4%E6%96%AD%E3%80%81%E5%88%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 基本操作：读、写、判断、删属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8E%9F%E5%9E%8B%E6%93%8D%E4%BD%9C%EF%BC%9A%E8%8E%B7%E5%8F%96-%E8%AE%BE%E7%BD%AE%E5%8E%9F%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 原型操作：获取&#x2F;设置原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%EF%BC%9A%E5%AE%9A%E4%B9%89-%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 属性定义：定义&#x2F;获取属性描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%83%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 其他方法（元编程常用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Reflect-%E4%B8%8E-Proxy%EF%BC%9A%E5%A4%A9%E7%94%9F%E4%B8%80%E5%AF%B9"><span class="toc-number">5.</span> <span class="toc-text">四、Reflect 与 Proxy：天生一对</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%EF%BC%9A%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E-Reflect-%E6%96%B9%E6%B3%95%E4%B8%80%E4%B8%80%E5%8C%B9%E9%85%8D"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 对应关系：拦截器与 Reflect 方法一一匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%AE%9E%E6%88%98%E7%A4%BA%E4%BE%8B%EF%BC%9AProxy-%E4%B8%AD%E7%94%A8-Reflect-%E4%BF%9D%E6%8C%81%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 实战示例：Proxy 中用 Reflect 保持默认行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Reflect-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BC%A0%E7%BB%9F%E6%93%8D%E4%BD%9C%E7%9A%84%E7%97%9B%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">五、Reflect 的核心优势：解决传统操作的痛点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E7%94%A8%E5%B8%83%E5%B0%94%E5%80%BC%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%9C%EF%BC%8C%E4%B8%8D%E7%94%A8-try-catch"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 统一错误处理：用布尔值判断结果，不用 try&#x2F;catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%AD%A3%E7%A1%AE%E4%BC%A0%E9%80%92-this%EF%BC%9A%E8%A7%A3%E5%86%B3-receiver-%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 正确传递 this：解决 receiver 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9A%E5%8F%AF%E7%BB%84%E5%90%88%E3%80%81%E5%8F%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 支持函数式编程：可组合、可复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Reflect-%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.</span> <span class="toc-text">六、Reflect 的实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E9%85%8D%E5%90%88-Proxy-%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%88%E5%A6%82-Vue3%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 配合 Proxy 实现响应式（如 Vue3）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%EF%BC%9A%E9%81%BF%E5%85%8D%E6%8A%9B%E9%94%99"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 安全的对象操作：避免抛错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%88%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86-Reflect%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 实现多继承（通过代理+Reflect）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.</span> <span class="toc-text">七、最佳实践与注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-Reflect%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 什么时候用 Reflect？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E7%94%A8-Reflect%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 什么时候不用 Reflect？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 浏览器兼容性</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/15/proxy/" title="代理（Proxy）：ES6 元编程的“对象拦截器”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/proxy.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代理（Proxy）：ES6 元编程的“对象拦截器”"/></a><div class="content"><a class="title" href="/2024/08/15/proxy/" title="代理（Proxy）：ES6 元编程的“对象拦截器”">代理（Proxy）：ES6 元编程的“对象拦截器”</a><time datetime="2024-08-15T12:46:25.000Z" title="发表于 2024-08-15 20:46:25">2024-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/14/reflect/" title="Reflect：ES6 标准化对象操作的“工具库”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/reflect.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Reflect：ES6 标准化对象操作的“工具库”"/></a><div class="content"><a class="title" href="/2024/08/14/reflect/" title="Reflect：ES6 标准化对象操作的“工具库”">Reflect：ES6 标准化对象操作的“工具库”</a><time datetime="2024-08-14T12:46:25.000Z" title="发表于 2024-08-14 20:46:25">2024-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/13/async&amp;await/" title="Async/Await：用同步的方式写异步，真香！"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/async.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Async/Await：用同步的方式写异步，真香！"/></a><div class="content"><a class="title" href="/2024/07/13/async&amp;await/" title="Async/Await：用同步的方式写异步，真香！">Async/Await：用同步的方式写异步，真香！</a><time datetime="2024-07-13T12:46:25.000Z" title="发表于 2024-07-13 20:46:25">2024-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/11/generator/" title="生成器函数与 yield：掌控函数执行的“暂停键”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/generator.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="生成器函数与 yield：掌控函数执行的“暂停键”"/></a><div class="content"><a class="title" href="/2024/07/11/generator/" title="生成器函数与 yield：掌控函数执行的“暂停键”">生成器函数与 yield：掌控函数执行的“暂停键”</a><time datetime="2024-07-11T12:46:25.000Z" title="发表于 2024-07-11 20:46:25">2024-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/23/message-channel/" title="MessageChannel 详解：浏览器中的“点对点双向通信管道”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/cover/messageChannel.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessageChannel 详解：浏览器中的“点对点双向通信管道”"/></a><div class="content"><a class="title" href="/2024/06/23/message-channel/" title="MessageChannel 详解：浏览器中的“点对点双向通信管道”">MessageChannel 详解：浏览器中的“点对点双向通信管道”</a><time datetime="2024-06-23T12:46:25.000Z" title="发表于 2024-06-23 20:46:25">2024-06-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Touko" target="_blank">Touko</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["生活明朗&#44; 万物可爱&#44; 人间值得&#44; 未来可期."]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/ES2017-ES8/" style="font-size: 0.88rem;">ES2017(ES8)<sup>1</sup></a><a href="/tags/ES6/" style="font-size: 0.88rem;">ES6<sup>6</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem; font-weight: 500; color: var(--anzhiyu-lighttext)">JavaScript<sup>10</sup></a><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 0.88rem;">性能优化<sup>6</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"><a class="tag-list" href="/tags/JavaScript" title="JavaScript">JavaScript</a><a class="tag-list" href="/tags/Vue" title="Vue">Vue</a></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.2/dist/svg-pan-zoom.min.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [`叮！可爱加载中... `, `🐱`];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `%c ${ascll[0]} %c${ascll[1]}`,
      "color:white; background-color:#f0ad4e",
      ''
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "你正在访问 Touko 的博客.",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
          const svgElement = document.getElementById(mermaidID)
          const viewBox = svgElement.getAttribute('viewBox')
          const viewBoxValues = viewBox.split(/[\s,]+/)
          window.svgPanZoom ? svgPanZoom(svgElement, { contain: true, controlIconsEnabled: true }) : ''
          const width = Number(getComputedStyle(svgElement).getPropertyValue('width').slice(0, -2))
          svgElement.setAttribute('height', `${viewBoxValues[3] * width / viewBoxValues[2]}px`)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'BsIRp7GQE8IZ5fkI0JRj8Vys-gzGzoHsz',
      appKey: 'vla82YKrFnfwtuQfgoaDnzu9',
      avatar: 'mp',
      serverURLs: 'https://bsirp7gq.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://bsirp7gq.lc-cn-n1-shared.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'BsIRp7GQE8IZ5fkI0JRj8Vys-gzGzoHsz',
        "X-LC-Key": 'vla82YKrFnfwtuQfgoaDnzu9',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@touko.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>