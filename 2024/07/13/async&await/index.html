<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Async/Await：用同步的方式写异步，真香！ | Touko</title><meta name="keywords" content="JavaScript,性能优化,ES2017(ES8)"><meta name="author" content="Touko"><meta name="copyright" content="Touko"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Async/Await：用同步的方式写异步，真香！"><meta name="application-name" content="Async/Await：用同步的方式写异步，真香！"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Async/Await：用同步的方式写异步，真香！"><meta property="og:url" content="http://toukoxu.github.io/2024/07/13/async&amp;await/index.html"><meta property="og:site_name" content="Touko"><meta property="og:description" content="async&amp;#x2F;await 是 ES2017 引入的强大特性，使得处理异步操作变得更加简单和直观。使用 async 声明的函数总是返回一个 Promise，而 await 关键字则像是它的指挥棒，允许你暂停函数的执行，直到 Promise 被解决或拒绝。这种方式让异步代码看起来更像同步代码，"><meta property="og:locale" content="zh"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/async.webp"><meta property="article:author" content="Touko"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/async.webp"><meta name="description" content="async&amp;#x2F;await 是 ES2017 引入的强大特性，使得处理异步操作变得更加简单和直观。使用 async 声明的函数总是返回一个 Promise，而 await 关键字则像是它的指挥棒，允许你暂停函数的执行，直到 Promise 被解决或拒绝。这种方式让异步代码看起来更像同步代码，"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://toukoxu.github.io/2024/07/13/async&amp;await/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 科技爱好者","🔨 开发一条龙","🌌 Hello World 宇宙","⌨️ 键盘撸猫区","🐱 万物皆可rua"]},
  algolia: {"appId":"SVGIUL6D7W","apiKey":"aee53519dcfc6f122cfe52009938fc1c","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本文最后一次更新为","messageNext":"天前，文章中的某些内容可能已过时！"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Touko","link":"链接: ","source":"来源: Touko","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Touko',
  title: 'Async/Await：用同步的方式写异步，真香！',
  postAI: '',
  pageFillDescription: '前置知识, 一、Asyncx2FAwait 的本质：老熟人的默契配合, 1.1 三大核心组件, 1.2 从代码看转换逻辑, 二、自动执行器：幕后的引擎, 2.1 核心逻辑（简化版）, 2.2 执行过程图解, 三、await 到底做了什么？四步看懂它的小动作, 四、错误处理：tryx2Fcatch 居然能管到异步操作？, 4.1 同步式的错误处理, 4.2 背后的错误传递, 五、性能优化：我在项目里掉过的性能坑, 5.1 坑一：没必要的顺序执行, 5.2 坑二：多余的 await 包装, 5.3 多个异步操作：用 Promise.all()处理并行, 5.4 高级技巧：模块里的顶级 await, 六、Asyncx2FAwait 实战场景：这些地方用起来超顺手, 6.1 异步初始化（比如数据库连接）, 6.2 有依赖关系的顺序请求, 6.3 带重试的请求, 6.4 超时控制（防止请求卡太久）, 七、踩过的坑：这些细节要注意, 7.1 箭头函数的 this 陷阱, 7.2 控制并发数量, 7.3 可取消的异步任务（结合 AbortSignal）, 八、常见问题解答（我当初学的时候也纠结过）, Q1 Async 函数会阻塞主线程吗？, Q2 可以 await 一个非 Promise 值吗？, Q3 为什么 Async 函数不管 return 什么最后都返回 Promise？, Q4 用 Promise.all()的时候如果有一个请求失败怎么办？, Q5 为什么说 Asyncx2FAwait 比回调好？是引入的强大特性使得处理异步操作变得更加简单和直观使用声明的函数总是返回一个而关键字则像是它的指挥棒允许你暂停函数的执行直到被解决或拒绝这种方式让异步代码看起来更像同步代码从而提高了可读性和可维护性尤其在处理链式异步操作和错误捕获时显示出其独特的优势前置知识如果对生成器函数和不太熟悉可以先看看下面这篇了解基础后再看会更顺站内地址生成器函数与一的本质老熟人的默契配合你可能觉得是里的新黑科技但其实它的底层是三个老熟人在搭班子干活说穿了就是把咱们早就眼熟的技术组合得更顺手了三大核心组件生成器提供暂停恢复的能力就像给函数装了个暂停键处理异步操作的标准接口负责管理异步结果自动执行器默默工作的调度员悄悄驱动生成器跑完全程从代码看转换逻辑咱们写的函数其实会被引擎偷偷转换成类似生成器的结构比如这样一段代码咱们写的优雅代码引擎背地里会把它转成差不多这样简化版引擎实际处理的样子就是那个自动执行器负责驱动生成器用代替这里有个小细节每个函数都被转换成一个生成器函数由自动执行器接管执行咱们不用手动调用全是执行器在后台搞定这也是比直接用方便的地方二自动执行器幕后的引擎自动执行器是能自动跑起来的关键我试着简化了它的核心代码大概长这样核心逻辑简化版返回一个这也是函数总返回的原因创建生成器实例步进函数驱动生成器一步步执行执行到下一个生成器跑完了把结果传给把后的结果包装成不管是不是成功了就把结果传给下一次继续执行失败了就把错误抛回生成器让接住捕获生成器内部的错误启动生成器执行过程图解我画了个流程图帮大家理解其实就是执行器在中间当裁判协调生成器和异步操作调用者函数执行器生成器调用者函数调用函数执行器麻烦帮我跑一下这个生成器执行器生成器开始执行咯调用生成器执行器遇到了先停在这返回的值执行器等你结果出来喊我执行器搞定结果在这执行器生成器继续跑吧这是刚才的结果调用结果生成器执行器跑完了这是最终结果执行器调用者任务完成给你结果简单说就是执行器启动生成器后每次遇到也就是咱们写的就停下来等异步结果拿到结果再叫醒生成器继续跑直到结束全程不用手动干预比直接用省太多事了三到底做了什么四步看懂它的小动作每次写的时候引擎其实在背后干了四件事我拆开来给大家说说暂停当前函数就像按了暂停键当前的变量执行位置都被冻起来包装异步结果不管后面是还是普通值比如都会被转成普通值会被包一层确保统一用处理注册回调把后面的代码比如拿到后处理的逻辑打包成一个微任务注册到事件循环里让出主线程当前函数暂停后主线程会去执行其他任务比如渲染处理其他事件等有结果了再回头执行刚才打包的微任务这里有个性能小细节不会阻塞主线程它只是把后续代码挂起包装成微任务让主线程先忙别的这也是为什么用的时候页面不会卡因为它会主动让道四错误处理居然能管到异步操作这是我觉得最方便的一点用同步代码里的就能搞定异步错误不用像回调那样嵌套多层处理同步式的错误处理可能失败依赖上一步结果也可能失败不管哪一步失败都会跑到这里请求失败背后的错误传递为什么能抓到异步错误秘密在自动执行器的这段代码里自动执行器处理的部分成功就传结果继续执行失败就把错误抛回生成器当后面的失败时执行器会调用把错误扔回生成器函数内部这时候生成器里的就会像捕获同步错误一样把这个异步错误接住之前用回调的时候每次异步操作都要单独写处理现在一个全搞定代码清爽多了五性能优化我在项目里掉过的性能坑分享几个我实际开发中遇到的问题都是关于性能的新手很容易踩坑坑一没必要的顺序执行反面例子两个请求本来可以同时跑却写成了顺序执行等完了才开始这两个请求如果没依赖关系比如不影响的参数完全可以同时启动我后来改成这样优化后同时启动两个请求总耗时是最慢那个的时间先同时发起请求拿到两个再等它们结果坑二多余的包装有时候会下意识地在前面加但其实没必要多余的本身已经返回因为函数会自动把返回值包成这里的纯属多此一举直接就行更简洁高效等价于上面的写法但少一层包装多个异步操作用处理并行如果需要等多个异步操作都完成配合是绝配下面的写法在实际项目中会经常用到哦同时启动等所有请求完成不过要注意是一损俱损只要有一个请求失败整个就会报错这时候可以用处理需要全部结果的场景哪怕部分失败高级技巧模块里的顶级现在很多打包工具比如已经支持模块顶层的了不用再包在函数里直接在模块顶层用加载配置其实引擎会把模块转成类似这样我在做一个工具库的时候用过这个用来加载动态配置比以前用立即执行函数清爽多了六实战场景这些地方用起来超顺手异步初始化比如数据库连接静态方法做异步初始化建立连接异步使用的时候直接这种场景如果用回调很容易写成嵌套的回调用就清晰多了有依赖关系的顺序请求比如先拿用户再用查订单先查用户再查商品验证能否购买异步生成订单步骤再复杂用顺序写出来也像同步代码一样好懂带重试的请求处理可能偶尔失败的接口时用写重试逻辑很直观重试次数用完等秒再重试递归重试我在对接一个不稳定的第三方接口时就用这个逻辑做了重试成功率提高了不少超时控制防止请求卡太久结合实现超时控制超时请求超时谁先完成就用谁的结果这个在做支付回调的时候特别有用防止因为网络问题让用户一直等七踩过的坑这些细节要注意箭头函数的陷阱用箭头函数当对象方法时会丢有问题指向不对因为箭头函数的是定义时的上下文正确写法用传统函数指向我在写一个类的方法时犯过这个错调试了半天才发现是箭头函数的锅控制并发数量如果并行请求太多比如一次发个接口可能会触发浏览器的并发限制这时候需要控制并发数所有任务控制最多同时跑个这里的是一个工具函数原理是把任务分成多批一批批执行每批个避免一次性发起太多请求可取消的异步任务结合有时候需要中途取消异步操作比如用户离开页面可以用每次做一点工作每次循环检查退出信号做清理工作启动长时间运行的任务中止任务设置一个定时器以便在秒后中止任务我在做一个文件上传组件时用过这个用户点取消按钮时就通过终止上传八常见问题解答我当初学的时候也纠结过函数会阻塞主线程吗不会函数遇到时会暂停并释放主线程的单线程模型通过事件循环实现异步执行开始假设是个等待秒的结束执行到时函数会暂停主线程可以去处理其他任务比如点击事件渲染等秒后才回头执行结束所以不会卡页面可以一个非值吗可以引擎会自动用包装非值合法等价于不过实际开发中很少这么用一般后面都是异步操作返回的为什么函数不管什么最后都返回因为它本质是异步操作的包装器哪怕你一个原始值引擎也会用包一层等价于所以调用函数时必须用或者才能拿到结果用的时候如果有一个请求失败怎么办之前已经提到过了会快速失败只要有一个被拒绝整个就会立刻失败进入如果需要等所有请求完成不管成功失败可以用过滤出成功的结果为什么说比回调好我总结了几个实际开发中的感受代码不嵌套扁平结构更易读告别回调地狱错误处理统一用不用每层回调都写处理逻辑顺序和代码执行顺序一致不用跳来跳去看代码调试更方便错误堆栈更完整回调的堆栈经常被异步操作打断其实不算什么高深的技术就是把这些老东西包装得更好用了但正是这种语法糖让我们写异步代码时能少掉很多头发如果你也有过用踩坑的经历欢迎在评论区分享呀',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-13 20:46:25',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link href="https://fonts.cdnfonts.com/css/shina-baby" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/site/loading.webp"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Touko</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/wechat.webp" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/wechat.webp"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/alipay.webp" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/alipay.webp"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/ES2017-ES8/" style="font-size: 1.05rem;">ES2017(ES8)<sup>1</sup></a><a href="/tags/ES6/" style="font-size: 1.05rem;">ES6<sup>6</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>10</sup></a><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 1.05rem;">性能优化<sup>6</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">August 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">July 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">June 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">February 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">May 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/04/"><span class="card-archive-list-date">April 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/03/"><span class="card-archive-list-date">March 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JavaScript/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JavaScript</span></a><a class="article-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>性能优化</span></a><a class="article-meta__tags" href="/tags/ES2017-ES8/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>ES2017(ES8)</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Async/Await：用同步的方式写异步，真香！</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-07-13T12:46:25.000Z" title="发表于 2024-07-13 20:46:25">2024-07-13</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-07-13T12:46:25.000Z" title="更新于 2024-07-13 20:46:25">2024-07-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">3.7k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为上海"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>上海</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/async.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://toukoxu.github.io/2024/07/13/async&amp;await/"><header><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a><a href="/tags/JavaScript/" tabindex="-1" itemprop="url">JavaScript</a><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" tabindex="-1" itemprop="url">性能优化</a><a href="/tags/ES2017-ES8/" tabindex="-1" itemprop="url">ES2017(ES8)</a><h1 id="CrawlerTitle" itemprop="name headline">Async/Await：用同步的方式写异步，真香！</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Touko</span><time itemprop="dateCreated datePublished" datetime="2024-07-13T12:46:25.000Z" title="发表于 2024-07-13 20:46:25">2024-07-13</time><time itemprop="dateCreated datePublished" datetime="2024-07-13T12:46:25.000Z" title="更新于 2024-07-13 20:46:25">2024-07-13</time></header><blockquote>
<p>async&#x2F;await 是 ES2017 引入的强大特性，使得处理异步操作变得更加简单和直观。使用 async 声明的函数总是返回一个 Promise，而 await 关键字则像是它的指挥棒，允许你暂停函数的执行，直到 Promise 被解决或拒绝。这种方式让异步代码看起来更像同步代码，从而提高了可读性和可维护性。尤其在处理链式异步操作和错误捕获时，async&#x2F;await 显示出其独特的优势。</p>
</blockquote>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>如果对生成器函数和 yield 不太熟悉，可以先看看下面这篇，了解基础后再看 Async&#x2F;Await 会更顺～</p>
<div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="/2024/07/11/generator">
    <div class="tag-link-tips">站内地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(/img/512.png)">
          <i class="anzhiyufont anzhiyu-icon-link" style="display: none"></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">生成器函数与 yield</div>
            <div class="tag-link-sitename"> Touko</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<h2 id="一、Async-Await-的本质：老熟人的默契配合"><a href="#一、Async-Await-的本质：老熟人的默契配合" class="headerlink" title="一、Async&#x2F;Await 的本质：老熟人的默契配合"></a>一、Async&#x2F;Await 的本质：老熟人的默契配合</h2><p>你可能觉得 Async&#x2F;Await 是 JavaScript 里的“新黑科技”，但其实它的底层是三个老熟人在搭班子干活。说穿了，就是把咱们早就眼熟的技术组合得更顺手了。</p>
<h3 id="1-1-三大核心组件"><a href="#1-1-三大核心组件" class="headerlink" title="1.1 三大核心组件"></a>1.1 三大核心组件</h3><ul>
<li><strong>Generator（生成器）</strong>：提供<strong>暂停-恢复</strong>的能力，就像给函数装了个暂停键</li>
<li><strong>Promise</strong>：处理<strong>异步操作</strong>的“标准接口”，负责管理异步结果</li>
<li><strong>自动执行器</strong>：默默工作的<strong>调度员</strong>，悄悄驱动生成器跑完全程</li>
</ul>
<h3 id="1-2-从代码看转换逻辑"><a href="#1-2-从代码看转换逻辑" class="headerlink" title="1.2 从代码看转换逻辑"></a>1.2 从代码看转换逻辑</h3><p>咱们写的 Async 函数，其实会被引擎偷偷转换成类似生成器的结构。比如这样一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 咱们写的优雅代码</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> api.<span class="title function_">get</span>(<span class="string">&#x27;/data&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">process</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引擎背地里会把它转成差不多这样（简化版）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引擎实际处理的样子</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// spawn就是那个自动执行器，负责驱动生成器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">yield</span> api.<span class="title function_">get</span>(<span class="string">&#x27;/data&#x27;</span>); <span class="comment">// 用yield代替await</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">process</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info flat"><p><strong>这里有个小细节：</strong> 每个Async函数都被转换成一个生成器函数，由<mark>自动执行器</mark>接管执行！</p>咱们不用手动调用<code>next()</code>，全是执行器在后台搞定，这也是<code>Async/Await</code>比直接用<code>Generator</code>方便的地方～</div>

<h2 id="二、自动执行器：幕后的引擎"><a href="#二、自动执行器：幕后的引擎" class="headerlink" title="二、自动执行器：幕后的引擎"></a>二、自动执行器：幕后的引擎</h2><p>自动执行器是 Async&#x2F;Await 能自动跑起来的关键，我试着简化了它的核心代码，大概长这样：</p>
<h3 id="2-1-核心逻辑（简化版）"><a href="#2-1-核心逻辑（简化版）" class="headerlink" title="2.1 核心逻辑（简化版）"></a>2.1 核心逻辑（简化版）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">spawn</span>(<span class="params">generatorFunc</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回一个Promise，这也是async函数总返回Promise的原因</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> generator = <span class="title function_">generatorFunc</span>(); <span class="comment">// 创建生成器实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步进函数：驱动生成器一步步执行</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">nextFn</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = <span class="title function_">nextFn</span>(); <span class="comment">// 执行到下一个yield</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">          <span class="comment">// 生成器跑完了，把结果传给Promise</span></span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">resolve</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把yield后的结果包装成Promise（不管是不是Promise）</span></span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(</span><br><span class="line">          <span class="comment">// 成功了就把结果传给下一次next()，继续执行</span></span><br><span class="line">          <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="title function_">step</span>(<span class="function">() =&gt;</span> generator.<span class="title function_">next</span>(v)),</span><br><span class="line">          <span class="comment">// 失败了就把错误抛回生成器，让try/catch接住</span></span><br><span class="line">          <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="title function_">step</span>(<span class="function">() =&gt;</span> generator.<span class="keyword">throw</span>(e))</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 捕获生成器内部的错误</span></span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动生成器</span></span><br><span class="line">    <span class="title function_">step</span>(<span class="function">() =&gt;</span> generator.<span class="title function_">next</span>());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-执行过程图解"><a href="#2-2-执行过程图解" class="headerlink" title="2.2 执行过程图解"></a>2.2 执行过程图解</h3><p>我画了个流程图帮大家理解，其实就是执行器在中间当“裁判”，协调生成器和异步操作：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  sequenceDiagram
participant 调用者
participant Async 函数
participant 执行器
participant 生成器

    调用者-&gt;&gt;Async函数: 调用 asyncFunc()
    Async函数-&gt;&gt;执行器: “麻烦帮我跑一下这个生成器”
    执行器-&gt;&gt;生成器: “开始执行咯（调用next()）”
    生成器--&gt;&gt;执行器: “遇到await了，先停在这”（返回yield的值）
    执行器-&gt;&gt;Promise: “等你结果出来喊我”
    Promise--&gt;&gt;执行器: “搞定，结果在这”
    执行器-&gt;&gt;生成器:  “继续跑吧，这是刚才的结果”（调用next(结果)）
    生成器--&gt;&gt;执行器: “跑完了，这是最终结果”
    执行器-&gt;&gt;调用者: “任务完成，给你结果”（Promise resolved）

  </pre></div>

<p>简单说就是：执行器启动生成器后，每次遇到 yield（也就是咱们写的 await）就停下来等异步结果，拿到结果再叫醒生成器继续跑，直到结束。全程不用手动干预，比直接用 Generator 省太多事了～</p>
<h2 id="三、await-到底做了什么？四步看懂它的“小动作”"><a href="#三、await-到底做了什么？四步看懂它的“小动作”" class="headerlink" title="三、await 到底做了什么？四步看懂它的“小动作”"></a>三、await 到底做了什么？四步看懂它的“小动作”</h2><p>每次写<code>await</code>的时候，引擎其实在背后干了四件事，我拆开来给大家说说：</p>
<ol>
<li><strong>暂停当前函数</strong>：就像按了暂停键，当前的变量、执行位置都被“冻”起来</li>
<li><strong>包装异步结果</strong>：不管 await 后面是 Promise 还是普通值（比如 await 42），都会被转成 Promise。普通值会被 Promise.resolve()包一层，确保统一用 Promise 处理</li>
<li><strong>注册回调</strong>：把 await 后面的代码（比如拿到 data 后处理的逻辑）打包成一个微任务，注册到事件循环里</li>
<li><strong>让出主线程</strong>：当前函数暂停后，主线程会去执行其他任务（比如渲染、处理其他事件），等 Promise 有结果了，再回头执行刚才打包的微任务</li>
</ol>
<div class="note info flat"><p><strong>这里有个性能小细节：</strong> <code>await</code>不会阻塞主线程！它只是把后续代码挂起（包装成<mark>微任务</mark>），让主线程先忙别的。这也是为什么用<code>await</code>的时候，页面不会卡——因为它会主动“让道”。</p>
</div>

<h2 id="四、错误处理：try-catch-居然能管到异步操作？"><a href="#四、错误处理：try-catch-居然能管到异步操作？" class="headerlink" title="四、错误处理：try&#x2F;catch 居然能管到异步操作？"></a>四、错误处理：try&#x2F;catch 居然能管到异步操作？</h2><p>这是我觉得 Async&#x2F;Await 最方便的一点：用同步代码里的 try&#x2F;catch 就能搞定异步错误，不用像回调那样嵌套多层 error 处理。</p>
<h3 id="4-1-同步式的错误处理"><a href="#4-1-同步式的错误处理" class="headerlink" title="4.1 同步式的错误处理"></a>4.1 同步式的错误处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/user&#x27;</span>); <span class="comment">// 可能失败</span></span><br><span class="line">    <span class="keyword">const</span> posts = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`/posts/<span class="subst">$&#123;user.id&#125;</span>`</span>); <span class="comment">// 依赖上一步结果，也可能失败</span></span><br><span class="line">    <span class="keyword">return</span> &#123; user, posts &#125;;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 不管哪一步失败，都会跑到这里</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求失败:&#x27;</span>, error);</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">user</span>: <span class="literal">null</span>, <span class="attr">posts</span>: [] &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-背后的错误传递"><a href="#4-2-背后的错误传递" class="headerlink" title="4.2 背后的错误传递"></a>4.2 背后的错误传递</h3><p>为什么 try&#x2F;catch 能抓到异步错误？秘密在自动执行器的这段代码里：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动执行器处理Promise的部分</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="title function_">step</span>(<span class="function">() =&gt;</span> generator.<span class="title function_">next</span>(v)), <span class="comment">// 成功就传结果继续执行</span></span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="title function_">step</span>(<span class="function">() =&gt;</span> generator.<span class="keyword">throw</span>(e)) <span class="comment">// 失败就把错误抛回生成器！</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>当 await 后面的 Promise 失败时，执行器会调用<code>generator.throw(e)</code>，把错误“扔回”生成器函数内部。这时候生成器里的 try&#x2F;catch 就会像捕获同步错误一样，把这个异步错误接住。</p>
<blockquote>
<p>之前用回调的时候，每次异步操作都要单独写 error 处理，现在一个 try&#x2F;catch 全搞定，代码清爽多了～</p>
</blockquote>
<h2 id="五、性能优化：我在项目里掉过的性能坑"><a href="#五、性能优化：我在项目里掉过的性能坑" class="headerlink" title="五、性能优化：我在项目里掉过的性能坑"></a>五、性能优化：我在项目里掉过的性能坑</h2><p>分享几个我实际开发中遇到的问题，都是关于 Async&#x2F;Await 性能的，新手很容易踩坑：</p>
<h3 id="5-1-坑一：没必要的顺序执行"><a href="#5-1-坑一：没必要的顺序执行" class="headerlink" title="5.1 坑一：没必要的顺序执行"></a>5.1 坑一：没必要的顺序执行</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反面例子：两个请求本来可以同时跑，却写成了顺序执行</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">slowFetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">await</span> <span class="title function_">fetchA</span>();</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">await</span> <span class="title function_">fetchB</span>(); <span class="comment">// 等A完了才开始B</span></span><br><span class="line">  <span class="keyword">return</span> [a, b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个请求如果没依赖关系（比如 A 不影响 B 的参数），完全可以同时启动，我后来改成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化后：同时启动两个请求，总耗时是最慢那个的时间</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fastFetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 先同时发起请求，拿到两个Promise</span></span><br><span class="line">  <span class="keyword">const</span> promiseA = <span class="title function_">fetchA</span>();</span><br><span class="line">  <span class="keyword">const</span> promiseB = <span class="title function_">fetchB</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再等它们结果</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">await</span> promiseA;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">await</span> promiseB;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [a, b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-坑二：多余的-await-包装"><a href="#5-2-坑二：多余的-await-包装" class="headerlink" title="5.2 坑二：多余的 await 包装"></a>5.2 坑二：多余的 await 包装</h3><p>有时候会下意识地在 return 前面加 await，但其实没必要：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多余的await</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">fetchData</span>(); <span class="comment">// fetchData本身已经返回Promise</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 Async 函数会自动把返回值包成 Promise，这里的 await 纯属多此一举，直接 return 就行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更简洁高效</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetchData</span>(); <span class="comment">// 等价于上面的写法，但少一层Promise包装</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-多个异步操作：用-Promise-all-处理并行"><a href="#5-3-多个异步操作：用-Promise-all-处理并行" class="headerlink" title="5.3 多个异步操作：用 Promise.all()处理并行"></a>5.3 多个异步操作：用 Promise.all()处理并行</h3><p>如果需要等多个异步操作都完成，<code>Promise.all()</code>配合 await 是绝配，下面的写法在实际项目中会经常用到哦~</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 同时启动，等所有请求完成</span></span><br><span class="line">  <span class="keyword">const</span> [user, posts] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">fetch</span>(<span class="string">&#x27;/user&#x27;</span>), <span class="title function_">fetch</span>(<span class="string">&#x27;/posts&#x27;</span>)]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; user, posts &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning flat"><p><strong>不过要注意：</strong> <code>Promise.all()</code>是“一损俱损”，只要有一个请求失败，整个就会报错，这时候可以用<code>Promise.allSettled()</code>处理需要全部结果的场景（哪怕部分失败）。</p>
</div>

<h3 id="5-4-高级技巧：模块里的顶级-await"><a href="#5-4-高级技巧：模块里的顶级-await" class="headerlink" title="5.4 高级技巧：模块里的顶级 await"></a>5.4 高级技巧：模块里的顶级 await</h3><p>现在很多打包工具（比如 Webpack、Vite）已经支持模块顶层的 await 了，不用再包在 Async 函数里：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接在模块顶层用await</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="keyword">await</span> <span class="title function_">loadConfig</span>(); <span class="comment">// 加载配置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> settings = <span class="title function_">process</span>(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实引擎会把模块转成类似这样</span></span><br><span class="line"><span class="title function_">loadConfig</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> settings = <span class="title function_">process</span>(config);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我在做一个工具库的时候用过这个，用来加载动态配置，比以前用 IIFE（立即执行函数）清爽多了。</p>
<h2 id="六、Async-Await-实战场景：这些地方用起来超顺手"><a href="#六、Async-Await-实战场景：这些地方用起来超顺手" class="headerlink" title="六、Async&#x2F;Await 实战场景：这些地方用起来超顺手"></a>六、Async&#x2F;Await 实战场景：这些地方用起来超顺手</h2><h3 id="6-1-异步初始化（比如数据库连接）"><a href="#6-1-异步初始化（比如数据库连接）" class="headerlink" title="6.1 异步初始化（比如数据库连接）"></a>6.1 异步初始化（比如数据库连接）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span> &#123;</span><br><span class="line">  <span class="comment">// 静态方法做异步初始化</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">await</span> <span class="title function_">createConnection</span>(); <span class="comment">// 建立连接（异步）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Database</span>(connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候直接await</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="keyword">await</span> <span class="title class_">Database</span>.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure>

<p>这种场景如果用回调，很容易写成嵌套的 init 回调，用 Async&#x2F;Await 就清晰多了。</p>
<h3 id="6-2-有依赖关系的顺序请求"><a href="#6-2-有依赖关系的顺序请求" class="headerlink" title="6.2 有依赖关系的顺序请求"></a>6.2 有依赖关系的顺序请求</h3><p>比如先拿用户 ID，再用 ID 查订单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">purchase</span>(<span class="params">itemId</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title function_">getUser</span>(); <span class="comment">// 先查用户</span></span><br><span class="line">  <span class="keyword">const</span> item = <span class="keyword">await</span> <span class="title function_">getItem</span>(itemId); <span class="comment">// 再查商品</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">validatePurchase</span>(user, item); <span class="comment">// 验证能否购买（异步）</span></span><br><span class="line">  <span class="keyword">const</span> receipt = <span class="keyword">await</span> <span class="title function_">createReceipt</span>(user, item); <span class="comment">// 生成订单</span></span><br><span class="line">  <span class="keyword">return</span> receipt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤再复杂，用顺序 await 写出来也像同步代码一样好懂。</p>
<h3 id="6-3-带重试的请求"><a href="#6-3-带重试的请求" class="headerlink" title="6.3 带重试的请求"></a>6.3 带重试的请求</h3><p>处理可能偶尔失败的接口时，用 Async&#x2F;Await 写重试逻辑很直观：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchWithRetry</span>(<span class="params">url, retries = <span class="number">3</span></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (retries &lt;= <span class="number">0</span>) <span class="keyword">throw</span> error; <span class="comment">// 重试次数用完</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">delay</span>(<span class="number">1000</span>); <span class="comment">// 等1秒再重试</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetchWithRetry</span>(url, retries - <span class="number">1</span>); <span class="comment">// 递归重试</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在对接一个不稳定的第三方接口时，就用这个逻辑做了重试，成功率提高了不少。</p>
<h3 id="6-4-超时控制（防止请求卡太久）"><a href="#6-4-超时控制（防止请求卡太久）" class="headerlink" title="6.4 超时控制（防止请求卡太久）"></a>6.4 超时控制（防止请求卡太久）</h3><p>结合<code>Promise.race()</code>实现超时控制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchWithTimeout</span>(<span class="params">url, timeout = <span class="number">5000</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(url);</span><br><span class="line">  <span class="comment">// 超时Promise</span></span><br><span class="line">  <span class="keyword">const</span> timeoutPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">_, reject</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求超时&#x27;</span>)), timeout)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 谁先完成就用谁的结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>([fetchPromise, timeoutPromise]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个在做支付回调的时候特别有用，防止因为网络问题让用户一直等。</p>
<h2 id="七、踩过的坑：这些细节要注意"><a href="#七、踩过的坑：这些细节要注意" class="headerlink" title="七、踩过的坑：这些细节要注意"></a>七、踩过的坑：这些细节要注意</h2><h3 id="7-1-箭头函数的-this-陷阱"><a href="#7-1-箭头函数的-this-陷阱" class="headerlink" title="7.1 箭头函数的 this 陷阱"></a>7.1 箭头函数的 this 陷阱</h3><p>用 Async 箭头函数当对象方法时，<code>this</code>会丢：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有问题：this指向不对</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">print</span>: <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// undefined! 因为箭头函数的this是定义时的上下文</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法：用传统函数</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// 42，this指向obj</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我在写一个类的方法时犯过这个错，调试了半天才发现是箭头函数的锅。</p>
<h3 id="7-2-控制并发数量"><a href="#7-2-控制并发数量" class="headerlink" title="7.2 控制并发数量"></a>7.2 控制并发数量</h3><p>如果并行请求太多（比如一次发 20 个接口），可能会触发浏览器的并发限制，这时候需要控制并发数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">processBatch</span>(<span class="params">items</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promises = items.<span class="title function_">map</span>(processItem); <span class="comment">// 所有任务</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 控制最多同时跑5个</span></span><br><span class="line">  <span class="keyword">const</span> results = <span class="keyword">await</span> <span class="title function_">throttlePromises</span>(promises, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>throttlePromises</code>是一个工具函数，原理是把任务分成多批，一批批执行（每批 5 个），避免一次性发起太多请求。</p>
<h3 id="7-3-可取消的异步任务（结合-AbortSignal）"><a href="#7-3-可取消的异步任务（结合-AbortSignal）" class="headerlink" title="7.3 可取消的异步任务（结合 AbortSignal）"></a>7.3 可取消的异步任务（结合 AbortSignal）</h3><p>有时候需要中途取消异步操作（比如用户离开页面），可以用<code>AbortSignal</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">longRunningTask</span>(<span class="params">abortSignal</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!abortSignal.<span class="property">aborted</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">doWork</span>();<span class="comment">// 每次做一点工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次循环检查退出信号</span></span><br><span class="line">    <span class="keyword">if</span> (abortSignal.<span class="property">aborted</span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">cleanup</span>(); <span class="comment">// 做清理工作</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">const</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动长时间运行的任务</span></span><br><span class="line"><span class="title function_">longRunningTask</span>(signal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> cancelTask &#123;</span><br><span class="line">  controller.<span class="title function_">abort</span>(); <span class="comment">// 中止任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个定时器，以便在 3 秒后中止任务</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">cancelTask</span>();</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>我在做一个文件上传组件时用过这个，用户点取消按钮时，就通过<code>AbortSignal</code>终止上传。</p>
<h2 id="八、常见问题解答（我当初学的时候也纠结过）"><a href="#八、常见问题解答（我当初学的时候也纠结过）" class="headerlink" title="八、常见问题解答（我当初学的时候也纠结过）"></a>八、常见问题解答（我当初学的时候也纠结过）</h2><h3 id="Q1-Async-函数会阻塞主线程吗？"><a href="#Q1-Async-函数会阻塞主线程吗？" class="headerlink" title="Q1: Async 函数会阻塞主线程吗？"></a>Q1: Async 函数会阻塞主线程吗？</h3><p><strong>不会！</strong> Async 函数遇到 await 时会<strong>暂停并释放主线程</strong>，JavaScript 的单线程模型通过事件循环实现异步执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">delay</span>(<span class="number">1000</span>); <span class="comment">// 假设delay是个等待1秒的Promise</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到 await 时，函数会暂停，主线程可以去处理其他任务（比如点击事件、渲染），等 1 秒后才回头执行 console.log(‘结束’)，所以不会卡页面。</p>
<h3 id="Q2-可以-await-一个非-Promise-值吗？"><a href="#Q2-可以-await-一个非-Promise-值吗？" class="headerlink" title="Q2: 可以 await 一个非 Promise 值吗？"></a>Q2: 可以 await 一个非 Promise 值吗？</h3><p><strong>可以！</strong> 引擎会自动用 <code>Promise.resolve()</code> 包装非 Promise 值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getNumber</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> num = <span class="keyword">await</span> <span class="number">42</span>; <span class="comment">// 合法！等价于 await Promise.resolve(42)</span></span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过实际开发中很少这么用，一般 await 后面都是异步操作返回的 Promise。</p>
<h3 id="Q3-为什么-Async-函数不管-return-什么，最后都返回-Promise？"><a href="#Q3-为什么-Async-函数不管-return-什么，最后都返回-Promise？" class="headerlink" title="Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？"></a>Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？</h3><p>因为它本质是异步操作的包装器。哪怕你 return 一个原始值，引擎也会用 Promise.resolve()包一层：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">answer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// 等价于 return Promise.resolve(42)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以调用 Async 函数时，必须用<code>await</code>或者<code>.then()</code>才能拿到结果。</p>
<h3 id="Q4-用-Promise-all-的时候，如果有一个请求失败怎么办？"><a href="#Q4-用-Promise-all-的时候，如果有一个请求失败怎么办？" class="headerlink" title="Q4: 用 Promise.all()的时候，如果有一个请求失败怎么办？"></a>Q4: 用 Promise.all()的时候，如果有一个请求失败怎么办？</h3><p>之前已经提到过了，Promise.all()会“快速失败”——只要有一个 Promise 被拒绝，整个 Promise.all()就会立刻失败，进入 catch。如果需要等所有请求完成（不管成功失败），可以用<code>Promise.allSettled()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([<span class="title function_">fetchA</span>(), <span class="title function_">fetchB</span>()]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 过滤出成功的结果</span></span><br><span class="line">  <span class="keyword">const</span> successData = results</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> r.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> r.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Q5-为什么说-Async-Await-比回调好？"><a href="#Q5-为什么说-Async-Await-比回调好？" class="headerlink" title="Q5: 为什么说 Async&#x2F;Await 比回调好？"></a>Q5: 为什么说 Async&#x2F;Await 比回调好？</h3><p>我总结了几个实际开发中的感受：</p>
<ul>
<li>代码不嵌套，扁平结构更易读（告别“回调地狱”）</li>
<li>错误处理统一用 try&#x2F;catch，不用每层回调都写 error 处理</li>
<li>逻辑顺序和代码执行顺序一致，不用跳来跳去看代码</li>
<li>调试更方便，错误堆栈更完整（回调的堆栈经常被异步操作打断）</li>
</ul>
<hr>
<p>其实 Async&#x2F;Await 不算什么高深的技术，就是把 Generator、Promise 这些老东西包装得更好用了。但正是这种“语法糖”，让我们写异步代码时能少掉很多头发～ 如果你也有过用 Async&#x2F;Await 踩坑的经历，欢迎在评论区分享呀！</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/site/avatar.webp" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/site/avatar.webp" title="头像" alt="头像"></a><div class="post-copyright__author_name">Touko</div><div class="post-copyright__author_desc">🐾猫爪按日出, 按出彩虹糖🌈</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://toukoxu.github.io/2024/07/13/async&amp;await/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://toukoxu.github.io/2024/07/13/async&amp;await/')">Async/Await：用同步的方式写异步，真香！</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/wechat.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/wechat.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/alipay.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/alipay.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://toukoxu.github.io/2024/07/13/async&amp;await/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://toukoxu.github.io" target="_blank">Touko</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>前端<span class="categoryesPageCount">10</span></a><a class="post-meta__box__categoryes" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>学习笔记<span class="categoryesPageCount">9</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JavaScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JavaScript<span class="tagsPageCount">10</span></a><a class="post-meta__box__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>性能优化<span class="tagsPageCount">6</span></a><a class="post-meta__box__tags" href="/tags/ES2017-ES8/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>ES2017(ES8)<span class="tagsPageCount">1</span></a></div></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/11/generator/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/generator.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">生成器函数与 yield：掌控函数执行的“暂停键”</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/14/reflect/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/reflect.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Reflect：ES6 标准化对象操作的“工具库”</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2022/02/01/event/" title="JS 事件系统完全指南与性能优化"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/event.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-02-01</div><div class="title">JS 事件系统完全指南与性能优化</div></div></a></div><div><a href="/2024/06/23/message-channel/" title="MessageChannel 详解：浏览器中的“点对点双向通信管道”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/message-channel.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-23</div><div class="title">MessageChannel 详解：浏览器中的“点对点双向通信管道”</div></div></a></div><div><a href="/2021/05/02/prototype-chain/" title="原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/prototype-chain.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-05-02</div><div class="title">原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心</div></div></a></div><div><a href="/2024/08/15/proxy/" title="代理（Proxy）：ES6 元编程的“对象拦截器”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/proxy.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-08-15</div><div class="title">代理（Proxy）：ES6 元编程的“对象拦截器”</div></div></a></div><div><a href="/2021/03/16/scope-chain/" title="作用域链（Scope Chain）：JS 变量查找的“路线图”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/scope-chain.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-03-16</div><div class="title">作用域链（Scope Chain）：JS 变量查找的“路线图”</div></div></a></div><div><a href="/2021/04/03/closure/" title="闭包（Closure）：JavaScript 里的“记忆小助手”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/closure.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-04-03</div><div class="title">闭包（Closure）：JavaScript 里的“记忆小助手”</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/site/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/emoji/sparkles.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">欢迎来到我的<b style="color:#fff">编程小天地</b>！这里有可爱的<b style="color:#fff">编程知识点</b>，致力于把复杂的概念变得<b style="color:#fff">简单可爱</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">一起探索，让代码生活更精彩！</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Touko</h1><div class="author-info__desc">🐾猫爪按日出, 按出彩虹糖🌈</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/ToukoXu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">😊 欢迎来看我的博客鸭~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">前置知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Async-Await-%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E8%80%81%E7%86%9F%E4%BA%BA%E7%9A%84%E9%BB%98%E5%A5%91%E9%85%8D%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">一、Async&#x2F;Await 的本质：老熟人的默契配合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 三大核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BB%8E%E4%BB%A3%E7%A0%81%E7%9C%8B%E8%BD%AC%E6%8D%A2%E9%80%BB%E8%BE%91"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 从代码看转换逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9A%E5%B9%95%E5%90%8E%E7%9A%84%E5%BC%95%E6%93%8E"><span class="toc-number">3.</span> <span class="toc-text">二、自动执行器：幕后的引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 核心逻辑（简化版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 执行过程图解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81await-%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9B%9B%E6%AD%A5%E7%9C%8B%E6%87%82%E5%AE%83%E7%9A%84%E2%80%9C%E5%B0%8F%E5%8A%A8%E4%BD%9C%E2%80%9D"><span class="toc-number">4.</span> <span class="toc-text">三、await 到底做了什么？四步看懂它的“小动作”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9Atry-catch-%E5%B1%85%E7%84%B6%E8%83%BD%E7%AE%A1%E5%88%B0%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">四、错误处理：try&#x2F;catch 居然能管到异步操作？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%90%8C%E6%AD%A5%E5%BC%8F%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 同步式的错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%83%8C%E5%90%8E%E7%9A%84%E9%94%99%E8%AF%AF%E4%BC%A0%E9%80%92"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 背后的错误传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E6%88%91%E5%9C%A8%E9%A1%B9%E7%9B%AE%E9%87%8C%E6%8E%89%E8%BF%87%E7%9A%84%E6%80%A7%E8%83%BD%E5%9D%91"><span class="toc-number">6.</span> <span class="toc-text">五、性能优化：我在项目里掉过的性能坑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%9D%91%E4%B8%80%EF%BC%9A%E6%B2%A1%E5%BF%85%E8%A6%81%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 坑一：没必要的顺序执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%9D%91%E4%BA%8C%EF%BC%9A%E5%A4%9A%E4%BD%99%E7%9A%84-await-%E5%8C%85%E8%A3%85"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 坑二：多余的 await 包装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%9A%E7%94%A8-Promise-all-%E5%A4%84%E7%90%86%E5%B9%B6%E8%A1%8C"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 多个异步操作：用 Promise.all()处理并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%EF%BC%9A%E6%A8%A1%E5%9D%97%E9%87%8C%E7%9A%84%E9%A1%B6%E7%BA%A7-await"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 高级技巧：模块里的顶级 await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Async-Await-%E5%AE%9E%E6%88%98%E5%9C%BA%E6%99%AF%EF%BC%9A%E8%BF%99%E4%BA%9B%E5%9C%B0%E6%96%B9%E7%94%A8%E8%B5%B7%E6%9D%A5%E8%B6%85%E9%A1%BA%E6%89%8B"><span class="toc-number">7.</span> <span class="toc-text">六、Async&#x2F;Await 实战场景：这些地方用起来超顺手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%BC%82%E6%AD%A5%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E6%AF%94%E5%A6%82%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 异步初始化（比如数据库连接）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%9C%89%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%AF%B7%E6%B1%82"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 有依赖关系的顺序请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%B8%A6%E9%87%8D%E8%AF%95%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 带重试的请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6%EF%BC%88%E9%98%B2%E6%AD%A2%E8%AF%B7%E6%B1%82%E5%8D%A1%E5%A4%AA%E4%B9%85%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 超时控制（防止请求卡太久）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%EF%BC%9A%E8%BF%99%E4%BA%9B%E7%BB%86%E8%8A%82%E8%A6%81%E6%B3%A8%E6%84%8F"><span class="toc-number">8.</span> <span class="toc-text">七、踩过的坑：这些细节要注意</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84-this-%E9%99%B7%E9%98%B1"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 箭头函数的 this 陷阱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 控制并发数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%EF%BC%88%E7%BB%93%E5%90%88-AbortSignal%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 可取消的异步任务（结合 AbortSignal）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94%EF%BC%88%E6%88%91%E5%BD%93%E5%88%9D%E5%AD%A6%E7%9A%84%E6%97%B6%E5%80%99%E4%B9%9F%E7%BA%A0%E7%BB%93%E8%BF%87%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">八、常见问题解答（我当初学的时候也纠结过）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Q1-Async-%E5%87%BD%E6%95%B0%E4%BC%9A%E9%98%BB%E5%A1%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">Q1: Async 函数会阻塞主线程吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q2-%E5%8F%AF%E4%BB%A5-await-%E4%B8%80%E4%B8%AA%E9%9D%9E-Promise-%E5%80%BC%E5%90%97%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">Q2: 可以 await 一个非 Promise 值吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q3-%E4%B8%BA%E4%BB%80%E4%B9%88-Async-%E5%87%BD%E6%95%B0%E4%B8%8D%E7%AE%A1-return-%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%80%E5%90%8E%E9%83%BD%E8%BF%94%E5%9B%9E-Promise%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">Q3: 为什么 Async 函数不管 return 什么，最后都返回 Promise？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q4-%E7%94%A8-Promise-all-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%A4%B1%E8%B4%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">9.4.</span> <span class="toc-text">Q4: 用 Promise.all()的时候，如果有一个请求失败怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Async-Await-%E6%AF%94%E5%9B%9E%E8%B0%83%E5%A5%BD%EF%BC%9F"><span class="toc-number">9.5.</span> <span class="toc-text">Q5: 为什么说 Async&#x2F;Await 比回调好？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/15/proxy/" title="代理（Proxy）：ES6 元编程的“对象拦截器”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/proxy.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代理（Proxy）：ES6 元编程的“对象拦截器”"/></a><div class="content"><a class="title" href="/2024/08/15/proxy/" title="代理（Proxy）：ES6 元编程的“对象拦截器”">代理（Proxy）：ES6 元编程的“对象拦截器”</a><time datetime="2024-08-15T12:46:25.000Z" title="发表于 2024-08-15 20:46:25">2024-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/14/reflect/" title="Reflect：ES6 标准化对象操作的“工具库”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/reflect.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Reflect：ES6 标准化对象操作的“工具库”"/></a><div class="content"><a class="title" href="/2024/08/14/reflect/" title="Reflect：ES6 标准化对象操作的“工具库”">Reflect：ES6 标准化对象操作的“工具库”</a><time datetime="2024-08-14T12:46:25.000Z" title="发表于 2024-08-14 20:46:25">2024-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/13/async&amp;await/" title="Async/Await：用同步的方式写异步，真香！"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/async.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Async/Await：用同步的方式写异步，真香！"/></a><div class="content"><a class="title" href="/2024/07/13/async&amp;await/" title="Async/Await：用同步的方式写异步，真香！">Async/Await：用同步的方式写异步，真香！</a><time datetime="2024-07-13T12:46:25.000Z" title="发表于 2024-07-13 20:46:25">2024-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/11/generator/" title="生成器函数与 yield：掌控函数执行的“暂停键”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/generator.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="生成器函数与 yield：掌控函数执行的“暂停键”"/></a><div class="content"><a class="title" href="/2024/07/11/generator/" title="生成器函数与 yield：掌控函数执行的“暂停键”">生成器函数与 yield：掌控函数执行的“暂停键”</a><time datetime="2024-07-11T12:46:25.000Z" title="发表于 2024-07-11 20:46:25">2024-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/23/message-channel/" title="MessageChannel 详解：浏览器中的“点对点双向通信管道”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/message-channel.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessageChannel 详解：浏览器中的“点对点双向通信管道”"/></a><div class="content"><a class="title" href="/2024/06/23/message-channel/" title="MessageChannel 详解：浏览器中的“点对点双向通信管道”">MessageChannel 详解：浏览器中的“点对点双向通信管道”</a><time datetime="2024-06-23T12:46:25.000Z" title="发表于 2024-06-23 20:46:25">2024-06-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Touko" target="_blank">Touko</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["生活明朗&#44; 万物可爱&#44; 人间值得&#44; 未来可期."]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/ES2017-ES8/" style="font-size: 0.88rem;">ES2017(ES8)<sup>1</sup></a><a href="/tags/ES6/" style="font-size: 0.88rem;">ES6<sup>6</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem; font-weight: 500; color: var(--anzhiyu-lighttext)">JavaScript<sup>10</sup></a><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 0.88rem;">性能优化<sup>6</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"><a class="tag-list" href="/tags/JavaScript" title="JavaScript">JavaScript</a><a class="tag-list" href="/tags/Vue" title="Vue">Vue</a></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.2/dist/svg-pan-zoom.min.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [`叮！可爱加载中... `, `🐱`];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `%c ${ascll[0]} %c${ascll[1]}`,
      "color:white; background-color:#f0ad4e",
      ''
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "你正在访问 Touko 的博客.",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
          const svgElement = document.getElementById(mermaidID)
          const viewBox = svgElement.getAttribute('viewBox')
          const viewBoxValues = viewBox.split(/[\s,]+/)
          window.svgPanZoom ? svgPanZoom(svgElement, { contain: true, controlIconsEnabled: true }) : ''
          const width = Number(getComputedStyle(svgElement).getPropertyValue('width').slice(0, -2))
          svgElement.setAttribute('height', `${viewBoxValues[3] * width / viewBoxValues[2]}px`)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'BsIRp7GQE8IZ5fkI0JRj8Vys-gzGzoHsz',
      appKey: 'vla82YKrFnfwtuQfgoaDnzu9',
      avatar: 'mp',
      serverURLs: 'https://bsirp7gq.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://bsirp7gq.lc-cn-n1-shared.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'BsIRp7GQE8IZ5fkI0JRj8Vys-gzGzoHsz',
        "X-LC-Key": 'vla82YKrFnfwtuQfgoaDnzu9',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@touko.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>