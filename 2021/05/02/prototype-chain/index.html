<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心 | Touko</title><meta name="keywords" content="JavaScript,ES6,性能优化"><meta name="author" content="Touko"><meta name="copyright" content="Touko"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心"><meta name="application-name" content="原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心"><meta property="og:url" content="http://toukoxu.github.io/2021/05/02/prototype-chain/index.html"><meta property="og:site_name" content="Touko"><meta property="og:description" content="原型链是 JavaScript 面向对象的“底层逻辑”——它让对象能“继承”其他对象的属性和方法，而 ES6 的 class 只是这套逻辑的“语法糖”。今天从原型链的本质讲到 Class 的应用，帮你彻底搞懂 JS 继承到底是怎么回事。  一、原型链：JS 对象继承的“底层骨架”1.1 什么是原型"><meta property="og:locale" content="zh"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/prototype-chain.webp"><meta property="article:author" content="Touko"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/prototype-chain.webp"><meta name="description" content="原型链是 JavaScript 面向对象的“底层逻辑”——它让对象能“继承”其他对象的属性和方法，而 ES6 的 class 只是这套逻辑的“语法糖”。今天从原型链的本质讲到 Class 的应用，帮你彻底搞懂 JS 继承到底是怎么回事。  一、原型链：JS 对象继承的“底层骨架”1.1 什么是原型"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://toukoxu.github.io/2021/05/02/prototype-chain/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 科技爱好者","🔨 开发一条龙","🌌 Hello World 宇宙","⌨️ 键盘撸猫区","🐱 万物皆可rua"]},
  algolia: {"appId":"SVGIUL6D7W","apiKey":"aee53519dcfc6f122cfe52009938fc1c","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本文最后一次更新为","messageNext":"天前，文章中的某些内容可能已过时！"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Touko","link":"链接: ","source":"来源: Touko","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Touko',
  title: '原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心',
  postAI: '',
  pageFillDescription: '一、原型链：JS 对象继承的底层骨架, 1.1 什么是原型链？, 1.2 原型链的三个核心概念, 二、原型链是怎么造出来的？, 2.1 用构造函数创建对象：原型链的常见来源, 2.2 new 操作符的底层逻辑, 三、原型链的查找规则：属性是怎么找到的？, 3.1 属性查找的完整流程, 3.2 原型链的终点：null, 四、原型链的动态特性：改原型会影响实例吗？, 4.1 动态修改原型：已创建的实例也会受影响, 4.2 重写原型：旧实例不受影响, 五、ES6 Class：原型链的语法糖, 5.1 Class 本质：还是原型继承, 5.2 Class 继承：extends 怎么工作？, 六、原型链的实际用途：这些场景会用到, 6.1 共享方法：节省内存, 6.2 实现自定义继承（ES5 写法）, 6.3 扩展内置对象（谨慎使用）, 七、原型链的坑：这些问题要注意, 7.1 原型污染：修改内置原型影响所有对象, 7.2 实例属性遮蔽原型属性, 7.3 循环引用：导致栈溢出, 八、原型链最佳实践：写代码更安全, 最后小测验原型链是面向对象的底层逻辑它让对象能继承其他对象的属性和方法而的只是这套逻辑的语法糖今天从原型链的本质讲到的应用帮你彻底搞懂继承到底是怎么回事一原型链对象继承的底层骨架什么是原型链简单说原型链是实现继承的核心机制每个对象都有一个隐藏的原型可通过访问这个原型本身也是一个对象它也有自己的原型这样层层向上就形成了一条原型链当你访问一个对象的属性时如果当前对象没有这个属性会自动沿着原型链向上查找直到找到属性或走到链的尽头看个直观的例子父对象动物有一个共享属性子对象兔子有自己的属性把的原型设为让兔子继承动物的属性现在兔子能访问动物的属性了从原型链上找到的原型链的三个核心概念要理解原型链必须分清这三个容易混淆的概念只有函数才有这个属性它是一个对象存储着该函数创建的实例要继承的属性和方法比如里的方法会被所有出来的实例继承所有对象包括函数都有的隐藏属性指向该对象的原型对象可通过访问旧版的已不推荐使用原型对象上的属性指向创建该原型对应的实例的构造函数比如它们的关系可以用一张图表示实例对象如构造函数的所有对象的最终原型原型链的终点构造函数二原型链是怎么造出来的用构造函数创建对象原型链的常见来源我们平时用构造函数创建对象时原型链会自动生成比如定义构造函数用来创建人实例实例独有的属性每个实例的都不同在构造函数的上定义共享方法所有实例共用你好我是用创建实例验证原型关系实例的原型是构造函数的原型的构造函数指向原函数操作符的底层逻辑你可能好奇到底做了什么能让实例和原型链关联起来其实它只干了四件事创建一个空对象把这个空对象的原型设为构造函数的执行构造函数把指向这个空对象给对象加属性如果构造函数没有返回其他对象就返回这个新对象否则返回构造函数的返回值我们可以手动模拟一个操作符更直观地看到这个过程创建空对象并把它的原型设为构造函数的执行构造函数指向新对象返回结果如果构造函数返回了对象就用它否则用新对象用自定义的创建实例和原生效果一样你好我是三原型链的查找规则属性是怎么找到的属性查找的完整流程当你访问时会按以下步骤查找先检查自身有没有通过可判断如果没有就找的原型检查原型有没有如果原型也没有就找原型的原型以此类推直到找到并返回或者走到原型链尽头返回看个例子理解这个流程定义构造函数实例独有的属性在上定义共享方法在吃东西创建实例喵星人调用查找流程检查自身没有方法查的原型找到方法执行喵星人在吃东西原型链的终点所有原型链的最终尽头都是因为的原型就是它是所有对象的最终原型除了用创建的纯净对象喵星人顺着原型链往上找第一层第二层第三层终点报错没有原型这也解释了为什么所有对象都能调用等方法这些方法其实定义在上所有对象都能通过原型链找到它们四原型链的动态特性改原型会影响实例吗动态修改原型已创建的实例也会受影响的原型是活的即使实例已经创建后续给原型添加的属性方法实例也能访问到创建实例此时上还没有方法后续给添加方法汪汪能调用到新添加的方法汪汪这是因为实例访问的是原型的引用而不是原型的副本原型变了所有指向它的实例都会跟着变重写原型旧实例不受影响但如果是完全重写原型而不是修改原型的属性情况就不一样了重写后的原型是一个新对象只有重写后创建的实例会用新原型之前的旧实例还是指向原来的原型旧实例创建于原型重写前完全重写新对象喵喵新实例创建于原型重写后报错的原型还是原来的空对象没有方法喵喵的原型是新对象有方法五原型链的语法糖本质还是原型继承引入的语法看起来像其他语言的类但底层还是基于原型链实现的它只是把原型继承的写法变得更简洁更易读没有改变的底层逻辑比如下面两段代码功能完全一样写法构造函数对应原来的构造函数实例方法会被添加到上在吃东西写法原型继承和上面完全等价在吃东西继承怎么工作的关键字本质是帮我们自动搭建了原型链比如让继承子类继承父类调用父类的相当于子类独有的属性子类独有的方法添加到上跳得很快速度创建子类实例小兔验证继承关系是的实例也是的实例因为继承最终继承自调用继承的方法和自己的方法小兔在吃东西继承自小兔跳得很快速度自己的方法做的核心事情把的原型设为从而搭建起的原型链六原型链的实际用途这些场景会用到共享方法节省内存如果多个实例需要用同一个方法把方法放在原型上而不是每个实例都定义一次能大幅节省内存因为所有实例共享同一个方法引用每个实例独有的属性所有实例共享方法你好验证两个实例的是同一个函数如果把写在构造函数里每个实例都会有一个独立的函数副本内存占用会翻倍实现自定义继承写法在出现前我们用原型链手动实现继承比如让继承父类图形父类的共享方法子类圆形调用父类构造函数继承父类的属性子类独有的属性搭建原型链让继承修复指向因为上面一步把换成了新对象会指向子类的共享方法使用子类继承自自己的方法扩展内置对象谨慎使用我们可以给内置对象的原型添加方法让所有该类型的对象都能使用比如给数组加一个方法给加方法所有数组都能调用注意扩展内置原型有风险可能和其他库的方法重名比如别人也给数组加了方法导致代码冲突非必要不推荐用注意扩展内置原型有风险可能和其他库的方法重名比如别人也给数组加了方法导致代码冲突非必要不推荐用七原型链的坑这些问题要注意原型污染修改内置原型影响所有对象如果恶意代码或不小心修改了所有对象都会受到影响这就是原型污染比如不小心给加了一个方法所有对象都会有这个方法即使是新建的空对象也会有方法所有对象都会有这个方法解决方案用创建纯净对象这种对象没有原型是不会继承的属性也就不会被污染不受原型污染影响实例属性遮蔽原型属性如果实例有一个和原型同名的属性实例属性会覆盖原型属性这叫属性遮蔽原型上的属性原型默认名实例上的属性和原型同名实例自定义名访问时会优先用实例的属性实例自定义名要访问原型的属性需要手动找原型原型默认名循环引用导致栈溢出如果两个构造函数的原型互相指向对方会形成循环原型链创建实例时会报错的原型指向的实例的原型指向的实例循环引用尝试创建实例会触发无限递归栈溢出八原型链最佳实践写代码更安全优先用语法和比手动改原型更清晰不容易出错比如不用用标准方法操作原型查原型替代改原型替代创建带原型的对象比更灵活属性和方法分开放构造函数里定义实例独有的属性原型上定义所有实例共享的方法符合内存高效利用的原则实例独有属性共享方法避免修改内置原型除非有绝对必要否则不要给等加方法防止冲突最后小测验看看你有没有掌握原型链的核心逻辑下面代码会输出什么答案是的实例继承自所以为是一个普通对象继承自所以为创建的实例原型就是所以第三个判断为原型链虽然是的底层概念但理解它能帮你避开很多隐藏的坑比如原型污染属性遮蔽也能让你更懂的本质不是新的继承方式只是原型链的优雅包装掌握这些你对面向对象的理解会更上一层楼',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-02 20:46:25',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link href="https://fonts.cdnfonts.com/css/shina-baby" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/site/loading.webp"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Touko</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/wechat.webp" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/wechat.webp"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/alipay.webp" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/alipay.webp"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/ES2017-ES8/" style="font-size: 1.05rem;">ES2017(ES8)<sup>1</sup></a><a href="/tags/ES6/" style="font-size: 1.05rem;">ES6<sup>6</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>10</sup></a><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 1.05rem;">性能优化<sup>6</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">August 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">July 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">June 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">February 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">May 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/04/"><span class="card-archive-list-date">April 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/03/"><span class="card-archive-list-date">March 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JavaScript/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JavaScript</span></a><a class="article-meta__tags" href="/tags/ES6/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>ES6</span></a><a class="article-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>性能优化</span></a></span></div></div><h1 class="post-title" itemprop="name headline">原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2021-05-02T12:46:25.000Z" title="发表于 2021-05-02 20:46:25">2021-05-02</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2021-05-02T12:46:25.000Z" title="更新于 2021-05-02 20:46:25">2021-05-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">3.7k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为上海"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>上海</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/prototype-chain.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://toukoxu.github.io/2021/05/02/prototype-chain/"><header><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a><a href="/tags/JavaScript/" tabindex="-1" itemprop="url">JavaScript</a><a href="/tags/ES6/" tabindex="-1" itemprop="url">ES6</a><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" tabindex="-1" itemprop="url">性能优化</a><h1 id="CrawlerTitle" itemprop="name headline">原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Touko</span><time itemprop="dateCreated datePublished" datetime="2021-05-02T12:46:25.000Z" title="发表于 2021-05-02 20:46:25">2021-05-02</time><time itemprop="dateCreated datePublished" datetime="2021-05-02T12:46:25.000Z" title="更新于 2021-05-02 20:46:25">2021-05-02</time></header><blockquote>
<p>原型链是 JavaScript 面向对象的“底层逻辑”——它让对象能“继承”其他对象的属性和方法，而 ES6 的 <code>class</code> 只是这套逻辑的“语法糖”。今天从原型链的本质讲到 Class 的应用，帮你彻底搞懂 JS 继承到底是怎么回事。</p>
</blockquote>
<h2 id="一、原型链：JS-对象继承的“底层骨架”"><a href="#一、原型链：JS-对象继承的“底层骨架”" class="headerlink" title="一、原型链：JS 对象继承的“底层骨架”"></a>一、原型链：JS 对象继承的“底层骨架”</h2><h3 id="1-1-什么是原型链？"><a href="#1-1-什么是原型链？" class="headerlink" title="1.1 什么是原型链？"></a>1.1 什么是原型链？</h3><p>简单说，<strong>原型链是 JS 实现继承的核心机制</strong>：每个对象都有一个隐藏的“原型”（<code>[[Prototype]]</code>，可通过 <code>Object.getPrototypeOf()</code> 访问），这个原型本身也是一个对象，它也有自己的原型——这样层层向上，就形成了一条“原型链”。</p>
<p>当你访问一个对象的属性时，如果当前对象没有这个属性，JS 会自动沿着原型链向上查找，直到找到属性或走到链的尽头（<code>null</code>）。</p>
<p>看个直观的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父对象：动物，有一个共享属性 eats</span></span><br><span class="line"><span class="keyword">const</span> animal = &#123; <span class="attr">eats</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子对象：兔子，有自己的属性 jumps</span></span><br><span class="line"><span class="keyword">const</span> rabbit = &#123; <span class="attr">jumps</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 rabbit 的原型设为 animal（让兔子继承动物的属性）</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(rabbit, animal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在兔子能访问动物的 eats 属性了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rabbit.<span class="property">eats</span>); <span class="comment">// true（从原型链上找到的）</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-原型链的三个核心概念"><a href="#1-2-原型链的三个核心概念" class="headerlink" title="1.2 原型链的三个核心概念"></a>1.2 原型链的三个核心概念</h3><p>要理解原型链，必须分清这三个容易混淆的概念：</p>
<ol>
<li><strong><code>prototype</code></strong>：只有<strong>函数</strong>才有这个属性，它是一个对象，存储着“该函数创建的实例要继承的属性和方法”（比如 <code>Person.prototype</code> 里的方法，会被所有 <code>new Person()</code> 出来的实例继承）。</li>
<li><strong><code>[[Prototype]]</code></strong>：所有对象（包括函数）都有的隐藏属性，指向该对象的“原型对象”（可通过 <code>Object.getPrototypeOf(obj)</code> 访问，旧版的 <code>__proto__</code> 已不推荐使用）。</li>
<li><strong><code>constructor</code></strong>：原型对象上的属性，指向“创建该原型对应的实例的构造函数”（比如 <code>Person.prototype.constructor === Person</code>）。</li>
</ol>
<p>它们的关系可以用一张图表示：</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  graph LR
A[实例对象（如 new Person()）] --&gt;|[[Prototype]]| B[构造函数的 prototype（Person.prototype）]
B --&gt;|[[Prototype]]| C[Object.prototype（所有对象的最终原型）]
C --&gt;|[[Prototype]]| D[null（原型链的终点）]
B --&gt;|constructor| E[构造函数（Person）]
  </pre></div>

<h2 id="二、原型链是怎么“造”出来的？"><a href="#二、原型链是怎么“造”出来的？" class="headerlink" title="二、原型链是怎么“造”出来的？"></a>二、原型链是怎么“造”出来的？</h2><h3 id="2-1-用构造函数创建对象：原型链的常见来源"><a href="#2-1-用构造函数创建对象：原型链的常见来源" class="headerlink" title="2.1 用构造函数创建对象：原型链的常见来源"></a>2.1 用构造函数创建对象：原型链的常见来源</h3><p>我们平时用 <code>new 构造函数()</code> 创建对象时，原型链会自动生成。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义构造函数（用来创建“人”实例）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 实例独有的属性：每个实例的 name 都不同</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在构造函数的 prototype 上定义共享方法（所有实例共用）</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`你好，我是<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 用 new 创建实例</span></span><br><span class="line"><span class="keyword">const</span> alice = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证原型关系</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(alice) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true（实例的原型是构造函数的 prototype）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true（原型的构造函数指向原函数）</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-new-操作符的底层逻辑"><a href="#2-2-new-操作符的底层逻辑" class="headerlink" title="2.2 new 操作符的底层逻辑"></a>2.2 <code>new</code> 操作符的底层逻辑</h3><p>你可能好奇：<code>new</code> 到底做了什么，能让实例和原型链关联起来？其实它只干了四件事：</p>
<ol>
<li>创建一个空对象（<code>&#123;&#125;</code>）；</li>
<li>把这个空对象的原型，设为构造函数的 <code>prototype</code>；</li>
<li>执行构造函数，把 <code>this</code> 指向这个空对象（给对象加属性）；</li>
<li>如果构造函数没有返回其他对象，就返回这个新对象（否则返回构造函数的返回值）。</li>
</ol>
<p>我们可以手动模拟一个 <code>new</code> 操作符，更直观地看到这个过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">constructor, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 创建空对象，并把它的原型设为构造函数的 prototype</span></span><br><span class="line">  <span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 执行构造函数，this 指向新对象</span></span><br><span class="line">  <span class="keyword">const</span> result = constructor.<span class="title function_">apply</span>(obj, args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 返回结果：如果构造函数返回了对象，就用它；否则用新对象</span></span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用自定义的 myNew 创建实例，和原生 new 效果一样</span></span><br><span class="line"><span class="keyword">const</span> bob = <span class="title function_">myNew</span>(<span class="title class_">Person</span>, <span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line">bob.<span class="title function_">sayHello</span>(); <span class="comment">// 你好，我是Bob</span></span><br></pre></td></tr></table></figure>

<h2 id="三、原型链的“查找规则”：属性是怎么找到的？"><a href="#三、原型链的“查找规则”：属性是怎么找到的？" class="headerlink" title="三、原型链的“查找规则”：属性是怎么找到的？"></a>三、原型链的“查找规则”：属性是怎么找到的？</h2><h3 id="3-1-属性查找的完整流程"><a href="#3-1-属性查找的完整流程" class="headerlink" title="3.1 属性查找的完整流程"></a>3.1 属性查找的完整流程</h3><p>当你访问 <code>obj.prop</code> 时，JS 会按以下步骤查找：</p>
<ol>
<li>先检查 <code>obj</code> 自身有没有 <code>prop</code>（通过 <code>obj.hasOwnProperty(&#39;prop&#39;)</code> 可判断）；</li>
<li>如果没有，就找 <code>obj</code> 的原型（<code>Object.getPrototypeOf(obj)</code>），检查原型有没有 <code>prop</code>；</li>
<li>如果原型也没有，就找原型的原型，以此类推；</li>
<li>直到找到 <code>prop</code> 并返回，或者走到原型链尽头（<code>null</code>），返回 <code>undefined</code>。</li>
</ol>
<p>看个例子理解这个流程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义构造函数 Animal</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 实例独有的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在 Animal.prototype 上定义共享方法</span></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> 在吃东西`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建实例 cat</span></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;喵星人&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 调用 cat.eat()，查找流程：</span></span><br><span class="line"><span class="comment">// ① 检查 cat 自身：没有 eat 方法 → ② 查 cat 的原型（Animal.prototype）→ 找到 eat 方法，执行</span></span><br><span class="line">cat.<span class="title function_">eat</span>(); <span class="comment">// 喵星人 在吃东西</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-原型链的终点：null"><a href="#3-2-原型链的终点：null" class="headerlink" title="3.2 原型链的终点：null"></a>3.2 原型链的终点：<code>null</code></h3><p>所有原型链的最终尽头都是 <code>null</code>——因为 <code>Object.prototype</code> 的原型就是 <code>null</code>，它是“所有对象的最终原型”（除了用 <code>Object.create(null)</code> 创建的“纯净对象”）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;喵星人&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺着原型链往上找：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(cat)); <span class="comment">// Animal.prototype（第一层）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>)); <span class="comment">// Object.prototype（第二层）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)); <span class="comment">// null（第三层，终点）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">null</span>)); <span class="comment">// 报错（null 没有原型）</span></span><br></pre></td></tr></table></figure>

<p>这也解释了为什么所有对象都能调用 <code>toString()</code>、<code>hasOwnProperty()</code> 等方法——这些方法其实定义在 <code>Object.prototype</code> 上，所有对象都能通过原型链找到它们。</p>
<h2 id="四、原型链的“动态特性”：改原型会影响实例吗？"><a href="#四、原型链的“动态特性”：改原型会影响实例吗？" class="headerlink" title="四、原型链的“动态特性”：改原型会影响实例吗？"></a>四、原型链的“动态特性”：改原型会影响实例吗？</h2><h3 id="4-1-动态修改原型：已创建的实例也会受影响"><a href="#4-1-动态修改原型：已创建的实例也会受影响" class="headerlink" title="4.1 动态修改原型：已创建的实例也会受影响"></a>4.1 动态修改原型：已创建的实例也会受影响</h3><p>JS 的原型是“活的”——即使实例已经创建，后续给原型添加的属性&#x2F;方法，实例也能访问到：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 创建实例 dog1（此时 Dog.prototype 上还没有 bark 方法）</span></span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续给 Dog.prototype 添加 bark 方法</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bark</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;汪汪！&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog1 能调用到新添加的 bark 方法</span></span><br><span class="line">dog1.<span class="title function_">bark</span>(); <span class="comment">// 汪汪！</span></span><br></pre></td></tr></table></figure>

<p>这是因为实例访问的是“原型的引用”，而不是“原型的副本”——原型变了，所有指向它的实例都会跟着变。</p>
<h3 id="4-2-重写原型：旧实例不受影响"><a href="#4-2-重写原型：旧实例不受影响" class="headerlink" title="4.2 重写原型：旧实例不受影响"></a>4.2 重写原型：旧实例不受影响</h3><p>但如果是“完全重写原型”（而不是修改原型的属性），情况就不一样了：重写后的原型是一个新对象，只有重写后创建的实例会用新原型，之前的旧实例还是指向原来的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 旧实例：创建于原型重写前</span></span><br><span class="line"><span class="keyword">const</span> cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完全重写 Cat.prototype（新对象）</span></span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="title function_">meow</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;喵喵~&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新实例：创建于原型重写后</span></span><br><span class="line"><span class="keyword">const</span> cat2 = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">cat1.<span class="title function_">meow</span>(); <span class="comment">// 报错（cat1 的原型还是原来的空对象，没有 meow 方法）</span></span><br><span class="line">cat2.<span class="title function_">meow</span>(); <span class="comment">// 喵喵~（cat2 的原型是新对象，有 meow 方法）</span></span><br></pre></td></tr></table></figure>

<h2 id="五、ES6-Class：原型链的“语法糖”"><a href="#五、ES6-Class：原型链的“语法糖”" class="headerlink" title="五、ES6 Class：原型链的“语法糖”"></a>五、ES6 Class：原型链的“语法糖”</h2><h3 id="5-1-Class-本质：还是原型继承"><a href="#5-1-Class-本质：还是原型继承" class="headerlink" title="5.1 Class 本质：还是原型继承"></a>5.1 Class 本质：还是原型继承</h3><p>ES6 引入的 <code>class</code> 语法，看起来像其他语言的“类”，但底层还是基于原型链实现的——它只是把原型继承的写法变得更简洁、更易读，没有改变 JS 的底层逻辑。</p>
<p>比如下面两段代码，功能完全一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法1：ES6 Class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="comment">// 构造函数：对应原来的构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例方法：会被添加到 Animal.prototype 上</span></span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> 在吃东西`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2：ES5 原型继承（和上面完全等价）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> 在吃东西`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-Class-继承：extends-怎么工作？"><a href="#5-2-Class-继承：extends-怎么工作？" class="headerlink" title="5.2 Class 继承：extends 怎么工作？"></a>5.2 Class 继承：<code>extends</code> 怎么工作？</h3><p>Class 的 <code>extends</code> 关键字，本质是帮我们自动搭建了原型链。比如让 <code>Rabbit</code> 继承 <code>Animal</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类 Rabbit 继承父类 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, speed</span>) &#123;</span><br><span class="line">    <span class="comment">// super()：调用父类的 constructor，相当于 Animal.call(this, name)</span></span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="comment">// 子类独有的属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = speed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子类独有的方法（添加到 Rabbit.prototype 上）</span></span><br><span class="line">  <span class="title function_">jump</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> 跳得很快，速度<span class="subst">$&#123;<span class="variable language_">this</span>.speed&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子类实例</span></span><br><span class="line"><span class="keyword">const</span> bunny = <span class="keyword">new</span> <span class="title class_">Rabbit</span>(<span class="string">&#x27;小兔&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证继承关系</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bunny <span class="keyword">instanceof</span> <span class="title class_">Rabbit</span>); <span class="comment">// true（是 Rabbit 的实例）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bunny <span class="keyword">instanceof</span> <span class="title class_">Animal</span>); <span class="comment">// true（也是 Animal 的实例，因为继承）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bunny <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true（最终继承自 Object）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用继承的方法和自己的方法</span></span><br><span class="line">bunny.<span class="title function_">eat</span>(); <span class="comment">// 小兔 在吃东西（继承自 Animal）</span></span><br><span class="line">bunny.<span class="title function_">jump</span>(); <span class="comment">// 小兔 跳得很快，速度10（自己的方法）</span></span><br></pre></td></tr></table></figure>

<p><code>extends</code> 做的核心事情：把 <code>Rabbit.prototype</code> 的原型，设为 <code>Animal.prototype</code>，从而搭建起“<code>bunny</code> → <code>Rabbit.prototype</code> → <code>Animal.prototype</code> → <code>Object.prototype</code> → <code>null</code>”的原型链。</p>
<h2 id="六、原型链的实际用途：这些场景会用到"><a href="#六、原型链的实际用途：这些场景会用到" class="headerlink" title="六、原型链的实际用途：这些场景会用到"></a>六、原型链的实际用途：这些场景会用到</h2><h3 id="6-1-共享方法：节省内存"><a href="#6-1-共享方法：节省内存" class="headerlink" title="6.1 共享方法：节省内存"></a>6.1 共享方法：节省内存</h3><p>如果多个实例需要用同一个方法，把方法放在原型上（而不是每个实例都定义一次），能大幅节省内存——因为所有实例共享同一个方法引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 每个实例独有的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 User 实例共享 sayHi 方法</span></span><br><span class="line"><span class="title class_">User</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`你好，<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> user2 = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证：两个实例的 sayHi 是同一个函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user1.<span class="property">sayHi</span> === user2.<span class="property">sayHi</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果把 <code>sayHi</code> 写在构造函数里（<code>this.sayHi = function() &#123;&#125;</code>），每个实例都会有一个独立的函数副本，内存占用会翻倍。</p>
<h3 id="6-2-实现自定义继承（ES5-写法）"><a href="#6-2-实现自定义继承（ES5-写法）" class="headerlink" title="6.2 实现自定义继承（ES5 写法）"></a>6.2 实现自定义继承（ES5 写法）</h3><p>在 Class 出现前，我们用原型链手动实现继承。比如让 <code>Circle</code> 继承 <code>Shape</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类：图形</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Shape</span>(<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类的共享方法</span></span><br><span class="line"><span class="title class_">Shape</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getColor</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：圆形</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius, color</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 调用父类构造函数，继承父类的属性（color）</span></span><br><span class="line">  <span class="title class_">Shape</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, color);</span><br><span class="line">  <span class="comment">// 2. 子类独有的属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 搭建原型链：让 Circle.prototype 继承 Shape.prototype</span></span><br><span class="line"><span class="title class_">Circle</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Shape</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 4. 修复 constructor 指向（因为上面一步把 Circle.prototype 换成了新对象，constructor 会指向 Shape）</span></span><br><span class="line"><span class="title class_">Circle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Circle</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 子类的共享方法</span></span><br><span class="line"><span class="title class_">Circle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getArea</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用子类</span></span><br><span class="line"><span class="keyword">const</span> redCircle = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(redCircle.<span class="title function_">getColor</span>()); <span class="comment">// red（继承自 Shape）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(redCircle.<span class="title function_">getArea</span>()); <span class="comment">// 78.539...（自己的方法）</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-扩展内置对象（谨慎使用）"><a href="#6-3-扩展内置对象（谨慎使用）" class="headerlink" title="6.3 扩展内置对象（谨慎使用）"></a>6.3 扩展内置对象（谨慎使用）</h3><p>我们可以给内置对象的原型添加方法，让所有该类型的对象都能使用。比如给数组加一个 <code>sum</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 Array.prototype 加 sum 方法，所有数组都能调用</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sum</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, num</span>) =&gt;</span> total + num, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers.<span class="title function_">sum</span>()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ 注意：扩展内置原型有风险！可能和其他库的方法重名（比如别人也给数组加了 <code>sum</code> 方法），导致代码冲突。非必要不推荐用。</p>
</blockquote>
<div class="note warning flat"><p><strong>注意：</strong> 扩展内置原型有风险！可能和其他库的方法重名（比如别人也给数组加了 `sum` 方法），导致代码冲突。非必要不推荐用。</div>

<h2 id="七、原型链的坑：这些问题要注意"><a href="#七、原型链的坑：这些问题要注意" class="headerlink" title="七、原型链的坑：这些问题要注意"></a>七、原型链的坑：这些问题要注意</h2><h3 id="7-1-原型污染：修改内置原型影响所有对象"><a href="#7-1-原型污染：修改内置原型影响所有对象" class="headerlink" title="7.1 原型污染：修改内置原型影响所有对象"></a>7.1 原型污染：修改内置原型影响所有对象</h3><p>如果恶意代码（或不小心）修改了 <code>Object.prototype</code>，所有对象都会受到影响——这就是“原型污染”。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不小心给 Object.prototype 加了一个 hack 方法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hack</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有对象都会有这个方法！&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使是新建的空对象，也会有 hack 方法</span></span><br><span class="line"><span class="keyword">const</span> emptyObj = &#123;&#125;;</span><br><span class="line">emptyObj.<span class="title function_">hack</span>(); <span class="comment">// 所有对象都会有这个方法！</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong>：用 <code>Object.create(null)</code> 创建“纯净对象”——这种对象没有原型（<code>[[Prototype]]</code> 是 <code>null</code>），不会继承 <code>Object.prototype</code> 的属性，也就不会被污染：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pureObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pureObj.<span class="property">hack</span>); <span class="comment">// undefined（不受原型污染影响）</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-实例属性“遮蔽”原型属性"><a href="#7-2-实例属性“遮蔽”原型属性" class="headerlink" title="7.2 实例属性“遮蔽”原型属性"></a>7.2 实例属性“遮蔽”原型属性</h3><p>如果实例有一个和原型同名的属性，实例属性会“覆盖”原型属性（这叫“属性遮蔽”）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 原型上的 name 属性</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;原型默认名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例上的 name 属性（和原型同名）</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;实例自定义名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问时会优先用实例的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// 实例自定义名</span></span><br><span class="line"><span class="comment">// 要访问原型的属性，需要手动找原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person).<span class="property">name</span>); <span class="comment">// 原型默认名</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-循环引用：导致栈溢出"><a href="#7-3-循环引用：导致栈溢出" class="headerlink" title="7.3 循环引用：导致栈溢出"></a>7.3 循环引用：导致栈溢出</h3><p>如果两个构造函数的原型互相指向对方，会形成“循环原型链”，创建实例时会报错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A 的原型指向 B 的实例</span></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line"><span class="comment">// B 的原型指向 A 的实例 → 循环引用！</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试创建实例：会触发无限递归，栈溢出</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(e.<span class="property">message</span>); <span class="comment">// Maximum call stack size exceeded</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、原型链最佳实践：写代码更安全"><a href="#八、原型链最佳实践：写代码更安全" class="headerlink" title="八、原型链最佳实践：写代码更安全"></a>八、原型链最佳实践：写代码更安全</h2><ol>
<li><p><strong>优先用 Class 语法</strong>：<code>class</code> 和 <code>extends</code> 比 ES5 手动改原型更清晰，不容易出错，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不用 <code>__proto__</code>，用标准方法操作原型</strong>：</p>
<ul>
<li>查原型：<code>Object.getPrototypeOf(obj)</code>（替代 <code>obj.__proto__</code>）</li>
<li>改原型：<code>Object.setPrototypeOf(obj, newProto)</code>（替代 <code>obj.__proto__ = newProto</code>）</li>
<li>创建带原型的对象：<code>Object.create(proto)</code>（比 <code>new</code> 更灵活）</li>
</ul>
</li>
<li><p><strong>属性和方法分开放</strong>：构造函数里定义“实例独有的属性”，原型上定义“所有实例共享的方法”——符合内存高效利用的原则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 实例独有属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// 共享方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免修改内置原型</strong>：除非有绝对必要，否则不要给 <code>Array.prototype</code>、<code>Object.prototype</code> 等加方法，防止冲突。</p>
</li>
</ol>
<h2 id="最后小测验"><a href="#最后小测验" class="headerlink" title="最后小测验"></a>最后小测验</h2><p>看看你有没有掌握原型链的核心逻辑，下面代码会输出什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(f1) === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br></pre></td></tr></table></figure>

<p><strong>答案</strong>：<code>true</code>、<code>true</code>、<code>true</code></p>
<ul>
<li><code>f1</code> 是 <code>Foo</code> 的实例，<code>Foo.prototype</code> 继承自 <code>Object.prototype</code>，所以 <code>f1 instanceof Object</code> 为 <code>true</code>；</li>
<li><code>Foo.prototype</code> 是一个普通对象，继承自 <code>Object.prototype</code>，所以 <code>Foo.prototype instanceof Object</code> 为 <code>true</code>；</li>
<li><code>new Foo()</code> 创建的实例，原型就是 <code>Foo.prototype</code>，所以第三个判断为 <code>true</code>。</li>
</ul>
<hr>
<p>原型链虽然是 JS 的“底层概念”，但理解它能帮你避开很多隐藏的坑（比如原型污染、属性遮蔽），也能让你更懂 Class 的本质——不是“新的继承方式”，只是原型链的优雅包装。掌握这些，你对 JS 面向对象的理解会更上一层楼～</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/site/avatar.webp" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/site/avatar.webp" title="头像" alt="头像"></a><div class="post-copyright__author_name">Touko</div><div class="post-copyright__author_desc">🐾猫爪按日出, 按出彩虹糖🌈</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://toukoxu.github.io/2021/05/02/prototype-chain/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://toukoxu.github.io/2021/05/02/prototype-chain/')">原型链（Prototype Chain）与 Class：吃透 JS 对象继承的核心</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/wechat.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/wechat.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/alipay.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/pay/alipay.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://toukoxu.github.io/2021/05/02/prototype-chain/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://toukoxu.github.io" target="_blank">Touko</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>前端<span class="categoryesPageCount">10</span></a><a class="post-meta__box__categoryes" href="/categories/%E5%89%8D%E7%AB%AF/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>学习笔记<span class="categoryesPageCount">10</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JavaScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JavaScript<span class="tagsPageCount">10</span></a><a class="post-meta__box__tags" href="/tags/ES6/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>ES6<span class="tagsPageCount">6</span></a><a class="post-meta__box__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>性能优化<span class="tagsPageCount">6</span></a></div></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/03/closure/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/closure.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">闭包（Closure）：JavaScript 里的“记忆小助手”</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/01/event/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/event.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JS 事件系统完全指南与性能优化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/08/15/proxy/" title="代理（Proxy）：ES6 元编程的“对象拦截器”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/proxy.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-08-15</div><div class="title">代理（Proxy）：ES6 元编程的“对象拦截器”</div></div></a></div><div><a href="/2024/06/14/iterator/" title="迭代器（Iterator）与解构：JS 数据遍历与拆箱的实用指南"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/iterator.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-14</div><div class="title">迭代器（Iterator）与解构：JS 数据遍历与拆箱的实用指南</div></div></a></div><div><a href="/2021/04/03/closure/" title="闭包（Closure）：JavaScript 里的“记忆小助手”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/closure.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-04-03</div><div class="title">闭包（Closure）：JavaScript 里的“记忆小助手”</div></div></a></div><div><a href="/2022/02/01/event/" title="JS 事件系统完全指南与性能优化"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/event.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-02-01</div><div class="title">JS 事件系统完全指南与性能优化</div></div></a></div><div><a href="/2024/07/13/async&await/" title="Async&#x2F;Await：用同步的方式写异步，真香！"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/async.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-07-13</div><div class="title">Async&#x2F;Await：用同步的方式写异步，真香！</div></div></a></div><div><a href="/2024/07/11/generator/" title="生成器函数与 yield：掌控函数执行的“暂停键”"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/generator.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-07-11</div><div class="title">生成器函数与 yield：掌控函数执行的“暂停键”</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/site/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/emoji/sparkles.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">欢迎来到我的<b style="color:#fff">编程小天地</b>！这里有可爱的<b style="color:#fff">编程知识点</b>，致力于把复杂的概念变得<b style="color:#fff">简单可爱</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">一起探索，让代码生活更精彩！</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Touko</h1><div class="author-info__desc">🐾猫爪按日出, 按出彩虹糖🌈</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/ToukoXu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">😊 欢迎来看我的博客鸭~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9AJS-%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E7%9A%84%E2%80%9C%E5%BA%95%E5%B1%82%E9%AA%A8%E6%9E%B6%E2%80%9D"><span class="toc-number">1.</span> <span class="toc-text">一、原型链：JS 对象继承的“底层骨架”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 什么是原型链？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 原型链的三个核心概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%98%AF%E6%80%8E%E4%B9%88%E2%80%9C%E9%80%A0%E2%80%9D%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">二、原型链是怎么“造”出来的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9A%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%B8%B8%E8%A7%81%E6%9D%A5%E6%BA%90"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 用构造函数创建对象：原型链的常见来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 new 操作符的底层逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E2%80%9C%E6%9F%A5%E6%89%BE%E8%A7%84%E5%88%99%E2%80%9D%EF%BC%9A%E5%B1%9E%E6%80%A7%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">三、原型链的“查找规则”：属性是怎么找到的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 属性查找的完整流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%88%E7%82%B9%EF%BC%9Anull"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 原型链的终点：null</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E2%80%9C%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7%E2%80%9D%EF%BC%9A%E6%94%B9%E5%8E%9F%E5%9E%8B%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%AE%9E%E4%BE%8B%E5%90%97%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">四、原型链的“动态特性”：改原型会影响实例吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%9E%8B%EF%BC%9A%E5%B7%B2%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B9%9F%E4%BC%9A%E5%8F%97%E5%BD%B1%E5%93%8D"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 动态修改原型：已创建的实例也会受影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%87%8D%E5%86%99%E5%8E%9F%E5%9E%8B%EF%BC%9A%E6%97%A7%E5%AE%9E%E4%BE%8B%E4%B8%8D%E5%8F%97%E5%BD%B1%E5%93%8D"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 重写原型：旧实例不受影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81ES6-Class%EF%BC%9A%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E2%80%9C%E8%AF%AD%E6%B3%95%E7%B3%96%E2%80%9D"><span class="toc-number">5.</span> <span class="toc-text">五、ES6 Class：原型链的“语法糖”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Class-%E6%9C%AC%E8%B4%A8%EF%BC%9A%E8%BF%98%E6%98%AF%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 Class 本质：还是原型继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Class-%E7%BB%A7%E6%89%BF%EF%BC%9Aextends-%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 Class 继承：extends 怎么工作？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%AE%9E%E9%99%85%E7%94%A8%E9%80%94%EF%BC%9A%E8%BF%99%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%BC%9A%E7%94%A8%E5%88%B0"><span class="toc-number">6.</span> <span class="toc-text">六、原型链的实际用途：这些场景会用到</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%85%B1%E4%BA%AB%E6%96%B9%E6%B3%95%EF%BC%9A%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 共享方法：节省内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%EF%BC%88ES5-%E5%86%99%E6%B3%95%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 实现自定义继承（ES5 写法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%89%A9%E5%B1%95%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%88%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 扩展内置对象（谨慎使用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%9D%91%EF%BC%9A%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E8%A6%81%E6%B3%A8%E6%84%8F"><span class="toc-number">7.</span> <span class="toc-text">七、原型链的坑：这些问题要注意</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%EF%BC%9A%E4%BF%AE%E6%94%B9%E5%86%85%E7%BD%AE%E5%8E%9F%E5%9E%8B%E5%BD%B1%E5%93%8D%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 原型污染：修改内置原型影响所有对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E2%80%9C%E9%81%AE%E8%94%BD%E2%80%9D%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 实例属性“遮蔽”原型属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%9A%E5%AF%BC%E8%87%B4%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 循环引用：导致栈溢出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%86%99%E4%BB%A3%E7%A0%81%E6%9B%B4%E5%AE%89%E5%85%A8"><span class="toc-number">8.</span> <span class="toc-text">八、原型链最佳实践：写代码更安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E5%B0%8F%E6%B5%8B%E9%AA%8C"><span class="toc-number">9.</span> <span class="toc-text">最后小测验</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/15/proxy/" title="代理（Proxy）：ES6 元编程的“对象拦截器”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/proxy.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代理（Proxy）：ES6 元编程的“对象拦截器”"/></a><div class="content"><a class="title" href="/2024/08/15/proxy/" title="代理（Proxy）：ES6 元编程的“对象拦截器”">代理（Proxy）：ES6 元编程的“对象拦截器”</a><time datetime="2024-08-15T12:46:25.000Z" title="发表于 2024-08-15 20:46:25">2024-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/14/reflect/" title="Reflect：ES6 标准化对象操作的“工具库”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/reflect.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Reflect：ES6 标准化对象操作的“工具库”"/></a><div class="content"><a class="title" href="/2024/08/14/reflect/" title="Reflect：ES6 标准化对象操作的“工具库”">Reflect：ES6 标准化对象操作的“工具库”</a><time datetime="2024-08-14T12:46:25.000Z" title="发表于 2024-08-14 20:46:25">2024-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/13/async&amp;await/" title="Async/Await：用同步的方式写异步，真香！"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/async.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Async/Await：用同步的方式写异步，真香！"/></a><div class="content"><a class="title" href="/2024/07/13/async&amp;await/" title="Async/Await：用同步的方式写异步，真香！">Async/Await：用同步的方式写异步，真香！</a><time datetime="2024-07-13T12:46:25.000Z" title="发表于 2024-07-13 20:46:25">2024-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/11/generator/" title="生成器函数与 yield：掌控函数执行的“暂停键”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/generator.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="生成器函数与 yield：掌控函数执行的“暂停键”"/></a><div class="content"><a class="title" href="/2024/07/11/generator/" title="生成器函数与 yield：掌控函数执行的“暂停键”">生成器函数与 yield：掌控函数执行的“暂停键”</a><time datetime="2024-07-11T12:46:25.000Z" title="发表于 2024-07-11 20:46:25">2024-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/23/message-channel/" title="MessageChannel 详解：浏览器中的“点对点双向通信管道”"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/toukoxu/picstore@main/images/cover/message-channel.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MessageChannel 详解：浏览器中的“点对点双向通信管道”"/></a><div class="content"><a class="title" href="/2024/06/23/message-channel/" title="MessageChannel 详解：浏览器中的“点对点双向通信管道”">MessageChannel 详解：浏览器中的“点对点双向通信管道”</a><time datetime="2024-06-23T12:46:25.000Z" title="发表于 2024-06-23 20:46:25">2024-06-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Touko" target="_blank">Touko</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["生活明朗&#44; 万物可爱&#44; 人间值得&#44; 未来可期."]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/ES2017-ES8/" style="font-size: 0.88rem;">ES2017(ES8)<sup>1</sup></a><a href="/tags/ES6/" style="font-size: 0.88rem;">ES6<sup>6</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem; font-weight: 500; color: var(--anzhiyu-lighttext)">JavaScript<sup>10</sup></a><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 0.88rem;">性能优化<sup>6</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"><a class="tag-list" href="/tags/JavaScript" title="JavaScript">JavaScript</a><a class="tag-list" href="/tags/Vue" title="Vue">Vue</a></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.2/dist/svg-pan-zoom.min.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [`叮！可爱加载中... `, `🐱`];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `%c ${ascll[0]} %c${ascll[1]}`,
      "color:white; background-color:#f0ad4e",
      ''
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "你正在访问 Touko 的博客.",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
          const svgElement = document.getElementById(mermaidID)
          const viewBox = svgElement.getAttribute('viewBox')
          const viewBoxValues = viewBox.split(/[\s,]+/)
          window.svgPanZoom ? svgPanZoom(svgElement, { contain: true, controlIconsEnabled: true }) : ''
          const width = Number(getComputedStyle(svgElement).getPropertyValue('width').slice(0, -2))
          svgElement.setAttribute('height', `${viewBoxValues[3] * width / viewBoxValues[2]}px`)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.cbd.int/mermaid@10.2.4/dist/mermaid.min.js').then(runMermaid)
  }

  anzhiyu.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'BsIRp7GQE8IZ5fkI0JRj8Vys-gzGzoHsz',
      appKey: 'vla82YKrFnfwtuQfgoaDnzu9',
      avatar: 'mp',
      serverURLs: 'https://bsirp7gq.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://bsirp7gq.lc-cn-n1-shared.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'BsIRp7GQE8IZ5fkI0JRj8Vys-gzGzoHsz',
        "X-LC-Key": 'vla82YKrFnfwtuQfgoaDnzu9',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@touko.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>